;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Glass, HEIGHT, MM_HEIGHT, MM_PER_PIXEL, MM_RULER, PIXEL_PER_MM, RULER_LENGTH, RULER_WIDTH, WGlass, WGlassGrafter, WHorizontalRuler, WIDTH, WVerticalRuler, canvas, cocktail_glass, cocktail_json, cocktail_representation, edit_canvas, erlenmeyer_json, export_glass, grafter, hruler, selected, vruler;

  export_glass = function(glass) {
    var export_string, w;

    export_string = cocktail_glass.to_full_json();
    w = window.open('');
    w.document.open('text/plain');
    return w.document.write(export_string);
  };

  cocktail_json = '{"path":"M 419 102 l -152 245 l 0 185 c 0 23.25 101 11.75 106 25","foot":{"x":255,"y":557},"stem":{"x":255,"y":532},"bowl":{"x":255,"y":347},"edge":{"x":255,"y":102},"height_in_mm":150,"spec":{"round_max":"cl","mm_from_top":0},"measure_lines":{},"nr_of_measure_lines":0}';

  erlenmeyer_json = '{"path":"M 307 103 l 0 123 l 100 299 c 10 25 9.5 26 -63 28 l -1 2 l 2 2","foot":{"x":255,"y":557},"stem":{"x":255,"y":555},"bowl":{"x":255,"y":553},"edge":{"x":255,"y":103},"height_in_mm":149,"spec":{"round_max":"cl","mm_from_top":0},"measure_lines":{},"nr_of_measure_lines":0}';

  Glass = require('./widgets/glass/glass');

  WGlass = require('./widgets/glass/wglass');

  WVerticalRuler = require('./widgets/ruler/wvertical_ruler');

  WHorizontalRuler = require('./widgets/ruler/whorizontal_ruler');

  WGlassGrafter = require('./widgets/glass/wgrafter');

  cocktail_glass = new Glass(cocktail_json);

  PIXEL_PER_MM = 455 / 15;

  HEIGHT = (15 + 5) * PIXEL_PER_MM;

  WIDTH = HEIGHT;

  MM_HEIGHT = 20;

  MM_PER_PIXEL = 1 / PIXEL_PER_MM;

  canvas = Raphael('test', WIDTH, HEIGHT);

  edit_canvas = Raphael('edit', WIDTH, HEIGHT);

  grafter = new WGlassGrafter(edit_canvas, 0, 0, WIDTH, HEIGHT, MM_PER_PIXEL({
    fill: 'red'
  }));

  cocktail_representation = new WGlass(canvas, 40, 40, cocktail_glass);

  selected = {
    selected: null
  };

  erlenmeyer_representation.start_selectable(selected);

  cocktail_representation.fill_to_height(111);

  erlenmeyer_representation.fill_to_height(98);

  RULER_WIDTH = 30;

  RULER_LENGTH = HEIGHT - RULER_WIDTH;

  MM_RULER = Math.ceil(RULER_LENGTH / PIXEL_PER_MM);

  vruler = new WVerticalRuler(canvas, 0, 0, RULER_WIDTH, RULER_LENGTH, MM_RULER);

  hruler = new WHorizontalRuler(canvas, RULER_WIDTH, RULER_LENGTH, RULER_LENGTH, RULER_WIDTH, MM_RULER);

}).call(this);

/*
//@ sourceMappingURL=test.map
*/

},{"./widgets/glass/glass":2,"./widgets/glass/wglass":3,"./widgets/ruler/wvertical_ruler":4,"./widgets/ruler/whorizontal_ruler":5,"./widgets/glass/wgrafter":6}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*
glass.coffee version 0.1

Modeling different glasses

(c) 2012 Huub de Beer H.T.de.Beer@gmail.com

Long description
*/


(function() {
  var Glass;

  Glass = (function() {
    Glass.TENTH_OF_MM = 10;

    Glass.prototype.to_json = function() {
      var export_object;

      export_object = {
        path: this.path,
        foot: {
          x: this.foot.x,
          y: this.foot.y
        },
        stem: {
          x: this.stem.x,
          y: this.stem.y
        },
        bowl: {
          x: this.bowl.x,
          y: this.bowl.y
        },
        edge: {
          x: this.edge.x,
          y: this.edge.y
        },
        height_in_mm: this.height_in_mm,
        spec: this.spec
      };
      return JSON.stringify(export_object, null, '  ');
    };

    Glass.prototype.to_full_json = function() {
      var export_object;

      export_object = {
        path: this.path,
        foot: {
          x: this.foot.x,
          y: this.foot.y
        },
        stem: {
          x: this.stem.x,
          y: this.stem.y
        },
        bowl: {
          x: this.bowl.x,
          y: this.bowl.y
        },
        bowl_start: this.bowl_start,
        edge: {
          x: this.edge.x,
          y: this.edge.y
        },
        height_in_mm: this.height_in_mm,
        unit: this.unit,
        spec: this.spec,
        vol: this.vol,
        r: this.r,
        speed: this.speed,
        maximum_height: this.maximum_height,
        maximum_volume: this.maximum_volume,
        maximum_speed: this.maximum_speed
      };
      return JSON.stringify(export_object, null, '  ');
    };

    function Glass(path, foot, stem, bowl, edge, height_in_mm, spec) {
      var import_object, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;

      if (spec == null) {
        spec = {
          round_max: "cl",
          mm_from_top: 5
        };
      }
      /*
      pre:
          path is the right hand side of the countour of the glass
        ∧ 0 ≤ foot.y 
        ∧ foot.y ≤ stem.y 
        ∧ stem.y ≤ bowl.y
        ∧ bowl.y < edge.y
        ∧ 0 < height_in_mm
      
      post:
          is_empty
      */

      if (arguments.length === 1) {
        import_object = JSON.parse(path);
        this.path = import_object.path;
        this.foot = import_object.foot;
        this.stem = import_object.stem;
        this.bowl = import_object.bowl;
        this.edge = import_object.edge;
        this.height_in_mm = import_object.height_in_mm;
        this.spec = (_ref = import_object != null ? import_object.spec : void 0) != null ? _ref : {
          round_max: "cl",
          mm_from_top: 5
        };
        this.unit = (_ref1 = import_object != null ? import_object.unit : void 0) != null ? _ref1 : Math.abs(this.edge.y - this.foot.y) / this.height_in_mm;
        this.bowl_start = (_ref2 = import_object != null ? import_object.bowl_start : void 0) != null ? _ref2 : this.height_in_mm - (Math.abs(this.bowl.y - this.edge.y) / this.unit);
        this.r = (_ref3 = import_object != null ? import_object.r : void 0) != null ? _ref3 : [];
        if (!(import_object != null ? import_object.r : void 0)) {
          this.r = this._compute_r(this.path, this.foot, this.height_in_mm, this.unit);
        }
        this.vol = (_ref4 = import_object != null ? import_object.vol : void 0) != null ? _ref4 : [];
        this.speed = (_ref5 = import_object != null ? import_object.speed : void 0) != null ? _ref5 : [];
        this.maximum_volume = (_ref6 = import_object != null ? import_object.maximum_volume : void 0) != null ? _ref6 : 0;
        this.maximum_height = (_ref7 = import_object != null ? import_object.maximum_height : void 0) != null ? _ref7 : 0;
        this.maximum_speed = (_ref8 = import_object != null ? import_object.maximum_speed : void 0) != null ? _ref8 : 0;
        if (this.maximum_volume === 0 || this.maximum_height === 0 || this.maximum_speed === 0) {
          this._determine_maximum(this.height_in_mm - this.spec.mm_from_top, this.spec.round_max);
        }
      } else {
        this.path = path;
        this.foot = foot;
        this.stem = stem;
        this.bowl = bowl;
        this.edge = edge;
        this.height_in_mm = height_in_mm;
        this.spec = spec;
        this.unit = Math.abs(this.edge.y - this.foot.y) / this.height_in_mm;
        this.bowl_start = this.height_in_mm - (Math.abs(this.bowl.y - this.edge.y) / this.unit);
        this.r = [];
        this.r = this._compute_r(this.path, this.foot, this.height_in_mm, this.unit);
        this.vol = [];
        this.speed = [];
        this.maximum_volume = 0;
        this.maximum_height = 0;
        this.maximum_speed = 0;
        this._determine_maximum(this.height_in_mm - this.spec.mm_from_top, this.spec.round_max);
      }
      this.make_empty();
    }

    Glass.prototype.compute_speed = function() {
      var dh, dvol, h, h_max, v_prev, vol, _results;

      h = 0;
      h_max = this.vol.length - 1;
      while (this.vol[h] === 0) {
        h++;
      }
      this.speed[0] = 0;
      v_prev = 0;
      this.maximum_speed = 0;
      _results = [];
      while (h <= h_max) {
        vol = this.vol[h];
        dh = 0;
        while (h <= h_max && v_prev === vol) {
          h++;
          dh += 0.01;
          vol = this.vol[h];
        }
        dvol = vol - v_prev;
        this.speed[vol] = dh / dvol;
        this.maximum_speed = Math.max(this.maximum_speed, this.speed[vol]);
        v_prev = vol;
        _results.push(h++);
      }
      return _results;
    };

    Glass.prototype.make_empty = function(initial_value) {
      if (initial_value == null) {
        initial_value = 0;
      }
      /*
      Empty this glass 
      
      pre:
          True
      
      post:
          current_height = 0
        ∧ current_volume = 0
      */

      this.current_volume = 0;
      this.current_height = 0;
      this.current_height = this.fill_to_volume(initial_value);
      this.current_height++;
      return this.current_graph = "M0,0";
    };

    Glass.prototype.is_empty = function() {
      /*
      Is this glass empty?
      
      pre:
          True
      
      post:
          True
      
      return:
          current_volume = 0
      */
      return this.current_volume === 0;
    };

    Glass.prototype.is_full = function() {
      /*
      Is this glass full?
      
      pre:
          True
      
      post:
          True
      
      return:
          current_volume = maximum_volume
      */
      return this.current_volume === this.maximum_volume;
    };

    Glass.prototype.fill_to_height = function(height) {
      /*
      Fill this glass up to height and return corresponding volume
      
      pre: 
          height, 0 ≤ height ≤ maximum_height
      
      post:
          current_height = height
        ∧ current_volume = volume_at_height(height)
      
      return:
          volume_at_height(height)
      */
      if (height <= this.maximum_height) {
        this.current_height = height;
      } else {
        this.current_height = this.maximum_height;
      }
      this.current_volume = this.volume_at_height(this.current_height);
      return this.current_volume;
    };

    Glass.prototype.fill_to_volume = function(volume) {
      /*
      Fill this glass up to volume and return the corresponding water level height.
      
      pre:
          volume, 0 ≤ volume ≤ maximum_volume
      
      post:
          current_volume = volume
        ∧ current_height = height_at_volume(volume)
      
      return:
          height_at_volume(volume)
      */
      if (volume <= this.maximum_volume) {
        this.current_volume = volume;
      } else {
        this.current_volume = this.maximum_volume;
      }
      this.current_height = this.height_at_volume(this.current_volume);
      return this.current_height;
    };

    Glass.prototype.speed_at_height = function(height) {
      return this.speed[height * Glass.TENTH_OF_MM];
    };

    Glass.prototype.speed_at_volume = function(vol) {
      var h;

      h = height_at_volume(vol);
      return this.speed[h * Glass.TENTH_OF_MM];
    };

    Glass.prototype.volume_at_height = function(height) {
      /*
      Compute the volume of the water in this glass when it is filled up to
      height. Take in account the shape of the glass: only the bowl of the
      glass can be filled.
      
      pre:
          height: water level height in mm
      
      post:
          volume = (∫h: 0 ≤ h ≤ height: πr(h)^2)
      
      return:
          volume in ml
      */

      var HSTEP, dvol, h;

      HSTEP = 0.01;
      h = Math.ceil(height * Glass.TENTH_OF_MM);
      if (this.vol[h] == null) {
        if (h === 0) {
          this.vol[0] = 0;
          this.speed[0] = 0;
        } else {
          if ((0 <= height && height < this.bowl_start)) {
            this.vol[h] = 0 + this.volume_at_height((h - 1) / Glass.TENTH_OF_MM);
            this.speed[h] = 0;
          } else {
            dvol = Math.PI * Math.pow(this.r[h] / Glass.TENTH_OF_MM, 2) * HSTEP;
            this.vol[h] = dvol + this.volume_at_height((h - 1) / Glass.TENTH_OF_MM);
            this.speed[h] = dvol !== 0 ? HSTEP / dvol : 0;
            this.maximum_speed = Math.max(this.maximum_speed, this.speed[h]);
          }
        }
      }
      return this.vol[h];
    };

    Glass.prototype.height_at_volume = function(volume) {
      /*
      Compute the height of the water level in this glass when there is volume water in it.
      
      pre:
          0 ≤ volume 
      
      post:
          height = (h: 0 ≤ h ≤ total_height: vol[h + 1] > volume ∧ vol[h-1] < volume)
      
      return:
          height in mm
      */

      var height, maxheight;

      height = this.current_height * Glass.TENTH_OF_MM;
      maxheight = this.height_in_mm * Glass.TENTH_OF_MM;
      while (!(this.vol[height] > volume || height >= maxheight)) {
        height++;
      }
      return Math.floor(height / Glass.TENTH_OF_MM);
    };

    Glass.prototype.get_current_graph = function() {
      return this.current_graph = this.graph[Math.ceil(this.current_height * Glass.TENTH_OF_MM)];
    };

    Glass.prototype.create_graph = function(paper, graph, line, x_axis, speed) {
      var EPSILON, add_time, dspeed, dtime, dvol, h, p, path, ptmm, speed_before, speed_step, vollast, x, y;

      if (speed == null) {
        speed = false;
      }
      EPSILON = 0.01;
      switch (x_axis) {
        case 'vol':
          if (speed) {
            ptmm = 1 / 100 / line.y_unit.per_pixel;
            dvol = 0;
            this.graph = [];
            path = "M0,0";
            h = 0;
            while (this.vol[h] === 0) {
              this.graph.push(path);
              h++;
            }
            x = line.min.x;
            y = line.max.y - (this.speed[h] / line.y_unit.per_pixel);
            path = "M" + x + "," + y;
            vollast = 0;
            this.graph.push(path);
            speed_before = this.speed[h];
            while (h < this.vol.length && this.vol[h] < this.maximum_volume) {
              dvol = this.vol[h] - vollast;
              vollast = this.vol[h];
              dspeed = speed_before !== 0 ? this.speed[h] - speed_before : 0;
              speed_before = this.speed[h];
              speed_step = dspeed / line.y_unit.per_pixel * (-1);
              path += "l" + (dvol / line.x_unit.per_pixel) + "," + speed_step;
              this.graph.push(path);
              h++;
            }
            graph.attr({
              path: path
            });
            line.add_point(x, y, graph);
            p = line.find_point_at(x);
            return line.add_freehand_line(p, path);
          } else {
            ptmm = 1 / 100 / line.y_unit.per_pixel;
            dvol = 0;
            this.graph = [];
            path = "M0,0";
            h = 0;
            while (this.vol[h] === 0) {
              this.graph.push(path);
              h++;
            }
            x = line.min.x;
            y = line.max.y - (h / 100 / line.y_unit.per_pixel);
            path = "M" + x + "," + y;
            vollast = 0;
            this.graph.push(path);
            while (h < this.vol.length && this.vol[h] < this.maximum_volume) {
              dvol = this.vol[h] - vollast;
              vollast = this.vol[h];
              path += "l" + (dvol / line.x_unit.per_pixel) + ",-" + ptmm;
              this.graph.push(path);
              h++;
            }
            graph.attr({
              path: path
            });
            line.add_point(x, y, graph);
            p = line.find_point_at(x);
            return line.add_freehand_line(p, path);
          }
          break;
        case 'time':
          ptmm = 1 / 100 / line.y_unit.per_pixel;
          dtime = 0;
          this.graph = [];
          path = "M0,0";
          h = 0;
          while (this.vol[h] === 0) {
            this.graph.push(path);
            h++;
          }
          x = line.min.x;
          y = line.max.y - (h / 100 / line.y_unit.per_pixel);
          path = "M" + x + "," + y;
          vollast = 0;
          add_time = 0;
          this.graph.push(path);
          while (h < this.vol.length && this.vol[h] < this.maximum_volume) {
            dvol = this.vol[h] - vollast;
            vollast = this.vol[h];
            add_time = dvol / speed;
            path += "l" + (add_time / line.x_unit.per_pixel) + ",-" + ptmm;
            this.graph.push(path);
            h++;
          }
          graph.attr({
            path: path
          });
          line.add_point(x, y, graph);
          p = line.find_point_at(x);
          return line.add_freehand_line(p, path);
      }
    };

    Glass.prototype._compute_r = function(path, foot, total_height, unit) {
      /*
      Given a path and the coordinate of the foot on the mid-line of the
      glass, compute the radius of the glass at every height.
      
      pre:
          path: SVG path of contour of the right side of the glass
        ∧ foot: point of the foot or bottom of the glass on the mid line
      
      post:
          (∀ h: 0 ≤ h ≤ total_height: r[h] = radius of glass at height h in mm/10 in mm) 
      
      return:
          r
      */

      var height, length_on_path, point_on_length, r, _i, _ref;

      r = [];
      length_on_path = 0;
      for (height = _i = _ref = total_height * Glass.TENTH_OF_MM; _ref <= 0 ? _i <= 0 : _i >= 0; height = _ref <= 0 ? ++_i : --_i) {
        point_on_length = Raphael.getPointAtLength(path, length_on_path);
        while (Math.abs(foot.y - point_on_length.y) > height * unit / Glass.TENTH_OF_MM) {
          length_on_path++;
          point_on_length = Raphael.getPointAtLength(path, length_on_path);
        }
        r[height] = Math.abs(point_on_length.x - foot.x) / unit;
      }
      return r;
    };

    Glass.prototype._determine_maximum = function(total_height, round_to) {
      var factor, total_volume;

      if (round_to == null) {
        round_to = "cl";
      }
      /*
      Determine the maximum volume and corresponding maximum height of this 
      glass. Round to the first ml, cl, dl, or l below total_height.
      
      pre:
          0 ≤ total_height
        ∧ round_to ∈ {ml, cl, dl, l}
      
      post:
          0 ≤ maximum_height < total_height
        ∧ maximum_volume = volume_at_height(maximum_height)
        ∧ height_at_volume(maximum_volume + 1 round_to) >= total_height
      */

      total_volume = this.volume_at_height(total_height);
      factor = 10;
      switch (round_to) {
        case "ml":
          factor = 1;
          break;
        case "cl":
          factor = 10;
          break;
        case "dl":
          factor = 100;
          break;
        case "l":
          factor = 1000;
      }
      this.maximum_volume = Math.floor(total_volume / factor) * factor;
      this.current_height = 0;
      return this.maximum_height = this.height_at_volume(this.maximum_volume);
    };

    return Glass;

  })();

  module.exports = Glass;

}).call(this);

/*
//@ sourceMappingURL=glass.map
*/

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*
*/


(function() {
  var Glass, MeasureLine, WGlass, WMeasureLine, Widget,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Widget = require('../widget');

  Glass = require('./glass');

  MeasureLine = require('./measure_line');

  WMeasureLine = require('./wmeasure_line');

  WGlass = (function(_super) {
    __extends(WGlass, _super);

    function WGlass(canvas, x, y, glass, spec) {
      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.glass = glass;
      this.spec = spec != null ? spec : {};
      this.hide_longdrink = __bind(this.hide_longdrink, this);
      this.show_longdrink = __bind(this.show_longdrink, this);
      this.start_manual_diff = __bind(this.start_manual_diff, this);
      this.stop_manual_diff = __bind(this.stop_manual_diff, this);
      WGlass.__super__.constructor.call(this, this.canvas, this.x, this.y, this.spec);
      this.points = this._compute_points(this.glass);
      this.lengths = this._compute_lengths_at_heigth();
      this._draw();
      this.place_at(this.x, this.y);
      this.move_handler = null;
      this.graph = null;
    }

    WGlass.prototype.fill_to_height = function(height_in_mm) {
      /*
      Update the fill-part to correspond to a water level equal to the height_in_mm.
      */

      var diameter, height, left, length, right;

      diameter = function(length, glass) {
        return Math.abs(Raphael.getPointAtLength(glass.path, length).x - glass.foot.x) * 2;
      };
      height = this.glass.foot.y - (height_in_mm * this.glass.unit);
      if (height < this.glass.bowl.y) {
        this.points.water_level = {};
        this.points.water_level.length = length = this.lengths[height_in_mm * Glass.TENTH_OF_MM];
        this.points.water_level.right = right = Raphael.getPointAtLength(this.glass.path, length);
        this.points.water_level.left = {
          x: right.x - diameter(length, this.glass),
          y: right.y
        };
        right = Raphael.path2curve(Raphael.getSubpath(this.glass.path, this.points.water_level.length, this.points.bowl.length));
        left = this._mirror_path_vertically(right, this.glass.bowl.x);
        return this.water_level.attr({
          path: right + ("H" + this.points.bowl.left.x) + left
        });
      }
    };

    WGlass.prototype._draw = function() {
      var base, bowl, max_ml_representation, max_x, max_y, maxpoint, _ref, _ref1;

      this.paths = this._create_paths();
      base = this.canvas.path(this.paths.base);
      base.attr({
        fill: '#aaa',
        stroke: 'black',
        'stroke-width': 2
      });
      this.widgets.push(base);
      this.water_level = this.canvas.path("M0,0");
      this.water_level.attr({
        fill: (_ref = (_ref1 = this.spec) != null ? _ref1.fill : void 0) != null ? _ref : '#abf',
        'fill-opacity': 0.4,
        stroke: 'none'
      });
      this.widgets.push(this.water_level);
      bowl = this.canvas.path(this.paths.bowl);
      bowl.attr({
        stroke: 'black',
        'stroke-width': 2
      });
      this.widgets.push(bowl);
      maxpoint = Raphael.getPointAtLength(this.glass.path, this.lengths[this.glass.maximum_height * Glass.TENTH_OF_MM]);
      max_x = maxpoint.x;
      max_y = maxpoint.y;
      this.max_ml = new MeasureLine(this.glass.maximum_volume, this.glass.maximum_height, this.glass, {
        x: max_x,
        y: max_y
      }, 'right', true, false);
      max_ml_representation = new WMeasureLine(this.canvas, max_x, max_y, this.max_ml);
      this.widgets.push(max_ml_representation.widgets);
      this.lf = this.canvas.rect(0, 0, 0, 0);
      this.lf.attr({
        fill: 'orange',
        'fill-opacity': 0.5,
        'stroke': 'none'
      });
      this.lf.hide();
      this.lml = this.canvas.path("M0,0");
      this.lml.attr({
        stroke: 'orange',
        'stroke-opacity': 0.5,
        'stroke-dasharray': '-'
      });
      this.lml.hide();
      this.lbl = this.canvas.path("M0,0");
      this.lbl.attr({
        stroke: 'orange',
        'stroke-opacity': 0.5,
        'stroke-dasharray': '-'
      });
      this.lbl.hide();
      this.longdrink = this.canvas.path("M0,0");
      this.longdrink.attr({
        stroke: 'orange',
        'stroke-width': 3,
        'stroke-opacity': 0.9
      });
      this.longdrink.hide();
      this.lgl = this.canvas.path("M0,0");
      this.lgl.attr({
        stroke: 'orange',
        'stroke-width': 3,
        'stroke-opacity': 0.9
      });
      this.lgl.hide();
      this.gp = this.canvas.circle(0, 0, 2);
      this.gp.attr({
        fill: 'gray'
      });
      this.gp.hide();
      this.ll = this.canvas.text(0, 0, "250 ml");
      this.ll.attr({
        'font-family': 'sans-serif',
        'font-size': '12pt',
        'text-anchor': 'start',
        fill: 'gray'
      });
      this.ll.hide();
      this.llp = this.canvas.circle(0, 0, 2);
      this.llp.attr({
        fill: 'gray'
      });
      this.llp.hide();
      this.lrp = this.canvas.circle(0, 0, 2);
      this.lrp.attr({
        fill: 'gray'
      });
      this.lrp.hide();
      this.glasspane = this.canvas.path("" + this.paths.bowl + " " + this.paths.base);
      this.glasspane.attr({
        fill: 'white',
        'fill-opacity': 0,
        'stroke-width': 5,
        'stroke-opacity': 0,
        'stroke': 'gray'
      });
      return this.widgets.push(this.glasspane);
    };

    WGlass.prototype._create_paths = function() {
      /*
      Create the path of the part of this glass
      */

      var left, paths, right;

      paths = {};
      right = Raphael.path2curve(Raphael.getSubpath(this.glass.path, this.points.bowl.length, this.points.foot.length));
      left = this._mirror_path_vertically(right, this.glass.foot.x);
      paths.base = right + ("H" + this.points.foot.left.x) + left;
      right = Raphael.path2curve(Raphael.getSubpath(this.glass.path, this.points.edge.length, this.points.bowl.length));
      left = this._mirror_path_vertically(right, this.glass.foot.x);
      paths.bowl = right + ("H" + this.points.bowl.left.x) + left;
      return paths;
    };

    WGlass.prototype._compute_geometry = function() {
      var base, bowl;

      base = Raphael.pathBBox(this.paths.base);
      bowl = Raphael.pathBBox(this.paths.bowl);
      this.geometry = {};
      this.geometry.top = bowl.y;
      this.geometry.left = Math.min(base.x, bowl.x);
      this.geometry.bottom = base.y2;
      this.geometry.right = Math.max(base.x2, bowl.b2);
      this.geometry.width = Math.max(base.width, bowl.width);
      this.geometry.height = base.height + bowl.height;
      return this.geometry.center = {
        x: (this.geometry.right - this.geometry.left) / 2 + this.geometry.left,
        y: (this.geometry.bottom - this.geometry.top) / 2 + this.geometry.top
      };
    };

    WGlass.prototype._compute_points = function(glass) {
      /*
      Compute points, lengths, and paths between points for the edge, foot, stem, and bowl
      */

      var diameter, length, line, points, right, _i, _len, _ref;

      diameter = function(length) {
        return Math.abs(Raphael.getPointAtLength(glass.path, length).x - glass.foot.x) * 2;
      };
      points = {};
      length = 0;
      _ref = ['edge', 'bowl', 'stem', 'foot'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        points[line] = {};
        points[line].length = length = this._length_at_y(glass.path, glass[line].y, length);
        points[line].right = right = Raphael.getPointAtLength(glass.path, length);
        points[line].left = {
          x: right.x - diameter(length),
          y: right.y
        };
      }
      return points;
    };

    WGlass.prototype._compute_lengths_at_heigth = function() {
      var height, height_in_pixels, length, lengths, max_length;

      lengths = [];
      length = 0;
      max_length = Raphael.getTotalLength(this.glass.path);
      height = this.glass.height_in_mm * Glass.TENTH_OF_MM;
      while (height > 0) {
        height_in_pixels = this.glass.foot.y - ((height * this.glass.unit) / Glass.TENTH_OF_MM);
        while (length < max_length && Raphael.getPointAtLength(this.glass.path, length).y < height_in_pixels) {
          length++;
        }
        lengths[height] = length;
        height--;
      }
      lengths[0] = this.points.foot.length;
      return lengths;
    };

    WGlass.prototype._length_at_y = function(path, y, start) {
      var length, max_length;

      if (start == null) {
        start = 0;
      }
      /*
        Find the length on the path the path hat intersects the horizontal line at y
      */

      length = start;
      max_length = Raphael.getTotalLength(path);
      while (length < max_length && Raphael.getPointAtLength(path, length).y < y) {
        length++;
      }
      return length;
    };

    WGlass.prototype._mirror_path_vertically = function(path, x_line) {
      /*
      */

      var cp1x, cp1y, cp2x, cp2y, cpath, cpathsegs, mirror, mirror_x, mirrorlist, segment, x, y, _i, _len, _ref, _ref1, _ref2, _ref3;

      mirror_x = function(x) {
        return x_line - Math.abs(x_line - x);
      };
      cpath = Raphael.path2curve(path);
      cpathsegs = Raphael.parsePathString(cpath);
      mirror = "";
      mirrorlist = [];
      _ref = cpathsegs[0].slice(1, 3), x = _ref[0], y = _ref[1];
      _ref1 = cpathsegs.slice(1, +cpathsegs.length + 1 || 9e9);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        segment = _ref1[_i];
        _ref2 = segment.slice(1, 5), cp1x = _ref2[0], cp1y = _ref2[1], cp2x = _ref2[2], cp2y = _ref2[3];
        mirrorlist.push([mirror_x(cp2x), cp2y, mirror_x(cp1x), cp1y, mirror_x(x), y]);
        _ref3 = segment.slice(5, 7), x = _ref3[0], y = _ref3[1];
      }
      mirror = ((function() {
        var _j, _len1, _ref4, _results;

        _ref4 = mirrorlist.reverse();
        _results = [];
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          segment = _ref4[_j];
          _results.push('C' + segment.join(","));
        }
        return _results;
      })()).join("");
      return mirror;
    };

    WGlass.prototype.set_graph = function(graph) {
      return this.graph = graph;
    };

    WGlass.prototype.del_graph = function() {
      return this.graph = null;
    };

    WGlass.prototype.move_longdrink = function(glassrep) {
      var _this = this;

      return function(e, x, y) {
        var BELOW, OVER_GRAPH_LENGTH, compute_vol, gheight, gpx, gpy, gvol, h, halfvol, halfvolpx, hi, left, length, lglpath, line, p, path, ph, py, r, right, rmm, vol;

        p = glassrep.fit_point(x, y);
        py = p.y - _this.dy;
        ph = glassrep.points.foot.right.y - py;
        h = Math.ceil((ph / glassrep.glass.unit) * Glass.TENTH_OF_MM);
        length = glassrep.lengths[h];
        right = Raphael.getPointAtLength(glassrep.glass.path, length);
        left = right.x - 2 * (right.x - glassrep.glass.edge.x);
        r = (right.x - left) / 2;
        rmm = r / glassrep.glass.unit;
        hi = Math.floor(20 * glassrep.glass.unit);
        compute_vol = function(rmm, h) {
          var hmm;

          hmm = h / glassrep.glass.unit;
          return Math.floor(Math.PI * Math.pow(rmm, 2) * hmm / 1000);
        };
        while ((compute_vol(rmm, hi) % 2) !== 0 && (compute_vol(rmm, hi) % 10) !== 5) {
          hi++;
        }
        vol = compute_vol(rmm, hi);
        BELOW = 10 * glassrep.glass.unit;
        if (_this.spec.diff_graph && _this.graph) {
          OVER_GRAPH_LENGTH = 1000;
          gheight = Math.ceil(ph / glassrep.glass.unit);
          gvol = _this.glass.volume_at_height(gheight);
          line = _this.graph.computer_line;
          gpx = line.min.x + gvol / line.x_unit.per_pixel;
          gpy = line.max.y - (gheight / 10) / line.y_unit.per_pixel;
          halfvol = vol / 2;
          halfvolpx = halfvol / line.x_unit.per_pixel;
          lglpath = "M" + gpx + "," + gpy + "l" + halfvolpx + "," + (-hi + BELOW) + "M" + gpx + "," + gpy + "l-" + halfvolpx + "," + BELOW;
          _this.lgl.attr({
            path: lglpath
          });
          _this.lgl.show().toFront();
          _this.gp.attr({
            cx: gpx,
            cy: gpy
          });
          _this.gp.show().toFront();
        } else {
          _this.lgl.hide();
          _this.gp.hide();
          OVER_GRAPH_LENGTH = 0;
        }
        _this.lf.attr({
          x: left + _this.dx,
          y: right.y + _this.dy,
          width: right.x - left,
          height: BELOW
        });
        path = "M" + right.x + "," + (right.y - hi + BELOW) + "H" + (-_this.dx + 10);
        path += "M" + right.x + "," + (right.y - hi + BELOW) + "h" + OVER_GRAPH_LENGTH;
        _this.lml.attr({
          path: path,
          transform: "t" + _this.dx + "," + _this.dy
        });
        _this.lml.toFront();
        path = "M" + right.x + "," + (right.y + BELOW) + "H" + (-_this.dx + 10);
        path += "M" + right.x + "," + (right.y + BELOW) + "h" + OVER_GRAPH_LENGTH;
        _this.lbl.attr({
          path: path,
          transform: "t" + _this.dx + "," + _this.dy
        });
        _this.lbl.toFront();
        path = "M" + right.x + "," + (right.y + BELOW) + "v-" + (hi + 10) + "M" + right.x + "," + (right.y + BELOW) + "L" + left + "," + (right.y + BELOW) + "v-" + (hi + 10);
        _this.longdrink.attr({
          path: path,
          transform: "t" + _this.dx + "," + _this.dy
        });
        _this.llp.attr({
          cx: left + _this.dx,
          cy: right.y + _this.dy
        });
        _this.lrp.attr({
          cx: right.x + _this.dx,
          cy: right.y + _this.dy
        });
        return _this.ll.attr({
          text: "" + vol + " ml",
          transform: "t" + (left + _this.dx + 10) + "," + (right.y - hi + _this.dy - 10 + BELOW)
        });
      };
    };

    WGlass.prototype.stop_manual_diff = function() {
      this.longdrink.hide();
      this.lgl.hide();
      this.gp.hide();
      this.glasspane.unmousemove(this.move_handler);
      this.glasspane.unmouseover(this.show_longdrink);
      return this.glasspane.unmouseout(this.hide_longdrink);
    };

    WGlass.prototype.start_manual_diff = function() {
      this.glasspane.mouseover(this.show_longdrink);
      return this.glasspane.mouseout(this.hide_longdrink);
    };

    WGlass.prototype.show_longdrink = function() {
      var _ref;

      this.longdrink.show();
      this.lml.show();
      this.lbl.show();
      this.ll.show();
      this.llp.show();
      this.lrp.show();
      this.move_handler = (_ref = this.move_handler) != null ? _ref : this.move_longdrink(this);
      return this.glasspane.mousemove(this.move_handler);
    };

    WGlass.prototype.hide_longdrink = function() {
      this.longdrink.hide();
      this.lml.hide();
      this.lbl.hide();
      this.ll.hide();
      this.llp.hide();
      this.lrp.hide();
      this.lgl.hide();
      return this.gp.hide();
    };

    return WGlass;

  })(Widget);

  module.exports = WGlass;

}).call(this);

/*
//@ sourceMappingURL=wglass.map
*/

},{"../widget":7,"./glass":2,"./measure_line":8,"./wmeasure_line":9}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*
(c) 2012, Huub de Beer (H.T.de.Beer@gmail.com)
*/


(function() {
  var WRuler, WVerticalRuler, Widget,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  WRuler = require('./wruler');

  Widget = require('../widget');

  WVerticalRuler = (function(_super) {
    __extends(WVerticalRuler, _super);

    function WVerticalRuler(canvas, x, y, width, height, height_in_mm, spec) {
      var _this = this;

      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.height_in_mm = height_in_mm;
      this.spec = spec != null ? spec : {};
      this.spec = {
        orientation: "vertical",
        rounded_corners: 0
      };
      WVerticalRuler.__super__.constructor.call(this, this.canvas, this.x, this.y, this.spec);
      this._draw();
      this._compute_geometry();
      this.widgets.mouseover(function(e) {
        return _this.measure_line.show();
      });
      this.widgets.mouseout(function(e) {
        return _this.measure_line.hide();
      });
      this.widgets.mousemove(function(e, x, y) {
        var p;

        p = _this.fit_point(x, y);
        return _this._move_measure_line(p.y);
      });
      this.widgets.click(function(e, x, y) {
        var p;

        p = _this.fit_point(x, y);
        return _this._place_pointer(p.y);
      });
    }

    WVerticalRuler.prototype.fit_point = function(x, y) {
      var point;

      point = {
        x: x - this.canvas.canvas.parentNode.offsetLeft,
        y: y - this.canvas.canvas.parentNode.offsetTop
      };
      return point;
    };

    WVerticalRuler.prototype._place_pointer = function(y) {
      var T_HEIGHT, T_WIDTH, active, pointer, remove, triangle, unactive, _ref;

      T_WIDTH = 10;
      T_HEIGHT = 4;
      triangle = "l" + T_WIDTH + "," + T_HEIGHT + "v-" + (2 * T_HEIGHT) + "l-" + T_WIDTH + "," + T_HEIGHT + "m" + T_WIDTH + ",0";
      pointer = this.canvas.path(("M" + (this.x + this.width) + "," + y) + triangle + ("h" + (((_ref = this.spec['measure_line_width']) != null ? _ref : 500) - this.width - T_WIDTH - 2)));
      pointer.attr({
        fill: '#222',
        stroke: '#222',
        'stroke-opacity': 0.75,
        'stroke-width': 1,
        'fill-opacity': 1,
        'stroke-dasharray': '.'
      });
      active = function(elt) {
        return elt.attr({
          fill: "red",
          stroke: "red",
          'stroke-opacity': 0.5,
          'fill-opacity': 0.5
        });
      };
      unactive = function(elt) {
        return elt.attr({
          fill: "#222",
          stroke: '#222',
          'stroke-opacity': 0.5,
          'stroke-width': 0.5,
          'fill-opacity': 1
        });
      };
      remove = function(elt) {
        elt.unmouseover(active);
        elt.unmouseout(unactive);
        return elt.remove();
      };
      pointer.mouseover(function() {
        return active(this);
      });
      pointer.mouseout(function() {
        return unactive(this);
      });
      pointer.click(function() {
        return remove(this);
      });
      pointer.touchstart(function() {
        return active(this);
      });
      pointer.touchcancel(function() {
        return unactive(this);
      });
      pointer.touchend(function() {
        return remove(this);
      });
      return this.pointers.push(pointer);
    };

    WVerticalRuler.prototype._move_measure_line = function(y) {
      var MEASURELINE_LENGTH, _ref;

      MEASURELINE_LENGTH = (_ref = this.spec['measure_line_width']) != null ? _ref : 500;
      return this.measure_line.attr({
        path: "M" + (this.x - this.dx) + "," + y + "h" + MEASURELINE_LENGTH,
        stroke: 'red',
        'stroke-opacity': 0.5,
        'stroke-width': 1
      });
    };

    WVerticalRuler.prototype._draw = function() {
      /*
      Draw a vertical ruler
      */

      var background, cmlabel, label, labels, ticks, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;

      this.unit = this.height / this.height_in_mm;
      background = this.canvas.rect(this.x, this.y, this.width, this.height, (_ref = this.spec.rounded_corners) != null ? _ref : 5);
      background.attr({
        fill: (_ref1 = this.spec.background) != null ? _ref1 : "white",
        stroke: (_ref2 = this.spec.stroke) != null ? _ref2 : "black",
        'stroke-width': (_ref3 = this.spec['stroke-width']) != null ? _ref3 : 2
      });
      this.widgets.push(background);
      ticks = this.canvas.path(this._ticks_path());
      ticks.attr({
        stroke: (_ref4 = this.spec.stroke) != null ? _ref4 : "black"
      });
      this.widgets.push(ticks);
      labels = this._ticks_labels();
      for (_i = 0, _len = labels.length; _i < _len; _i++) {
        label = labels[_i];
        label.attr({
          'font-family': (_ref5 = this.spec['font-family']) != null ? _ref5 : 'sans-serif',
          'font-size': (_ref6 = this.spec['font-size']) != null ? _ref6 : 10,
          'font-weight': 'bold'
        });
        this.widgets.push(label);
      }
      cmlabel = this.canvas.text(this.x + 11, this.y + 11, "cm");
      cmlabel.attr({
        'font-family': (_ref7 = this.spec['font-family']) != null ? _ref7 : 'sans-serif',
        'font-size': ((_ref8 = this.spec['font-size']) != null ? _ref8 : 10) + 2,
        'font-weight': 'bold'
      });
      this.widgets.push(cmlabel);
      this.pointers = this.canvas.set();
      this.widgets.push(this.pointers);
      this.measure_line = this.canvas.path("M" + this.x + "," + this.y);
      this.measure_line.hide();
      return this.widgets.push(this.measure_line);
    };

    WVerticalRuler.prototype._ticks_path = function() {
      /*
      Generate the ticks by moving from tick to tick and drawing a horizontal line
      for every tick.
      */

      var CM_WIDTH, HCM_WIDTH, MM_WIDTH, d, mm, x, y, _i, _ref, _ref1, _ref2, _ref3, _ref4;

      MM_WIDTH = (_ref = this.spec.mm_width) != null ? _ref : 3;
      HCM_WIDTH = (_ref1 = this.spec.hcm_width) != null ? _ref1 : 7;
      CM_WIDTH = (_ref2 = this.spec.cm_width) != null ? _ref2 : 11;
      x = this.x + this.width;
      y = this.y + this.height - ((_ref3 = this.spec.border_width) != null ? _ref3 : 2);
      d = "";
      for (mm = _i = 2, _ref4 = this.height_in_mm - 1; 2 <= _ref4 ? _i < _ref4 : _i > _ref4; mm = 2 <= _ref4 ? ++_i : --_i) {
        y -= this.unit;
        d += "M" + x + "," + y;
        if (mm % 10 === 0) {
          d += "h-" + CM_WIDTH;
        } else if (mm % 5 === 0) {
          d += "h-" + HCM_WIDTH;
        } else {
          d += "h-" + MM_WIDTH;
        }
      }
      return d;
    };

    WVerticalRuler.prototype._ticks_labels = function() {
      /*
      Draw the labels of the cm ticks
      */

      var X_DISTANCE, Y_DISTANCE, cm, labels, mm, x, y, _i, _ref, _ref1, _ref2, _ref3;

      X_DISTANCE = (_ref = this.spec.x_distance) != null ? _ref : 18;
      Y_DISTANCE = (_ref1 = this.spec.y_distance) != null ? _ref1 : 3;
      x = this.x + this.width - X_DISTANCE;
      y = this.y + this.height - ((_ref2 = this.spec.border_width) != null ? _ref2 : 2);
      cm = 0;
      labels = [];
      for (mm = _i = 2, _ref3 = this.height_in_mm - 1; 2 <= _ref3 ? _i < _ref3 : _i > _ref3; mm = 2 <= _ref3 ? ++_i : --_i) {
        y -= this.unit;
        if (mm % 10 === 0) {
          cm++;
          labels.push(this.canvas.text(x, y + Y_DISTANCE, "" + cm));
        }
      }
      return labels;
    };

    return WVerticalRuler;

  })(Widget);

  module.exports = WVerticalRuler;

}).call(this);

/*
//@ sourceMappingURL=wvertical_ruler.map
*/

},{"./wruler":10,"../widget":7}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*
(c) 2012, Huub de Beer (H.T.de.Beer@gmail.com)
*/


(function() {
  var WHorizontalRuler, Widget,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Widget = require('../widget');

  WHorizontalRuler = (function(_super) {
    __extends(WHorizontalRuler, _super);

    function WHorizontalRuler(canvas, x, y, width, height, height_in_mm, spec) {
      var _this = this;

      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.height_in_mm = height_in_mm;
      this.spec = spec != null ? spec : {};
      this.spec = {
        orientation: "horizontal",
        rounded_corners: 0
      };
      WHorizontalRuler.__super__.constructor.call(this, this.canvas, this.x, this.y, this.spec);
      this._draw();
      this._compute_geometry();
      this.widgets.mouseover(function(e) {
        return _this.measure_line.show();
      });
      this.widgets.mouseout(function(e) {
        return _this.measure_line.hide();
      });
      this.widgets.mousemove(function(e, x, y) {
        var p;

        p = _this.fit_point(x, y);
        return _this._move_measure_line(p.x);
      });
      this.widgets.click(function(e, x, y) {
        var p;

        p = _this.fit_point(x, y);
        return _this._place_pointer(p.x);
      });
    }

    WHorizontalRuler.prototype._place_pointer = function(x) {
      var T_HEIGHT, T_WIDTH, active, pointer, remove, triangle, unactive, _ref;

      T_WIDTH = 4;
      T_HEIGHT = 10;
      triangle = "l" + T_WIDTH + ",-" + T_HEIGHT + "h-" + (2 * T_WIDTH) + "l" + T_WIDTH + "," + T_HEIGHT + "m0,0";
      pointer = this.canvas.path(("M" + x + "," + this.y) + triangle + ("v-" + (((_ref = this.spec['measure_line_width']) != null ? _ref : 500) - this.height - T_WIDTH - 2)));
      pointer.attr({
        fill: '#222',
        stroke: '#222',
        'stroke-opacity': 0.75,
        'stroke-width': 1,
        'fill-opacity': 1,
        'stroke-dasharray': '.'
      });
      active = function(elt) {
        return elt.attr({
          fill: "red",
          stroke: "red",
          'stroke-opacity': 0.5,
          'fill-opacity': 0.5
        });
      };
      unactive = function(elt) {
        return elt.attr({
          fill: "#222",
          stroke: '#222',
          'stroke-opacity': 0.5,
          'stroke-width': 0.5,
          'fill-opacity': 1
        });
      };
      remove = function(elt) {
        elt.unmouseover(active);
        elt.unmouseout(unactive);
        return elt.remove();
      };
      pointer.mouseover(function() {
        return active(this);
      });
      pointer.mouseout(function() {
        return unactive(this);
      });
      pointer.click(function() {
        return remove(this);
      });
      pointer.touchstart(function() {
        return active(this);
      });
      pointer.touchcancel(function() {
        return unactive(this);
      });
      pointer.touchend(function() {
        return remove(this);
      });
      return this.pointers.push(pointer);
    };

    WHorizontalRuler.prototype._move_measure_line = function(x) {
      var MEASURELINE_LENGTH, _ref;

      MEASURELINE_LENGTH = (_ref = this.spec['measure_line_width']) != null ? _ref : 500;
      return this.measure_line.attr({
        path: "M" + x + "," + (this.y - this.dy + this.height) + "v-" + (MEASURELINE_LENGTH + this.height),
        stroke: 'red',
        'stroke-opacity': 0.5,
        'stroke-width': 1
      });
    };

    WHorizontalRuler.prototype._draw = function() {
      /*
      Draw a vertical ruler
      */

      var background, cmlabel, label, labels, ticks, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;

      this.unit = this.width / this.height_in_mm;
      background = this.canvas.rect(this.x, this.y, this.width, this.height, (_ref = this.spec.rounded_corners) != null ? _ref : 5);
      background.attr({
        fill: (_ref1 = this.spec.background) != null ? _ref1 : "white",
        stroke: (_ref2 = this.spec.stroke) != null ? _ref2 : "black",
        'stroke-width': (_ref3 = this.spec['stroke-width']) != null ? _ref3 : 2
      });
      this.widgets.push(background);
      ticks = this.canvas.path(this._ticks_path());
      ticks.attr({
        stroke: (_ref4 = this.spec.stroke) != null ? _ref4 : "black"
      });
      this.widgets.push(ticks);
      labels = this._ticks_labels();
      for (_i = 0, _len = labels.length; _i < _len; _i++) {
        label = labels[_i];
        label.attr({
          'font-family': (_ref5 = this.spec['font-family']) != null ? _ref5 : 'sans-serif',
          'font-size': (_ref6 = this.spec['font-size']) != null ? _ref6 : 10,
          'font-weight': 'bold'
        });
        this.widgets.push(label);
      }
      cmlabel = this.canvas.text(this.x + this.width - 11, this.y + this.height - 11, "cm");
      cmlabel.attr({
        'font-family': (_ref7 = this.spec['font-family']) != null ? _ref7 : 'sans-serif',
        'font-size': ((_ref8 = this.spec['font-size']) != null ? _ref8 : 10) + 2,
        'font-weight': 'bold'
      });
      this.widgets.push(cmlabel);
      this.pointers = this.canvas.set();
      this.widgets.push(this.pointers);
      this.measure_line = this.canvas.path("M" + this.x + "," + this.y);
      this.measure_line.hide();
      return this.widgets.push(this.measure_line);
    };

    WHorizontalRuler.prototype._ticks_path = function() {
      /*
      Generate the ticks by moving from tick to tick and drawing a horizontal line
      for every tick.
      */

      var CM_WIDTH, HCM_WIDTH, MM_WIDTH, d, mm, x, y, _i, _ref, _ref1, _ref2, _ref3, _ref4;

      MM_WIDTH = (_ref = this.spec.mm_width) != null ? _ref : 3;
      HCM_WIDTH = (_ref1 = this.spec.hcm_width) != null ? _ref1 : 7;
      CM_WIDTH = (_ref2 = this.spec.cm_width) != null ? _ref2 : 11;
      x = this.x + ((_ref3 = this.spec.border_width) != null ? _ref3 : 2);
      y = this.y;
      d = "";
      for (mm = _i = 2, _ref4 = this.height_in_mm - 1; 2 <= _ref4 ? _i < _ref4 : _i > _ref4; mm = 2 <= _ref4 ? ++_i : --_i) {
        x += this.unit;
        d += "M" + x + "," + y;
        if (mm % 10 === 0) {
          d += "v" + CM_WIDTH;
        } else if (mm % 5 === 0) {
          d += "v" + HCM_WIDTH;
        } else {
          d += "v" + MM_WIDTH;
        }
      }
      return d;
    };

    WHorizontalRuler.prototype._ticks_labels = function() {
      /*
      Draw the labels of the cm ticks
      */

      var X_DISTANCE, Y_DISTANCE, cm, labels, mm, x, y, _i, _ref, _ref1, _ref2, _ref3;

      X_DISTANCE = (_ref = this.spec.x_distance) != null ? _ref : 3;
      Y_DISTANCE = (_ref1 = this.spec.y_distance) != null ? _ref1 : 10;
      x = this.x + ((_ref2 = this.spec.border_width) != null ? _ref2 : 2);
      y = this.y + Y_DISTANCE;
      cm = 0;
      labels = [];
      for (mm = _i = 2, _ref3 = this.height_in_mm - 1; 2 <= _ref3 ? _i < _ref3 : _i > _ref3; mm = 2 <= _ref3 ? ++_i : --_i) {
        x += this.unit;
        if (mm % 10 === 0) {
          cm++;
          labels.push(this.canvas.text(x, y + Y_DISTANCE, "" + cm));
        }
      }
      return labels;
    };

    return WHorizontalRuler;

  })(Widget);

  module.exports = WHorizontalRuler;

}).call(this);

/*
//@ sourceMappingURL=whorizontal_ruler.map
*/

},{"../widget":7}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var ActionButton, Button, ButtonGroup, ContourLine, SwitchButton, WGlassGrafter, Widget,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Widget = require('../widget');

  ContourLine = require('./contour_line');

  Button = require('../buttons/button');

  ActionButton = require('../buttons/action_button');

  SwitchButton = require('../buttons/switch_button');

  ButtonGroup = require('../buttons/button_group');

  WGlassGrafter = (function(_super) {
    __extends(_Class, _super);

    _Class.prototype.initialize_properties = function(properties) {
      var p, _ref;

      p = {};
      p.buttons = (_ref = properties != null ? properties.buttons : void 0) != null ? _ref : ['normal', 'add_point', 'remove_point', 'straight', 'curve'];
      return p;
    };

    function _Class(paper, x, y, width, height, mm_per_pixel, properties) {
      var _this = this;

      this.paper = paper;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.control_point_start = __bind(this.control_point_start, this);
      this.remove_point = __bind(this.remove_point, this);
      this.move_point_start = __bind(this.move_point_start, this);
      this.add_point = __bind(this.add_point, this);
      this.mousemove = __bind(this.mousemove, this);
      this.mouseout = __bind(this.mouseout, this);
      this.mouseover = __bind(this.mouseover, this);
      this.prop = this.initialize_properties(properties);
      this.PADDING = 3;
      this.POINT_WIDTH = 3;
      this.BUTTON_WIDTH = 32;
      Button.set_width(this.BUTTON_WIDTH);
      Button.set_base_path("lib/icons");
      this.AXIS_WIDTH = 40;
      this.BUTTON_SEP = 5;
      this.GROUP_SEP = 15;
      this.CANVAS_SEP = 10;
      this.CANVAS_TOP = this.y + this.PADDING + this.BUTTON_WIDTH + this.CANVAS_SEP;
      this.CANVAS_LEFT = this.x + this.PADDING;
      this.CANVAS_HEIGHT = this.height - this.PADDING * 2 - this.BUTTON_WIDTH - this.CANVAS_SEP - this.AXIS_WIDTH;
      this.CANVAS_WIDTH = this.width - this.PADDING * 2 - this.AXIS_WIDTH;
      this.CANVAS_BOTTOM = this.CANVAS_TOP + this.CANVAS_HEIGHT;
      this.CANVAS_RIGHT = this.CANVAS_LEFT + this.CANVAS_WIDTH;
      this.CANVAS_MID = this.CANVAS_LEFT + this.CANVAS_WIDTH / 2;
      this.BORDER_WIDTH = this.CANVAS_WIDTH / 2;
      if (mm_per_pixel !== 0) {
        this.PIXELS_PER_MM = 1 / mm_per_pixel;
      }
      this.contour = new ContourLine(this.CANVAS_MID, this.CANVAS_TOP, this.BORDER_WIDTH, this.CANVAS_HEIGHT, mm_per_pixel);
      this.actions = {
        normal: {
          button: {
            type: 'group',
            option_group: 'mode',
            group: 'select',
            icon: 'edit-select',
            tooltip: 'Normaal',
            on_select: function() {
              return _this.change_mode('normal');
            },
            enabled: true,
            "default": true
          },
          cursor: 'default'
        },
        add_point: {
          button: {
            type: 'group',
            option_group: 'mode',
            group: 'edit-point',
            icon: 'format-add-node',
            tooltip: 'zet een punt',
            on_select: function() {
              return _this.change_mode('add_point');
            },
            enabled: true
          },
          cursor: 'crosshair'
        },
        remove_point: {
          button: {
            type: 'group',
            option_group: 'mode',
            group: 'edit-point',
            icon: 'format-remove-node',
            tooltip: 'verwijder een punt',
            on_select: function() {
              return _this.change_mode('remove_point');
            },
            enabled: true
          },
          cursor: 'default'
        },
        straight: {
          button: {
            type: 'group',
            option_group: 'mode',
            group: 'edit-line',
            icon: 'straight-line',
            tooltip: 'Maak er een rechte lijn van',
            on_select: function() {
              return _this.change_mode('straight');
            }
          },
          cursor: 'default'
        },
        curve: {
          button: {
            type: 'group',
            option_group: 'mode',
            group: 'edit-line',
            icon: 'draw-bezier-curves',
            tooltip: 'Maak er een kromme lijn van',
            on_select: function() {
              return _this.change_mode('curve');
            }
          },
          cursor: 'default'
        },
        realistic: {
          button: {
            type: 'action',
            icon: 'games-hint',
            group: 'view',
            tooltip: 'Bekijk het glas 3-dimensionaal',
            action: function() {}
          }
        },
        export_png: {
          button: {
            type: 'action',
            icon: 'image-x-generic',
            group: 'export',
            tooltip: 'Download als een PNG afbeelding',
            action: function() {}
          }
        },
        export_svg: {
          button: {
            type: 'action',
            icon: 'image-svg+xml',
            group: 'export',
            tooltip: 'Download als een SVG afbeelding',
            action: function() {}
          }
        }
      };
      this.draw();
      this.mode = 'normal';
      this.click = '';
      this.points_draggable = false;
      this.cp_points_draggable = false;
      this.make_draggable();
      this.canvas.mouseover(this.mouseover);
      this.canvas.mouseout(this.mouseout);
    }

    _Class.prototype.mouseover = function(e, x, y) {
      return this.canvas.mousemove(this.mousemove);
    };

    _Class.prototype.mouseout = function(e, x, y) {
      return this.canvas.unmousemove(this.mousemove);
    };

    _Class.prototype.fit_point = function(x, y) {
      var point;

      point = {
        x: Math.floor(x - this.paper.canvas.parentNode.offsetLeft),
        y: Math.floor(y - this.paper.canvas.parentNode.offsetTop)
      };
      return point;
    };

    _Class.prototype.reset_mouse = function() {
      this.click = '';
      this.canvas.unclick(this.add_point);
      this.canvas.unclick(this.remove_point);
      this.canvas.unclick(this.change_line(''));
      this.potential_point.hide();
      this.potential_above.hide();
      this.potential_below.hide();
      this.remove_point_point.hide();
      this.remove_point_line.hide();
      return this.change_line_area.hide();
    };

    _Class.prototype.mousemove = function(e, x, y) {
      var above, below, p, point, q;

      p = this.fit_point(x, y);
      this.canvas.attr({
        cursor: this.actions[this.mode].cursor
      });
      switch (this.mode) {
        case 'normal':
          return 1 === 1;
        case 'add_point':
          if (this.contour.can_add_point(p.x, p.y)) {
            above = this.contour.get_point_above_height(p.y);
            below = above + 1;
            above = this.contour.get_point(above);
            below = this.contour.get_point(below);
            if (this.click !== this.mode) {
              this.canvas.click(this.add_point);
              this.click = this.mode;
            }
            this.potential_above.attr({
              path: "M" + above.x + "," + above.y + "L" + p.x + "," + (p.y - 2)
            });
            this.potential_above.show();
            this.potential_below.attr({
              path: "M" + below.x + "," + below.y + "L" + p.x + "," + (p.y + 2)
            });
            return this.potential_below.show();
          } else {
            this.potential_point.hide();
            this.potential_above.hide();
            this.potential_below.hide();
            return this.canvas.attr({
              cursor: 'not-allowed'
            });
          }
          break;
        case 'remove_point':
          q = this.contour.find_point_near(p.x, p.y, this.POINT_WIDTH * 5);
          if (q !== -1 && this.contour.can_remove_point(q)) {
            if (this.click !== this.mode) {
              this.canvas.click(this.remove_point);
              this.click = this.mode;
            }
            point = this.contour.get_point(q);
            above = q - 1;
            below = q + 1;
            above = this.contour.get_point(above);
            below = this.contour.get_point(below);
            this.remove_point_point.attr({
              cx: point.x,
              cy: point.y
            });
            this.remove_point_point.show();
            this.remove_point_line.attr({
              path: "M" + above.x + "," + above.y + "L" + below.x + "," + below.y
            });
            return this.remove_point_line.show();
          } else {
            this.reset_mouse();
            return this.canvas.attr({
              cursor: 'not-allowed'
            });
          }
          break;
        case 'straight':
          q = this.contour.get_point_above_height(p.y);
          if (q !== -1) {
            point = this.contour.get_point(q);
            below = this.contour.get_point(q + 1);
            if (point.segment.type !== 'straight') {
              if (this.click !== this.mode) {
                this.canvas.click(this.change_line(this, 'straight'));
                this.click = this.mode;
              }
              this.change_line_area.attr({
                y: point.y,
                height: below.y - point.y
              });
              return this.change_line_area.show();
            } else {
              this.change_line_area.hide();
              return this.canvas.attr({
                cursor: 'not-allowed'
              });
            }
          } else {
            this.change_line_area.hide();
            return this.canvas.attr({
              cursor: 'not-allowed'
            });
          }
          break;
        case 'curve':
          q = this.contour.get_point_above_height(p.y);
          if (q !== -1) {
            point = this.contour.get_point(q);
            below = this.contour.get_point(q + 1);
            if (point.segment.type !== 'curve') {
              if (this.click !== this.mode) {
                this.canvas.click(this.change_line(this, 'curve'));
                this.click = this.mode;
              }
              this.change_line_area.attr({
                y: point.y,
                height: below.y - point.y
              });
              return this.change_line_area.show();
            } else {
              this.change_line_area.hide();
              return this.canvas.attr({
                cursor: 'not-allowed'
              });
            }
          } else {
            this.change_line_area.hide();
            return this.canvas.attr({
              cursor: 'not-allowed'
            });
          }
      }
    };

    _Class.prototype.add_point = function(e, x, y) {
      var p, point, q;

      p = this.fit_point(x, y);
      point = this.paper.circle(p.x, p.y, this.POINT_WIDTH);
      point.attr({
        fill: 'black'
      });
      q = this.contour.add_point(p.x, p.y, point);
      point.drag(this.move_point(this, q), this.move_point_start, this.move_point_end(this, q));
      return this.draw_glass();
    };

    _Class.prototype.make_draggable = function() {
      var point, _i, _len, _ref, _ref1;

      this.points_draggable = (_ref = this.points_draggable) != null ? _ref : false;
      if (!this.points_draggable) {
        _ref1 = this.contour.points;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          point = _ref1[_i];
          point.representation.drag(this.move_point(this, point), this.move_point_start, this.move_point_end(this, point));
          if (point.border === 'none') {
            point.representation.attr({
              fill: 'blue',
              stroke: 'blue',
              r: this.POINT_WIDTH * 2,
              'fill-opacity': 0.3
            });
          }
        }
        return this.points_draggable = true;
      }
    };

    _Class.prototype.move_point = function(grafter, point) {
      var _this = this;

      return function(dx, dy, x, y, e) {
        var newp, p, tx, ty;

        tx = Math.floor(dx - grafter.dpo.x);
        ty = Math.floor(dy - grafter.dpo.y);
        p = grafter.contour.find_point_at(point.y);
        if (point.border === 'foot') {
          newp = {
            x: point.x + tx,
            y: point.y
          };
        } else {
          newp = {
            x: point.x + tx,
            y: point.y + ty
          };
        }
        if (p !== -1 && grafter.contour.can_move_point(p, newp.x, newp.y)) {
          grafter.contour.move_point(p, newp.x, newp.y);
          grafter.dpo = {
            x: dx,
            y: dy
          };
          point.representation.attr({
            cx: point.x,
            cy: point.y
          });
          switch (point.border) {
            case 'edge':
              _this.edge.attr({
                path: "M" + _this.CANVAS_MID + "," + point.y + "h" + (_this.CANVAS_WIDTH / 2)
              });
              break;
            case 'bowl':
              _this.bowl.attr({
                path: "M" + _this.CANVAS_MID + "," + point.y + "h" + (_this.CANVAS_WIDTH / 2)
              });
              break;
            case 'stem':
              _this.stem.attr({
                path: "M" + _this.CANVAS_MID + "," + point.y + "h" + (_this.CANVAS_WIDTH / 2)
              });
          }
          return _this.draw_glass();
        } else {

        }
      };
    };

    _Class.prototype.move_point_start = function(x, y, e) {
      var _ref;

      this.dpo = (_ref = this.dpo) != null ? _ref : {};
      return this.dpo = {
        x: 0,
        y: 0
      };
    };

    _Class.prototype.move_point_end = function(grafter, point) {
      var _this = this;

      return function(x, y, e) {
        grafter.draw_glass();
        return point.representation.toFront();
      };
    };

    _Class.prototype.make_undraggable = function() {
      var point, _i, _len, _ref, _ref1;

      this.points_draggable = (_ref = this.points_draggable) != null ? _ref : false;
      if (this.points_draggable) {
        _ref1 = this.contour.points;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          point = _ref1[_i];
          point.representation.undrag();
          if (point.border === 'none') {
            point.representation.attr({
              fill: 'black',
              stroke: 'black',
              r: this.POINT_WIDTH,
              'fill-opacity': 1
            });
          }
        }
        return this.points_draggable = false;
      }
    };

    _Class.prototype.remove_point = function(e, x, y) {
      var p, q, r;

      p = this.fit_point(x, y);
      q = this.contour.find_point_near(p.x, p.y, this.POINT_WIDTH * 5);
      if (q !== -1 && this.contour.can_remove_point(q)) {
        r = this.contour.get_point(q);
        r.representation.remove();
        this.contour.remove_point(q);
        this.draw_glass();
        this.remove_point_point.hide();
        return this.remove_point_line.hide();
      }
    };

    _Class.prototype.change_line = function(grafter, kind) {
      var _this = this;

      return function(e, x, y) {
        var below, c1, c2, cbottom, clbottom, cltop, ctop, p, point, q;

        p = _this.fit_point(x, y);
        q = _this.contour.get_point_above_height(p.y);
        if (kind === 'curve') {
          if (q !== -1 && q !== (_this.contour.points.length - 1)) {
            grafter.contour.make_curve(q);
            point = grafter.contour.get_point(q);
            below = grafter.contour.get_point(q + 1);
            c1 = point.segment.c1;
            c2 = point.segment.c2;
            if ((c1 != null ? c1.representation : void 0) == null) {
              c1.representation = _this.paper.circle(c1.x, c1.y, _this.POINT_WIDTH * 2);
              c1.line = _this.paper.path("M" + point.x + "," + point.y + "L" + c1.x + "," + c1.y);
            }
            ctop = c1.representation;
            ctop.attr({
              cx: c1.x,
              cy: c1.y,
              fill: 'orange',
              stroke: 'orange',
              'fill-opacity': 0.3
            });
            cltop = c1.line;
            cltop.attr({
              path: "M" + point.x + "," + point.y + "L" + c1.x + "," + c1.y,
              stroke: 'orange',
              'stroke-dasharray': '.'
            });
            ctop.drag(_this.move_control_point(_this, point, ctop, cltop, 1), _this.control_point_start, _this.control_point_end(_this, point, ctop));
            if ((c2 != null ? c2.representation : void 0) == null) {
              c2.representation = _this.paper.circle(c2.x, c2.y, _this.POINT_WIDTH * 2);
              c2.line = _this.paper.path("M" + below.x + "," + below.y + "L" + c2.x + "," + c2.y);
            }
            cbottom = c2.representation;
            cbottom.attr({
              cx: c2.x,
              cy: c2.y,
              fill: 'orange',
              stroke: 'orange',
              'fill-opacity': 0.3
            });
            clbottom = c2.line;
            clbottom.attr({
              path: "M" + below.x + "," + below.y + "L" + c2.x + "," + c2.y,
              stroke: 'orange',
              'stroke-dasharray': '.'
            });
            cbottom.drag(_this.move_control_point(_this, point, cbottom, clbottom, 2), _this.control_point_start, _this.control_point_end(_this, c1, cbottom));
            return grafter.draw_glass();
          }
        } else {
          if (q !== -1) {
            grafter.contour.make_straight(q);
            return grafter.draw_glass();
          }
        }
      };
    };

    _Class.prototype.move_control_point = function(grafter, point, representation, line, cp) {
      var _this = this;

      return function(dx, dy, x, y, e) {
        var below, newp, p, start, tx, ty;

        tx = dx - grafter.dpo.x;
        ty = dy - grafter.dpo.y;
        p = grafter.contour.find_point_at(point.y);
        below = grafter.contour.get_point(p + 1);
        newp = {
          x: representation.attr('cx') + tx,
          y: representation.attr('cy') + ty
        };
        if (grafter.contour.can_move_control_point(p, newp.x, newp.y)) {
          grafter.contour.move_control_point(p, cp, newp.x, newp.y);
          representation.attr({
            cx: newp.x,
            cy: newp.y
          });
          start = cp === 1 ? point : below;
          line.attr({
            path: "M" + start.x + "," + start.y + "L" + newp.x + "," + newp.y
          });
          grafter.dpo = {
            x: dx,
            y: dy
          };
          return grafter.draw_glass();
        }
      };
    };

    _Class.prototype.control_point_start = function() {
      var _ref;

      this.dpo = (_ref = this.dpo) != null ? _ref : {};
      return this.dpo = {
        x: 0,
        y: 0
      };
    };

    _Class.prototype.control_point_end = function(grafter, above, representation) {
      var _this = this;

      return function(x, y, e) {
        return grafter.draw_glass();
      };
    };

    _Class.prototype.draw_glass = function() {
      this.glass_base.attr({
        path: this.contour.to_glass_path('base')
      });
      this.glass_bowl.attr({
        path: this.contour.to_glass_path()
      });
      return this.glass_contour.attr({
        path: this.contour.to_path()
      });
    };

    _Class.prototype.change_mode = function(mode) {
      var _ref;

      this.reset_mouse();
      this.make_undraggable();
      this.mode = (_ref = this.mode) != null ? _ref : {};
      this.mode = mode;
      if (this.mode === 'normal') {
        this.make_draggable();
      } else {
        this.make_undraggable();
      }
      if (this.mode === 'curve') {
        return this.make_cp_draggable();
      } else {
        return this.make_cp_undraggable();
      }
    };

    _Class.prototype.make_cp_draggable = function() {
      var next_point, point, s, _i, _len, _ref, _ref1;

      this.cp_points_draggable = (_ref = this.cp_points_draggable) != null ? _ref : false;
      if (!this.cp_points_draggable) {
        _ref1 = this.contour.points;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          point = _ref1[_i];
          s = point.segment;
          if (s.type === 'curve') {
            point.segment.c1.representation.attr({
              cx: point.segment.c1.x,
              cy: point.segment.c1.y
            });
            point.segment.c1.representation.show();
            point.segment.c2.representation.attr({
              cx: point.segment.c2.x,
              cy: point.segment.c2.y
            });
            point.segment.c2.representation.show();
            point.segment.c1.line.attr({
              path: "M" + point.x + "," + point.y + "L" + point.segment.c1.x + "," + point.segment.c1.y
            });
            point.segment.c1.line.show();
            next_point = this.contour.get_point(this.contour.find_point_at(point.y) + 1);
            point.segment.c2.line.attr({
              path: "M" + next_point.x + "," + next_point.y + "L" + point.segment.c2.x + "," + point.segment.c2.y
            });
            point.segment.c2.line.show();
          }
        }
        return this.cp_points_draggable = true;
      }
    };

    _Class.prototype.make_cp_undraggable = function() {
      var point, s, _i, _len, _ref, _ref1;

      this.cp_points_draggable = (_ref = this.cp_points_draggable) != null ? _ref : false;
      if (this.cp_points_draggable) {
        _ref1 = this.contour.points;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          point = _ref1[_i];
          s = point.segment;
          if (s.type === 'curve') {
            point.segment.c1.representation.hide();
            point.segment.c2.representation.hide();
            point.segment.c1.line.hide();
            point.segment.c2.line.hide();
          }
        }
        return this.cp_points_draggable = false;
      }
    };

    _Class.prototype.draw = function() {
      var mid_line;

      this.elements = this.paper.set();
      this.glass_base = this.paper.path(this.contour.to_glass_path('base'));
      this.glass_base.attr({
        fill: 'black',
        'fill-opacity': 0.3,
        stroke: 'gray',
        'stroke-width': 2,
        'stroke-dasharray': ''
      });
      this.glass_bowl = this.paper.path(this.contour.to_glass_path());
      this.glass_bowl.attr({
        stroke: 'black',
        'stroke-width': 2,
        'stroke-dasharray': ''
      });
      this.draw_axis('radius');
      this.draw_axis('height');
      this.potential_point = this.paper.circle(0, 0, this.POINT_WIDTH * 2);
      this.potential_point.attr({
        fill: 'green',
        opacity: 0.5
      });
      this.potential_point.hide();
      this.potential_above = this.paper.path("M0,0");
      this.potential_above.attr({
        stroke: 'green',
        opacity: 0.5,
        'stroke-dasharray': '-'
      });
      this.potential_above.hide();
      this.potential_below = this.paper.path("M0,0");
      this.potential_below.attr({
        stroke: 'green',
        opacity: 0.5,
        'stroke-dasharray': '-'
      });
      this.potential_below.hide();
      this.remove_point_point = this.paper.circle(0, 0, this.POINT_WIDTH * 4);
      this.remove_point_point.attr({
        fill: 'red',
        stroke: 'red',
        opacity: 0.5
      });
      this.remove_point_point.hide();
      this.remove_point_line = this.paper.path("M0,0");
      this.remove_point_line.attr({
        stroke: 'red',
        opacity: 0.5,
        'stroke-dasharray': '-'
      });
      this.remove_point_line.hide();
      this.change_line_area = this.paper.rect(this.CANVAS_MID, this.CANVAS_BOTTOM, this.CANVAS_WIDTH / 2, 0);
      this.change_line_area.attr({
        fill: 'orange',
        opacity: 0.5
      });
      this.change_line_area.hide();
      this.glass_contour = this.paper.path(this.contour.to_path());
      this.glass_contour.attr({
        stroke: 'DarkGreen',
        'stroke-width': 3
      });
      this.canvas = this.paper.rect(this.CANVAS_MID, this.CANVAS_TOP, this.CANVAS_WIDTH / 2, this.CANVAS_HEIGHT);
      this.canvas.attr({
        fill: 'white',
        'fill-opacity': 0,
        stroke: 'black',
        'stroke-width': 2
      });
      mid_line = this.paper.path("M" + this.CANVAS_MID + "," + this.CANVAS_TOP + "v" + this.CANVAS_HEIGHT);
      mid_line.attr({
        stroke: 'white',
        'stroke-width': 2,
        'stroke-dasharray': '.'
      });
      this.glass_contour.hide();
      this.draw_buttons();
      this.foot = this.draw_border(this.contour.foot, '');
      this.foot.attr({
        stroke: 'black'
      });
      this.stem = this.draw_border(this.contour.stem);
      this.bowl = this.draw_border(this.contour.bowl);
      this.edge = this.draw_border(this.contour.edge);
      this.foot_point = this.draw_point(this.contour.foot);
      this.contour.foot.representation = this.foot_point;
      this.stem_point = this.draw_point(this.contour.stem);
      this.contour.stem.representation = this.stem_point;
      this.bowl_point = this.draw_point(this.contour.bowl);
      this.contour.bowl.representation = this.bowl_point;
      this.edge_point = this.draw_point(this.contour.edge);
      return this.contour.edge.representation = this.edge_point;
    };

    _Class.prototype.draw_point = function(p) {
      var point;

      if (p.border !== 'none') {
        point = this.paper.circle(p.x, p.y, this.POINT_WIDTH * 2);
        point.attr({
          fill: 'white',
          stroke: 'black',
          'stroke-width': 2
        });
      } else {
        point = this.paper.circle(p.x, p.y, this.POINT_WIDTH);
        point.attr({
          fill: 'black',
          stroke: 'black',
          'stroke-width': this.POINT_WIDTH,
          'stroke-opacity': 0
        });
      }
      p.representation = point;
      return point;
    };

    _Class.prototype.draw_border = function(border, dashing) {
      var border_line;

      if (dashing == null) {
        dashing = '-';
      }
      border_line = this.paper.path("M" + this.CANVAS_MID + "," + border.y + "h" + this.BORDER_WIDTH);
      border_line.attr({
        stroke: 'navy',
        'stroke-dasharray': dashing
      });
      return border_line;
    };

    _Class.prototype.draw_buttons = function() {
      var action, button, buttongroup, group, name, optiongroup, optiongroups, sep, x, y, _ref, _ref1, _ref2, _ref3, _results;

      x = this.CANVAS_MID;
      y = this.CANVAS_TOP - this.CANVAS_SEP - this.BUTTON_WIDTH;
      this.mode = "";
      group = '';
      optiongroups = {};
      sep = 0;
      this.buttons = {};
      _ref = this.actions;
      for (name in _ref) {
        action = _ref[name];
        if (__indexOf.call(this.prop.buttons, name) >= 0) {
          button = action.button;
          if (group !== '') {
            if (button.group === group) {
              x += this.BUTTON_WIDTH + this.BUTTON_SEP;
            } else {
              x += this.BUTTON_WIDTH + this.GROUP_SEP;
            }
          }
          group = button.group;
          switch (button.type) {
            case 'action':
              this.buttons.name = new ActionButton(this.paper, {
                x: x,
                y: y,
                icon: button.icon,
                tooltip: button.tooltip,
                action: button.action
              });
              break;
            case 'switch':
              this.buttons.name = new SwitchButton(this.paper, {
                x: x,
                y: y,
                icon: button.icon,
                tooltip: button.tooltip,
                switched_on: (_ref1 = button != null ? button.switched_on : void 0) != null ? _ref1 : false,
                on_switch_on: button.on_switch_on,
                on_switch_off: button.on_switch_off
              });
              break;
            case 'group':
              optiongroups[button.option_group] = (_ref2 = optiongroups[button.option_group]) != null ? _ref2 : [];
              optiongroups[button.option_group].push({
                x: x,
                y: y,
                icon: button.icon,
                tooltip: button.tooltip,
                value: name,
                on_select: button.on_select,
                chosen: (_ref3 = button["default"]) != null ? _ref3 : false
              });
          }
        }
      }
      _results = [];
      for (name in optiongroups) {
        optiongroup = optiongroups[name];
        buttongroup = new ButtonGroup(this.paper, optiongroup);
        _results.push((function() {
          var _i, _len, _ref4, _results1;

          _ref4 = buttongroup.buttons;
          _results1 = [];
          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
            button = _ref4[_i];
            _results1.push(this.buttons[button.value] = button);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    _Class.prototype.draw_axis = function(axis) {
      var AXISLABELSEP, HALFTICKSLENGTH, LABELSEP, TICKSLENGTH, albb, axis_label, end, i, label, label_text, ltbb, movement, path, step, x, y;

      TICKSLENGTH = 10;
      HALFTICKSLENGTH = TICKSLENGTH / 2;
      LABELSEP = 5;
      AXISLABELSEP = 30;
      path = '';
      step = 5 * this.PIXELS_PER_MM;
      label = 0;
      i = 0;
      if (axis === 'radius') {
        movement = 'v';
        x = this.CANVAS_MID;
        end = this.CANVAS_MID + this.BORDER_WIDTH;
        while (x <= end) {
          path += "M" + x + "," + this.CANVAS_BOTTOM;
          if ((i % 10) === 0) {
            path += "" + movement + TICKSLENGTH;
            label_text = this.paper.text(x, 0, label);
            label_text.attr({
              'font-family': 'sans-serif',
              'font-size': '12pt'
            });
            ltbb = label_text.getBBox();
            label_text.attr({
              y: this.CANVAS_BOTTOM + LABELSEP + ltbb.height
            });
            label += 1;
          } else {
            path += "" + movement + HALFTICKSLENGTH;
          }
          x += step;
          i += 5;
        }
        axis_label = this.paper.text(0, 0, 'straal (cm)');
        axis_label.attr({
          'font-family': 'sans-serif',
          'font-size': '14pt',
          'text-anchor': 'start'
        });
        albb = axis_label.getBBox();
        axis_label.attr({
          x: this.CANVAS_RIGHT - albb.width,
          y: this.CANVAS_BOTTOM + LABELSEP + albb.height + TICKSLENGTH + LABELSEP
        });
      } else {
        movement = 'h';
        y = this.CANVAS_BOTTOM;
        end = this.CANVAS_TOP;
        while (y >= end) {
          path += "M" + this.CANVAS_RIGHT + "," + y;
          if ((i % 10) === 0) {
            path += "" + movement + TICKSLENGTH;
            label_text = this.paper.text(0, y, 99);
            label_text.attr({
              'font-family': 'sans-serif',
              'font-size': '12pt'
            });
            ltbb = label_text.getBBox();
            label_text.attr({
              x: this.CANVAS_RIGHT + LABELSEP + TICKSLENGTH + ltbb.width,
              'text-anchor': 'end',
              text: label
            });
            label += 1;
          } else {
            path += "" + movement + HALFTICKSLENGTH;
          }
          y -= step;
          i += 5;
        }
        axis_label = this.paper.text(0, 0, 'hoogte (cm)');
        axis_label.attr({
          'font-family': 'sans-serif',
          'font-size': '14pt',
          'text-anchor': 'start'
        });
        albb = axis_label.getBBox();
        axis_label.attr({
          x: this.CANVAS_RIGHT - albb.width,
          y: this.CANVAS_BOTTOM + LABELSEP + albb.height + TICKSLENGTH + LABELSEP
        });
        axis_label.transform("r-90," + this.CANVAS_RIGHT + "," + this.CANVAS_BOTTOM + "t" + this.CANVAS_HEIGHT + "," + LABELSEP);
      }
      axis = this.paper.path(path);
      axis.attr({
        stroke: 'black',
        'stroke-width': 2
      });
      return axis;
    };

    return _Class;

  })(Widget);

  module.exports = WGlassGrafter;

}).call(this);

/*
//@ sourceMappingURL=wgrafter.map
*/

},{"../widget":7,"./contour_line":11,"../buttons/button":12,"../buttons/action_button":13,"../buttons/switch_button":14,"../buttons/button_group":15}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*

(c) 2012, Huub de Beer, H.T.de.Beer@gmail.com
*/


(function() {
  var Widget,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Widget = (function() {
    function Widget(canvas, x, y, spec) {
      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.spec = spec != null ? spec : {};
      this.disable_draggable = __bind(this.disable_draggable, this);
      this.enable_draggable = __bind(this.enable_draggable, this);
      this.drag_move = __bind(this.drag_move, this);
      this.drag_end = __bind(this.drag_end, this);
      this.drag_start = __bind(this.drag_start, this);
      this.stop_draggable = __bind(this.stop_draggable, this);
      this.start_draggable = __bind(this.start_draggable, this);
      this.select = __bind(this.select, this);
      this.disable_selectable = __bind(this.disable_selectable, this);
      this.enable_selectable = __bind(this.enable_selectable, this);
      this.stop_selectable = __bind(this.stop_selectable, this);
      this.start_selectable = __bind(this.start_selectable, this);
      this.widgets = this.canvas.set();
      this.dx = this.dy = 0;
      this.selected = false;
    }

    Widget.prototype.start_selectable = function(slot) {
      this.slot = slot;
      this.glasspane.mouseover(this.enable_selectable);
      return this.glasspane.mouseout(this.disable_selectable);
    };

    Widget.prototype.stop_selectable = function() {
      this.glasspane.unmouseover(this.enable_selectable);
      return this.glasspane.unmouseout(this.disable_selectable);
    };

    Widget.prototype.enable_selectable = function() {
      return this.glasspane.dblclick(this.select);
    };

    Widget.prototype.disable_selectable = function() {
      return this.glasspane.undblclick(this.select);
    };

    Widget.prototype.select = function() {
      var _ref;

      if (this.selected) {
        this.selected = false;
        this.slot.selected = null;
        this.disable_draggable();
        return this.glasspane.attr('stroke-opacity', 0);
      } else {
        this.selected = true;
        if ((_ref = this.slot) != null ? _ref.selected : void 0) {
          this.slot.selected.select();
        }
        this.slot.selected = this;
        this.widgets.toFront();
        this.enable_draggable();
        return this.glasspane.attr('stroke-opacity', 0.5);
      }
    };

    Widget.prototype.start_draggable = function() {
      this.glasspane.mouseover(this.enable_draggable);
      return this.glasspane.mouseout(this.disable_draggable);
    };

    Widget.prototype.stop_draggable = function() {
      this.glasspane.unmouseover(this.enable_draggable);
      return this.glasspane.unmouseout(this.disable_draggable);
    };

    Widget.prototype.drag_start = function() {
      var _ref;

      this.dpo = (_ref = this.dpo) != null ? _ref : {};
      return this.dpo = {
        x: 0,
        y: 0
      };
    };

    Widget.prototype.drag_end = function() {};

    Widget.prototype.drag_move = function(dx, dy, x, y, e) {
      var tx, ty;

      tx = Math.floor(dx - this.dpo.x);
      ty = Math.floor(dy - this.dpo.y);
      this.x += tx;
      this.y += ty;
      this.widgets.transform("...t" + tx + "," + ty);
      return this.dpo = {
        x: dx,
        y: dy
      };
    };

    Widget.prototype.enable_draggable = function() {
      this.widgets.attr('cursor', 'move');
      return this.widgets.drag(this.drag_move, this.drag_start, this.drag_end);
    };

    Widget.prototype.disable_draggable = function() {
      this.widgets.attr('cursor', 'default');
      return this.widgets.undrag();
    };

    Widget.prototype.place_at = function(x, y) {
      /*
      Place this widget at co-ordinates x an y
      */
      this._compute_geometry();
      this.dx = x - this.geometry.left;
      this.dy = y - this.geometry.top;
      this.widgets.transform("...t" + this.dx + "," + this.dy);
      this.x = x;
      this.y = y;
      this._compute_geometry();
      return this;
    };

    Widget.prototype.fit_point = function(x, y) {
      var point;

      point = {
        x: x - this.canvas.canvas.parentNode.offsetLeft,
        y: y - this.canvas.canvas.parentNode.offsetTop
      };
      return point;
    };

    Widget.prototype._draw = function() {
      /*
      Draw this widget. Virtual method to be overloaded by all subclasses of 
      Widget. All shapes drawn are added to the list of widgets
      */

    };

    Widget.prototype._compute_geometry = function() {
      /*
      Compute the left, top, bottom, right, width, height, and center of this 
      widget given its top-left corner (x, y). 
      
      This does not work with paths that do not start at (0,0)
      */

      var bbox;

      bbox = this.widgets.getBBox();
      this.geometry = {};
      this.geometry.width = bbox.width;
      this.geometry.height = bbox.height;
      this.geometry.top = bbox.y;
      this.geometry.left = bbox.x;
      this.geometry.right = bbox.x2;
      this.geometry.bottom = bbox.y2;
      return this.geometry.center = {
        x: (this.geometry.right - this.geometry.left) / 2 + this.geometry.left,
        y: (this.geometry.bottom - this.geometry.top) / 2 + this.geometry.top
      };
    };

    return Widget;

  })();

  module.exports = Widget;

}).call(this);

/*
//@ sourceMappingURL=widget.map
*/

},{}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*
 (c) 2012, Huub de Beer, H.T.de.Beer@gmail.com
*/


(function() {
  var MeasureLine;

  MeasureLine = (function() {
    MeasureLine.EPSILON = 0.01;

    MeasureLine.prototype.to_json = function() {
      var export_object;

      export_object = {
        volume: this.volume,
        height: this.height,
        initial_position: this.initial_position,
        position: {
          x: this.position.x,
          y: this.position.y
        },
        side: this.side,
        movable: this.movable,
        visible: this.visible
      };
      return JSON.stringify(export_object);
    };

    MeasureLine.prototype.from_json = function(mljson) {
      this.volume = mljson.volume;
      this.height = mljson.height;
      this.initial_position = mljson.initial_position;
      this.position = mljson.position;
      this.side = mljson.side;
      this.movable = mljson.movable;
      return this.visible = mljson.visible;
    };

    function MeasureLine(volume, height, glass, initial_position, side, visible, movable) {
      this.volume = volume;
      this.height = height;
      this.glass = glass;
      this.initial_position = initial_position != null ? initial_position : {
        x: -1,
        y: -1
      };
      this.side = side != null ? side : 'right';
      this.visible = visible != null ? visible : false;
      this.movable = movable != null ? movable : true;
      this.set_position(this.initial_position);
    }

    MeasureLine.prototype.reset = function() {
      /*
      */
      return this.set_position(this.initial_position);
    };

    MeasureLine.prototype.hide = function() {
      return this.visible = false;
    };

    MeasureLine.prototype.show = function() {
      return this.visible = true;
    };

    MeasureLine.prototype.set_position = function(position) {
      /*
      Set the position of this measure line. Position is a point (x, y). Subsequently the height in mm can be computed.
      */
      this.position = position;
      return this.height = (this.glass.foot.y - this.position.y) / this.glass.unit;
    };

    MeasureLine.prototype.is_correct = function() {
      /*
      Is this measure line on the correct height on the glass? That is: is the error smaller than epsilon?
      */
      return Math.abs(this.error) <= MeasureLine.EPSILON;
    };

    MeasureLine.prototype.error = function() {
      /*
      The distance of this measure line to the correct position in mm. A negative error means it is too hight, a positive distance that it is too low
      */
      return (this.glass.height_at_volume(this.volume)) - this.height;
    };

    return MeasureLine;

  })();

  module.exports = MeasureLine;

}).call(this);

/*
//@ sourceMappingURL=measure_line.map
*/

},{}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var ContourLine;

  ContourLine = (function() {
    function _Class(left, top, width, height, mm_per_pixel, record) {
      var FOOTHEIGHT, STEMHEIGHT, STEMWIDTH;

      this.mm_per_pixel = mm_per_pixel;
      this.record = record != null ? record : false;
      this.mid = {
        x: left,
        y: Math.floor(top + height / 2)
      };
      this.min = {
        x: left - width,
        y: top,
        width: 25
      };
      this.max = {
        x: left + width,
        y: top + height
      };
      FOOTHEIGHT = 20;
      STEMWIDTH = 10;
      STEMHEIGHT = 20;
      this.foot = {
        x: Math.floor(this.mid.x + width / 3),
        y: this.max.y,
        border: 'foot',
        segment: {
          type: 'straight',
          c1: {
            x: 0,
            y: 0
          },
          c2: {
            x: 0,
            y: 0
          }
        }
      };
      this.stem = {
        x: Math.floor(this.mid.x + width / 3),
        y: Math.floor(this.max.y - FOOTHEIGHT),
        border: 'stem',
        segment: {
          type: 'straight',
          c1: {
            x: 0,
            y: 0
          },
          c2: {
            x: 0,
            y: 0
          }
        }
      };
      this.bowl = {
        x: Math.floor(this.mid.x + width / 3),
        y: Math.floor(this.max.y - (FOOTHEIGHT + STEMHEIGHT)),
        border: 'bowl',
        segment: {
          type: 'straight',
          c1: {
            x: 0,
            y: 0
          },
          c2: {
            x: 0,
            y: 0
          }
        }
      };
      this.edge = {
        x: Math.floor(this.mid.x + width / 3),
        y: Math.floor(this.max.y - (height / 2)),
        border: 'edge',
        segment: {
          type: 'straight',
          c1: {
            x: 0,
            y: 0,
            line: null,
            representation: null
          },
          c2: {
            x: 0,
            y: 0,
            line: null,
            representation: null
          }
        }
      };
      this.points = [this.edge, this.bowl, this.stem, this.foot];
    }

    _Class.prototype.get_point = function(p) {
      return this.points[p];
    };

    _Class.prototype.get_point_above_height = function(h) {
      var p;

      p = 0;
      while (p < this.points.length && this.points[p].y < h) {
        p++;
      }
      return p - 1;
    };

    _Class.prototype.can_add_point = function(x, y) {
      var p, point, result;

      result = false;
      p = this.get_point_above_height(y);
      if (p !== -1) {
        point = this.points[p];
        if (point.y === y) {
          result = false;
        } else {
          result = true;
        }
      }
      return result;
    };

    _Class.prototype.can_remove_point = function(p) {
      return this.points[p].border === 'none';
    };

    _Class.prototype.can_move_point = function(p, x, y, r) {
      var result;

      if (r == null) {
        r = 1;
      }
      result = false;
      if ((this.mid.x + r <= x && x <= this.max.x) && (this.min.y <= y && y <= this.max.y)) {
        if ((0 < p && p < this.points.length - 1)) {
          if ((this.points[p - 1].y + r < y && y < this.points[p + 1].y - r)) {
            result = true;
          }
        } else {
          if (p === 0) {
            result = y < this.points[p + 1].y && x >= (this.mid.x + this.min.width);
          } else {
            result = this.points[p - 1].y < y;
          }
        }
      }
      return result;
    };

    _Class.prototype.can_move_control_point = function(p, x, y) {
      var above, below;

      if (p < this.points.length - 1) {
        above = this.points[p];
        below = this.points[p + 1];
        return (this.mid.x <= x && x <= this.max.x) && (above.y <= y && y <= below.y);
      } else {
        return false;
      }
    };

    _Class.prototype.can_move_border = function(border, x, y) {};

    _Class.prototype.find_point_at = function(y, r) {
      var p, _ref;

      if (r == null) {
        r = 1;
      }
      p = 0;
      while (p < this.points.length && !(((y - r) <= (_ref = this.points[p].y) && _ref <= (y + r)))) {
        p++;
      }
      return p = p === this.points.length ? -1 : p;
    };

    _Class.prototype.find_point_near = function(x, y, r) {
      var ar, found, _ref;

      if (r == null) {
        r = 1;
      }
      found = -1;
      ar = 0;
      while (found === -1 && ar < r) {
        found = Math.max(this.find_point_at(y + ar), this.find_point_at(y - ar));
        if (found !== -1 && (x - ar <= (_ref = this.points[found].x) && _ref <= x + ar)) {
          break;
        } else {
          found = -1;
        }
        ar++;
      }
      return found;
    };

    _Class.prototype.add_point = function(x, y, representation) {
      var above, below, head, p, point, tail;

      p = this.get_point_above_height(y);
      head = [];
      if (!(p < 0)) {
        head = this.points.slice(0, +p + 1 || 9e9);
      }
      tail = this.points.slice(p + 1);
      above = this.points[p];
      below = this.points[p + 1];
      point = {
        x: x,
        y: y,
        border: 'none',
        segment: {
          type: 'straight',
          c1: {
            x: 0,
            y: 0,
            line: null,
            representation: null
          },
          c2: {
            x: 0,
            y: 0,
            line: null,
            representation: null
          }
        },
        representation: representation
      };
      above.segment.c2.y = y - Math.abs(above.segment.c2.y - below.y);
      this.points = head.concat(point, tail);
      return point;
    };

    _Class.prototype.remove_point = function(p) {
      var head, tail;

      head = this.points.slice(0, p);
      tail = p === this.points.length - 1 ? [] : this.points.slice(p + 1);
      return this.points = head.concat(tail);
    };

    _Class.prototype.move_point = function(p, x, y) {
      this.points[p].x = x;
      this.points[p].y = y;
      if (this.points[p].segment.type === 'curve') {
        this.set_control_points(p);
      }
      if (p !== 0 && this.points[p - 1].segment.type === 'curve') {
        return this.set_control_points(p - 1);
      }
    };

    _Class.prototype.set_control_points = function(p) {
      var above, below, dxc1, dxc2, dy;

      if (p !== this.points.length - 1) {
        above = this.points[p];
        below = this.points[p + 1];
        dxc1 = Math.abs(this.mid.x - above.x) / 2;
        dxc2 = Math.abs(this.mid.x - below.x) / 2;
        dy = Math.abs(above.y - below.y) / 4;
        above.segment.c1.x = above.x - dxc1;
        above.segment.c1.y = above.y + dy;
        above.segment.c2.x = below.x - dxc2;
        return above.segment.c2.y = below.y - dy;
      }
    };

    _Class.prototype.make_curve = function(p) {
      var point_segment;

      point_segment = this.points[p].segment;
      point_segment.type = 'curve';
      return this.set_control_points(p);
    };

    _Class.prototype.make_straight = function(p) {
      this.points[p].segment.type = 'straight';
      this.points[p].segment.c1.representation.remove();
      this.points[p].segment.c1.line.remove();
      this.points[p].segment.c2.line.remove();
      this.points[p].segment.c2.representation.remove();
      this.points[p].segment.c1.representation = null;
      this.points[p].segment.c1.line = null;
      this.points[p].segment.c2.line = null;
      return this.points[p].segment.c2.representation = null;
    };

    _Class.prototype.move_control_point = function(p, cp, x, y) {
      var point;

      if (cp === 1) {
        point = this.points[p].segment.c1;
      } else {
        point = this.points[p].segment.c2;
      }
      point.x = x;
      return point.y = y;
    };

    _Class.prototype.move_border = function(border, x, y) {};

    _Class.prototype.to_path = function() {
      var i, p, path, q;

      p = this.points[0];
      path = "M" + p.x + "," + p.y;
      i = 0;
      while (i < this.points.length - 1) {
        p = this.points[i];
        q = this.points[i + 1];
        switch (p.segment.type) {
          case 'straight':
            path += "L" + q.x + "," + q.y;
            break;
          case 'curve':
            path += "C" + p.segment.c1.x + "," + p.segment.c1.y + "," + p.segment.c2.x + "," + p.segment.c2.y + "," + q.x + "," + q.y;
        }
        i++;
      }
      return path;
    };

    _Class.prototype.to_glass_path = function(part) {
      var i, mid, mirror, p, path, q;

      if (part == null) {
        part = 'full';
      }
      i = 0;
      switch (part) {
        case 'full':
          i = 0;
          break;
        case 'base':
          while (this.points[i].border !== 'bowl') {
            i++;
          }
      }
      p = this.points[i];
      path = "M" + p.x + "," + p.y;
      while (i < this.points.length - 1) {
        p = this.points[i];
        q = this.points[i + 1];
        switch (p.segment.type) {
          case 'straight':
            path += "L" + q.x + "," + q.y;
            break;
          case 'curve':
            path += "C" + p.segment.c1.x + "," + p.segment.c1.y + "," + p.segment.c2.x + "," + p.segment.c2.y + "," + q.x + "," + q.y;
        }
        i++;
      }
      mid = this.mid;
      mirror = function(x) {
        return x - 2 * (x - mid.x);
      };
      p = this.points[i];
      path += "H" + (mirror(p.x));
      while (i > 0) {
        p = this.points[i];
        q = this.points[i - 1];
        if (part === 'base' && p.border === 'bowl') {
          path += "H" + p.x + "H" + (mirror(p.x));
          break;
        }
        switch (q.segment.type) {
          case 'straight':
            path += "L" + (mirror(q.x)) + "," + q.y;
            break;
          case 'curve':
            path += "C" + (mirror(q.segment.c2.x)) + "," + q.segment.c2.y + "," + (mirror(q.segment.c1.x)) + "," + q.segment.c1.y + "," + (mirror(q.x)) + "," + q.y;
        }
        i--;
      }
      return path;
    };

    _Class.prototype.to_glass = function(spec) {
      var glass, height_in_mm, midbowl, midedge, midfoot, midstem, path;

      height_in_mm = Math.floor((this.foot.y - this.edge.y) * this.mm_per_pixel);
      path = this.to_relative_path();
      midfoot = {
        x: this.mid.x,
        y: this.foot.y
      };
      midstem = {
        x: this.mid.x,
        y: this.stem.y
      };
      midbowl = {
        x: this.mid.x,
        y: this.bowl.y
      };
      midedge = {
        x: this.mid.x,
        y: this.edge.y
      };
      glass = new Glass(path, midfoot, midstem, midbowl, midedge, height_in_mm, spec);
      return glass;
    };

    _Class.prototype.from_glass = function(glass) {
      var factor, mm_per_pixel;

      mm_per_pixel = glass.height_in_mm / (glass.foot.y - glass.edge.y);
      return factor = this.mm_per_pixel / mm_per_pixel;
    };

    _Class.prototype.to_relative_path = function() {
      var elt, path, relpath, relsegs, seg, _i, _j, _len, _len1;

      path = this.to_path();
      relsegs = Raphael.pathToRelative(path);
      relpath = "";
      for (_i = 0, _len = relsegs.length; _i < _len; _i++) {
        seg = relsegs[_i];
        for (_j = 0, _len1 = seg.length; _j < _len1; _j++) {
          elt = seg[_j];
          relpath += "" + elt + " ";
        }
      }
      return relpath.replace(/\s$/, '');
    };

    return _Class;

  })();

  module.exports = ContourLine;

}).call(this);

/*
//@ sourceMappingURL=contour_line.map
*/

},{}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Button;

  Button = (function() {
    _Class.WIDTH = 34;

    _Class.set_width = function(width) {
      return this.WIDTH = width;
    };

    _Class.BASEPATH = '.';

    _Class.set_base_path = function(basepath) {
      if (basepath == null) {
        basepath = '.';
      }
      return this.BASEPATH = basepath;
    };

    function _Class(paper, button) {
      var _ref, _ref1, _ref2, _ref3;

      this.paper = paper;
      this.prop = this.initialize_properties();
      this.x = (_ref = button != null ? button.x : void 0) != null ? _ref : 0;
      this.y = (_ref1 = button != null ? button.y : void 0) != null ? _ref1 : 0;
      this.icon = (_ref2 = button != null ? button.icon : void 0) != null ? _ref2 : "none.png";
      this.tooltip = (_ref3 = button != null ? button.tooltip : void 0) != null ? _ref3 : "";
      this.draw();
    }

    _Class.prototype.initialize_properties = function() {
      return {
        corners: 2,
        normal: {
          fill: 'white',
          stroke: 'silver',
          'fill-opacity': 1,
          'stroke-opacity': 0.5,
          'stroke-width': 0.5
        },
        disabled: {
          fill: 'gray',
          stroke: 'silver',
          'fill-opacity': 0.5,
          'stroke-opacity': 0.8
        },
        activated: {
          'stroke-width': 2,
          fill: 'yellow',
          stroke: 'gray',
          'fill-opacity': 0.25,
          'stroke-opacity': 1
        },
        switched_on: {
          fill: 'purple',
          'stroke-width': 2,
          stroke: 'gray',
          'fill-opacity': 0.25,
          'stroke-opacity': 1
        },
        highlight: {
          fill: 'orange',
          stroke: 'gray',
          'fill-opacity': 0.5,
          'stroke-opacity': 1
        }
      };
    };

    _Class.prototype.draw = function() {
      var basepath, width;

      width = Button.WIDTH;
      this.back = this.paper.rect(this.x, this.y, width, width);
      this.back.attr(this.prop.normal);
      basepath = Button.BASEPATH;
      this.image = this.paper.image("" + basepath + "/" + this.icon + ".png", this.x + 1, this.y + 1, width - 2, width - 2);
      this.image.attr({
        'font-family': 'sans-serif',
        'font-size': "" + (width - 2) + "px",
        title: this.tooltip
      });
      return this.elements = this.paper.set(this.back, this.image);
    };

    return _Class;

  })();

  module.exports = Button;

}).call(this);

/*
//@ sourceMappingURL=button.map
*/

},{}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*
(c) 2012, Huub de Beer, H.T.de.Beer@gmail.com
*/


(function() {
  var MeasureLine, WMeasureLine, Widget,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Widget = require('../widget');

  MeasureLine = require('./measure_line');

  WMeasureLine = (function(_super) {
    __extends(WMeasureLine, _super);

    function WMeasureLine(canvas, x, y, ml, foot, spec) {
      var _this = this;

      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.ml = ml;
      this.foot = foot;
      this.spec = spec != null ? spec : {};
      this.end = __bind(this.end, this);
      this.start = __bind(this.start, this);
      this.drag = __bind(this.drag, this);
      WMeasureLine.__super__.constructor.call(this, this.canvas, this.x, this.y, this.spec);
      this._draw();
      if (this.ml.movable) {
        this.widgets.mouseover(function(e) {
          return _this.border.attr({
            fill: 'gold',
            'fill-opacity': 0.25,
            'stroke-opacity': 0.75,
            cursor: 'move'
          });
        });
        this.widgets.mouseout(function(e) {
          return _this.border.attr({
            'stroke-opacity': 0,
            cursor: 'default',
            fill: 'white',
            'fill-opacity': 0
          });
        });
        this.widgets.drag(this.drag, this.start, this.end);
      }
    }

    WMeasureLine.prototype.drag = function(dx, dy, x, y, e) {
      var tx, ty;

      tx = Math.floor(dx - this.dpo.x);
      ty = Math.floor(dy - this.dpo.y);
      this.x += tx;
      this.y += ty;
      this.widgets.transform("...t" + tx + "," + ty);
      this.dpo = {
        x: dx,
        y: dy
      };
      this._compute_geometry();
      this.ml.position.x = this.x;
      this.ml.position.y = this.y;
      return this.ml.glass.change_measure_line(this.ml.volume, (this.foot - this.y) / this.ml.glass.unit);
    };

    WMeasureLine.prototype.show = function() {
      return this.widgets.show();
    };

    WMeasureLine.prototype.hide = function() {
      return this.widgets.hide();
    };

    WMeasureLine.prototype.start = function() {
      var _ref;

      this.dpo = (_ref = this.dpo) != null ? _ref : {};
      this.dpo = {
        x: 0,
        y: 0
      };
      return this.border.attr({
        'fill': 'gold',
        'fill-opacity': 0.05
      });
    };

    WMeasureLine.prototype.end = function() {
      return this.border.attr({
        'fill': 'white',
        'fill-opacity': 0
      });
    };

    WMeasureLine.prototype._draw = function() {
      var BENDINESS, LABELSKIP, TICKWIDTH, bbox, label, labelleft, tick, tickpath, _ref, _ref1, _ref2, _ref3, _ref4;

      TICKWIDTH = (_ref = this.spec['thickwidth']) != null ? _ref : 10;
      LABELSKIP = (_ref1 = this.spec['labelskip']) != null ? _ref1 : 5;
      BENDINESS = 6;
      this.bend = (_ref2 = this.spec.bend) != null ? _ref2 : false;
      switch (this.ml.side) {
        case 'right':
          if (this.bend) {
            tickpath = "M" + this.ml.position.x + "," + this.ml.position.y + "c0," + 2 + ",-" + BENDINESS + "," + BENDINESS + ",-" + TICKWIDTH + "," + BENDINESS;
          } else {
            tickpath = "M" + this.ml.position.x + "," + this.ml.position.y + "h-" + TICKWIDTH;
          }
          tick = this.canvas.path(tickpath);
          label = this.canvas.text(0, 0, "" + this.ml.volume + " ml");
          label.attr({
            'font-family': (_ref3 = this.spec['font-family']) != null ? _ref3 : 'sans-serif',
            'font-size': (_ref4 = this.spec['font-size']) != null ? _ref4 : 12,
            'text-anchor': 'start'
          });
          bbox = label.getBBox();
          labelleft = this.ml.position.x - LABELSKIP - bbox.width - TICKWIDTH;
          if (this.bend) {
            label.attr({
              x: labelleft,
              y: this.ml.position.y + BENDINESS
            });
          } else {
            label.attr({
              x: labelleft,
              y: this.ml.position.y
            });
          }
          bbox = label.getBBox();
          this.border = this.canvas.rect(bbox.x, bbox.y, bbox.width + TICKWIDTH, bbox.height);
          this.border.attr({
            stroke: 'black',
            fill: 'white',
            'fill-opacity': 0,
            'stroke-opacity': 0,
            'stroke-dasharray': '. '
          });
          break;
        case 'left':
          tickpath = "M" + this.ml.position.x + "," + this.ml.position.y + "h" + TICKWIDTH;
      }
      this.widgets.push(tick, label, this.border);
      bbox = this.widgets.getBBox();
      this.width = bbox.width;
      return this.height = bbox.height;
    };

    return WMeasureLine;

  })(Widget);

  module.exports = WMeasureLine;

}).call(this);

/*
//@ sourceMappingURL=wmeasure_line.map
*/

},{"../widget":7,"./measure_line":8}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*
(c) 2012, Huub de Beer (H.T.de.Beer@gmail.com)
*/


(function() {
  var WRuler, Widget,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Widget = require('../widget');

  WRuler = (function(_super) {
    __extends(WRuler, _super);

    function WRuler(canvas, x, y, width, height, height_in_mm, spec) {
      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.height_in_mm = height_in_mm;
      this.spec = spec != null ? spec : {};
      WRuler.__super__.constructor.call(this, this.canvas, this.x, this.y, this.spec);
    }

    return WRuler;

  })(Widget);

  module.exports = WRuler;

}).call(this);

/*
//@ sourceMappingURL=wruler.map
*/

},{"../widget":7}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var ActionButton, Button,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Button = require('./button');

  ActionButton = (function(_super) {
    __extends(_Class, _super);

    function _Class(paper, button) {
      var _ref;

      this.paper = paper;
      this.activate = __bind(this.activate, this);
      _Class.__super__.constructor.call(this, this.paper, button);
      this.action = (_ref = button != null ? button.action : void 0) != null ? _ref : function() {};
      this.elements.click(this.activate);
    }

    _Class.prototype.activate = function() {
      return this.action();
    };

    _Class.prototype.disable = function() {
      this.back.attr(this.prop.disabled);
      return this.elements.unclick(this.activate);
    };

    _Class.prototype.enable = function() {
      this.back.attr(this.prop.normal);
      return this.elements.click(this.activate);
    };

    return _Class;

  })(Button);

  module.exports = ActionButton;

}).call(this);

/*
//@ sourceMappingURL=action_button.map
*/

},{"./button":12}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Button, SwitchButton,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Button = require('./button');

  SwitchButton = (function(_super) {
    __extends(_Class, _super);

    function _Class(paper, button) {
      var _ref, _ref1, _ref2;

      this.paper = paper;
      this["switch"] = __bind(this["switch"], this);
      _Class.__super__.constructor.call(this, this.paper, button);
      this.switched_on = (_ref = button != null ? button.switched_on : void 0) != null ? _ref : false;
      this.on_switch_on = (_ref1 = button != null ? button.on_switch_on : void 0) != null ? _ref1 : function() {};
      this.on_switch_off = (_ref2 = button != null ? button.on_switch_off : void 0) != null ? _ref2 : function() {};
      if (this.switched_on) {
        this.back.attr(this.prop.switched_on);
        this.on_switch_on();
      } else {
        this.on_switch_off();
      }
      this.elements.click(this["switch"]);
    }

    _Class.prototype["switch"] = function() {
      if (this.switched_on) {
        this.switched_on = false;
        this.back.attr(this.prop.normal);
        return this.on_switch_off();
      } else {
        this.switched_on = true;
        this.back.attr(this.prop.switched_on);
        return this.on_switch_on();
      }
    };

    _Class.prototype.disable = function() {
      this.back.attr(this.prop.disabled);
      return this.elements.unclick(this["switch"]);
    };

    _Class.prototype.enable = function() {
      this.back.attr(this.prop.normal);
      return this.elements.click(this["switch"]);
    };

    return _Class;

  })(Button);

  module.exports = SwitchButton;

}).call(this);

/*
//@ sourceMappingURL=switch_button.map
*/

},{"./button":12}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var ButtonGroup, OptionButton;

  OptionButton = require('./option_button');

  ButtonGroup = (function() {
    function _Class(paper, buttonlist) {
      var button, _i, _len;

      this.paper = paper;
      this.buttons = [];
      this.value = "";
      for (_i = 0, _len = buttonlist.length; _i < _len; _i++) {
        button = buttonlist[_i];
        this.buttons.push(new OptionButton(this.paper, button, this));
      }
    }

    _Class.prototype.disable = function() {
      var button, _i, _len, _ref, _results;

      _ref = this.buttons;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        button = _ref[_i];
        _results.push(button.disable());
      }
      return _results;
    };

    _Class.prototype.enable = function() {
      var button, _i, _len, _ref, _results;

      _ref = this.buttons;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        button = _ref[_i];
        _results.push(button.enable());
      }
      return _results;
    };

    _Class.prototype.select = function(button) {
      var i, _i, _len, _ref, _results;

      _ref = this.buttons;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (i.value === button) {
          _results.push(i.select());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    _Class.prototype.deselect = function(button) {
      var i, _i, _len, _ref, _results;

      _ref = this.buttons;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (i.value === button) {
          _results.push(i.deselect());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return _Class;

  })();

  module.exports = ButtonGroup;

}).call(this);

/*
//@ sourceMappingURL=button_group.map
*/

},{"./option_button":16}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Button, OptionButton,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Button = require('./button');

  OptionButton = (function(_super) {
    __extends(_Class, _super);

    function _Class(paper, button, group) {
      var _ref, _ref1;

      this.paper = paper;
      this.group = group;
      this.select = __bind(this.select, this);
      _Class.__super__.constructor.call(this, this.paper, button);
      this.value = (_ref = button.value) != null ? _ref : "no value given";
      this.on_select = (_ref1 = button != null ? button.on_select : void 0) != null ? _ref1 : function() {
        return "";
      };
      if (button.chosen) {
        this.back.attr(this.prop.activated);
        this.group.value = this.value;
      }
      this.elements.click(this.select);
    }

    _Class.prototype.select = function() {
      var button, _i, _len, _ref;

      _ref = this.group.buttons;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        button = _ref[_i];
        button.deselect();
      }
      this.back.attr(this.prop.activated);
      this.group.value = this.value;
      return this.on_select();
    };

    _Class.prototype.deselect = function() {
      return this.back.attr(this.prop.normal);
    };

    _Class.prototype.disable = function() {
      this.back.attr(this.prop.disabled);
      return this.elements.unclick(this.select);
    };

    _Class.prototype.enable = function() {
      this.back.attr(this.prop.normal);
      return this.elements.click(this.select);
    };

    return _Class;

  })(Button);

  module.exports = OptionButton;

}).call(this);

/*
//@ sourceMappingURL=option_button.map
*/

},{"./button":12}]},{},[1])
;