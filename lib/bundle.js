;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Glass, WGlass, canvas, cocktail_glass, cocktail_json, cocktail_representation, export_string, w;

  console.log("test");

  cocktail_json = '{"path":"M 419 102 l -152 245 l 0 185 c 0 23.25 101 11.75 106 25","foot":{"x":255,"y":557},"stem":{"x":255,"y":532},"bowl":{"x":255,"y":347},"edge":{"x":255,"y":102},"height_in_mm":150,"spec":{"round_max":"cl","mm_from_top":0},"measure_lines":{},"nr_of_measure_lines":0}';

  canvas = Raphael('test', 500, 500);

  console.log("in");

  Glass = require('./widgets/glass/glass');

  WGlass = require('./widgets/glass/wglass');

  cocktail_glass = new Glass(cocktail_json);

  export_string = cocktail_glass.to_full_json();

  w = window.open('');

  w.document.open('text/plain');

  w.document.write(export_string);

  cocktail_representation = new WGlass(canvas, 1, 1, cocktail_glass);

}).call(this);

/*
//@ sourceMappingURL=test.map
*/

},{"./widgets/glass/glass":2,"./widgets/glass/wglass":3}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
glass.coffee version 0.1

Modeling different glasses

(c) 2012 Huub de Beer H.T.de.Beer@gmail.com

Long description
*/


(function() {
  var Glass;

  Glass = (function() {
    Glass.TENTH_OF_MM = 10;

    Glass.prototype.to_json = function() {
      var export_object;
      export_object = {
        path: this.path,
        foot: {
          x: this.foot.x,
          y: this.foot.y
        },
        stem: {
          x: this.stem.x,
          y: this.stem.y
        },
        bowl: {
          x: this.bowl.x,
          y: this.bowl.y
        },
        edge: {
          x: this.edge.x,
          y: this.edge.y
        },
        height_in_mm: this.height_in_mm,
        spec: this.spec
      };
      return JSON.stringify(export_object, null, '  ');
    };

    Glass.prototype.to_full_json = function() {
      var export_object;
      export_object = {
        path: this.path,
        foot: {
          x: this.foot.x,
          y: this.foot.y
        },
        stem: {
          x: this.stem.x,
          y: this.stem.y
        },
        bowl: {
          x: this.bowl.x,
          y: this.bowl.y
        },
        bowl_start: this.bowl_start,
        edge: {
          x: this.edge.x,
          y: this.edge.y
        },
        height_in_mm: this.height_in_mm,
        unit: this.unit,
        spec: this.spec,
        vol: this.vol,
        r: this.r,
        speed: this.speed,
        maximum_height: this.maximum_height,
        maximum_volume: this.maximum_volume,
        maximum_speed: this.maximum_speed
      };
      return JSON.stringify(export_object, null, '  ');
    };

    function Glass(path, foot, stem, bowl, edge, height_in_mm, spec) {
      var import_object, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      if (spec == null) {
        spec = {
          round_max: "cl",
          mm_from_top: 5
        };
      }
      /*
      pre:
          path is the right hand side of the countour of the glass
        ∧ 0 ≤ foot.y 
        ∧ foot.y ≤ stem.y 
        ∧ stem.y ≤ bowl.y
        ∧ bowl.y < edge.y
        ∧ 0 < height_in_mm
      
      post:
          is_empty
      */

      if (arguments.length === 1) {
        import_object = JSON.parse(path);
        this.path = import_object.path;
        this.foot = import_object.foot;
        this.stem = import_object.stem;
        this.bowl = import_object.bowl;
        this.edge = import_object.edge;
        this.height_in_mm = import_object.height_in_mm;
        this.spec = (_ref = import_object != null ? import_object.spec : void 0) != null ? _ref : {
          round_max: "cl",
          mm_from_top: 5
        };
        this.unit = (_ref1 = import_object != null ? import_object.unit : void 0) != null ? _ref1 : Math.abs(this.edge.y - this.foot.y) / this.height_in_mm;
        this.bowl_start = (_ref2 = import_object != null ? import_object.bowl_start : void 0) != null ? _ref2 : this.height_in_mm - (Math.abs(this.bowl.y - this.edge.y) / this.unit);
        this.r = (_ref3 = import_object != null ? import_object.r : void 0) != null ? _ref3 : [];
        if (!(import_object != null ? import_object.r : void 0)) {
          this.r = this._compute_r(this.path, this.foot, this.height_in_mm, this.unit);
        }
        console.log(this.r);
        this.vol = (_ref4 = import_object != null ? import_object.vol : void 0) != null ? _ref4 : [];
        this.speed = (_ref5 = import_object != null ? import_object.speed : void 0) != null ? _ref5 : [];
        this.maximum_volume = (_ref6 = import_object != null ? import_object.maximum_volume : void 0) != null ? _ref6 : 0;
        this.maximum_height = (_ref7 = import_object != null ? import_object.maximum_height : void 0) != null ? _ref7 : 0;
        this.maximum_speed = (_ref8 = import_object != null ? import_object.maximum_speed : void 0) != null ? _ref8 : 0;
        if (this.maximum_volume === 0 || this.maximum_height === 0 || this.maximum_speed === 0) {
          this._determine_maximum(this.height_in_mm - this.spec.mm_from_top, this.spec.round_max);
        }
      } else {
        this.path = path;
        this.foot = foot;
        this.stem = stem;
        this.bowl = bowl;
        this.edge = edge;
        this.height_in_mm = height_in_mm;
        this.spec = spec;
        this.unit = Math.abs(this.edge.y - this.foot.y) / this.height_in_mm;
        this.bowl_start = this.height_in_mm - (Math.abs(this.bowl.y - this.edge.y) / this.unit);
        this.r = [];
        this.r = this._compute_r(this.path, this.foot, this.height_in_mm, this.unit);
        this.vol = [];
        this.speed = [];
        this.maximum_volume = 0;
        this.maximum_height = 0;
        this.maximum_speed = 0;
        this._determine_maximum(this.height_in_mm - this.spec.mm_from_top, this.spec.round_max);
      }
      this.make_empty();
    }

    Glass.prototype.compute_speed = function() {
      var dh, dvol, h, h_max, v_prev, vol, _results;
      h = 0;
      h_max = this.vol.length - 1;
      while (this.vol[h] === 0) {
        h++;
      }
      this.speed[0] = 0;
      v_prev = 0;
      this.maximum_speed = 0;
      _results = [];
      while (h <= h_max) {
        vol = this.vol[h];
        dh = 0;
        while (h <= h_max && v_prev === vol) {
          h++;
          dh += 0.01;
          vol = this.vol[h];
        }
        dvol = vol - v_prev;
        this.speed[vol] = dh / dvol;
        this.maximum_speed = Math.max(this.maximum_speed, this.speed[vol]);
        v_prev = vol;
        _results.push(h++);
      }
      return _results;
    };

    Glass.prototype.make_empty = function(initial_value) {
      if (initial_value == null) {
        initial_value = 0;
      }
      /*
      Empty this glass 
      
      pre:
          True
      
      post:
          current_height = 0
        ∧ current_volume = 0
      */

      this.current_volume = 0;
      this.current_height = 0;
      this.current_height = this.fill_to_volume(initial_value);
      this.current_height++;
      return this.current_graph = "M0,0";
    };

    Glass.prototype.is_empty = function() {
      /*
      Is this glass empty?
      
      pre:
          True
      
      post:
          True
      
      return:
          current_volume = 0
      */

      return this.current_volume === 0;
    };

    Glass.prototype.is_full = function() {
      /*
      Is this glass full?
      
      pre:
          True
      
      post:
          True
      
      return:
          current_volume = maximum_volume
      */

      return this.current_volume === this.maximum_volume;
    };

    Glass.prototype.fill_to_height = function(height) {
      /*
      Fill this glass up to height and return corresponding volume
      
      pre: 
          height, 0 ≤ height ≤ maximum_height
      
      post:
          current_height = height
        ∧ current_volume = volume_at_height(height)
      
      return:
          volume_at_height(height)
      */

      if (height <= this.maximum_height) {
        this.current_height = height;
      } else {
        this.current_height = this.maximum_height;
      }
      this.current_volume = this.volume_at_height(this.current_height);
      return this.current_volume;
    };

    Glass.prototype.fill_to_volume = function(volume) {
      /*
      Fill this glass up to volume and return the corresponding water level height.
      
      pre:
          volume, 0 ≤ volume ≤ maximum_volume
      
      post:
          current_volume = volume
        ∧ current_height = height_at_volume(volume)
      
      return:
          height_at_volume(volume)
      */

      if (volume <= this.maximum_volume) {
        this.current_volume = volume;
      } else {
        this.current_volume = this.maximum_volume;
      }
      this.current_height = this.height_at_volume(this.current_volume);
      return this.current_height;
    };

    Glass.prototype.speed_at_height = function(height) {
      return this.speed[height * Glass.TENTH_OF_MM];
    };

    Glass.prototype.speed_at_volume = function(vol) {
      var h;
      h = height_at_volume(vol);
      return this.speed[h * Glass.TENTH_OF_MM];
    };

    Glass.prototype.volume_at_height = function(height) {
      /*
      Compute the volume of the water in this glass when it is filled up to
      height. Take in account the shape of the glass: only the bowl of the
      glass can be filled.
      
      pre:
          height: water level height in mm
      
      post:
          volume = (∫h: 0 ≤ h ≤ height: πr(h)^2)
      
      return:
          volume in ml
      */

      var HSTEP, dvol, h;
      HSTEP = 0.01;
      h = Math.ceil(height * Glass.TENTH_OF_MM);
      if (this.vol[h] == null) {
        if (h === 0) {
          this.vol[0] = 0;
          this.speed[0] = 0;
        } else {
          if ((0 <= height && height < this.bowl_start)) {
            this.vol[h] = 0 + this.volume_at_height((h - 1) / Glass.TENTH_OF_MM);
            this.speed[h] = 0;
          } else {
            dvol = Math.PI * Math.pow(this.r[h] / Glass.TENTH_OF_MM, 2) * HSTEP;
            this.vol[h] = dvol + this.volume_at_height((h - 1) / Glass.TENTH_OF_MM);
            this.speed[h] = dvol !== 0 ? HSTEP / dvol : 0;
            this.maximum_speed = Math.max(this.maximum_speed, this.speed[h]);
          }
        }
      }
      return this.vol[h];
    };

    Glass.prototype.height_at_volume = function(volume) {
      /*
      Compute the height of the water level in this glass when there is volume water in it.
      
      pre:
          0 ≤ volume 
      
      post:
          height = (h: 0 ≤ h ≤ total_height: vol[h + 1] > volume ∧ vol[h-1] < volume)
      
      return:
          height in mm
      */

      var height, maxheight;
      height = this.current_height * Glass.TENTH_OF_MM;
      maxheight = this.height_in_mm * Glass.TENTH_OF_MM;
      while (!(this.vol[height] > volume || height >= maxheight)) {
        height++;
      }
      return Math.floor(height / Glass.TENTH_OF_MM);
    };

    Glass.prototype.get_current_graph = function() {
      return this.current_graph = this.graph[Math.ceil(this.current_height * Glass.TENTH_OF_MM)];
    };

    Glass.prototype.create_graph = function(paper, graph, line, x_axis, speed) {
      var EPSILON, add_time, dspeed, dtime, dvol, h, p, path, ptmm, speed_before, speed_step, vollast, x, y;
      if (speed == null) {
        speed = false;
      }
      EPSILON = 0.01;
      switch (x_axis) {
        case 'vol':
          if (speed) {
            ptmm = 1 / 100 / line.y_unit.per_pixel;
            dvol = 0;
            this.graph = [];
            path = "M0,0";
            h = 0;
            while (this.vol[h] === 0) {
              this.graph.push(path);
              h++;
            }
            x = line.min.x;
            y = line.max.y - (this.speed[h] / line.y_unit.per_pixel);
            path = "M" + x + "," + y;
            vollast = 0;
            this.graph.push(path);
            speed_before = this.speed[h];
            while (h < this.vol.length && this.vol[h] < this.maximum_volume) {
              dvol = this.vol[h] - vollast;
              vollast = this.vol[h];
              dspeed = speed_before !== 0 ? this.speed[h] - speed_before : 0;
              speed_before = this.speed[h];
              speed_step = dspeed / line.y_unit.per_pixel * (-1);
              path += "l" + (dvol / line.x_unit.per_pixel) + "," + speed_step;
              this.graph.push(path);
              h++;
            }
            graph.attr({
              path: path
            });
            line.add_point(x, y, graph);
            p = line.find_point_at(x);
            return line.add_freehand_line(p, path);
          } else {
            ptmm = 1 / 100 / line.y_unit.per_pixel;
            dvol = 0;
            this.graph = [];
            path = "M0,0";
            h = 0;
            while (this.vol[h] === 0) {
              this.graph.push(path);
              h++;
            }
            x = line.min.x;
            y = line.max.y - (h / 100 / line.y_unit.per_pixel);
            path = "M" + x + "," + y;
            vollast = 0;
            this.graph.push(path);
            while (h < this.vol.length && this.vol[h] < this.maximum_volume) {
              dvol = this.vol[h] - vollast;
              vollast = this.vol[h];
              path += "l" + (dvol / line.x_unit.per_pixel) + ",-" + ptmm;
              this.graph.push(path);
              h++;
            }
            graph.attr({
              path: path
            });
            line.add_point(x, y, graph);
            p = line.find_point_at(x);
            return line.add_freehand_line(p, path);
          }
          break;
        case 'time':
          ptmm = 1 / 100 / line.y_unit.per_pixel;
          dtime = 0;
          this.graph = [];
          path = "M0,0";
          h = 0;
          while (this.vol[h] === 0) {
            this.graph.push(path);
            h++;
          }
          x = line.min.x;
          y = line.max.y - (h / 100 / line.y_unit.per_pixel);
          path = "M" + x + "," + y;
          vollast = 0;
          add_time = 0;
          this.graph.push(path);
          while (h < this.vol.length && this.vol[h] < this.maximum_volume) {
            dvol = this.vol[h] - vollast;
            vollast = this.vol[h];
            add_time = dvol / speed;
            path += "l" + (add_time / line.x_unit.per_pixel) + ",-" + ptmm;
            this.graph.push(path);
            h++;
          }
          graph.attr({
            path: path
          });
          line.add_point(x, y, graph);
          p = line.find_point_at(x);
          return line.add_freehand_line(p, path);
      }
    };

    Glass.prototype._compute_r = function(path, foot, total_height, unit) {
      /*
      Given a path and the coordinate of the foot on the mid-line of the
      glass, compute the radius of the glass at every height.
      
      pre:
          path: SVG path of contour of the right side of the glass
        ∧ foot: point of the foot or bottom of the glass on the mid line
      
      post:
          (∀ h: 0 ≤ h ≤ total_height: r[h] = radius of glass at height h in mm/10 in mm) 
      
      return:
          r
      */

      var height, length_on_path, point_on_length, r, _i, _ref;
      r = [];
      length_on_path = 0;
      for (height = _i = _ref = total_height * Glass.TENTH_OF_MM; _ref <= 0 ? _i <= 0 : _i >= 0; height = _ref <= 0 ? ++_i : --_i) {
        point_on_length = Raphael.getPointAtLength(path, length_on_path);
        while (Math.abs(foot.y - point_on_length.y) > height * unit / Glass.TENTH_OF_MM) {
          length_on_path++;
          point_on_length = Raphael.getPointAtLength(path, length_on_path);
        }
        r[height] = Math.abs(point_on_length.x - foot.x) / unit;
      }
      return r;
    };

    Glass.prototype._determine_maximum = function(total_height, round_to) {
      var factor, total_volume;
      if (round_to == null) {
        round_to = "cl";
      }
      /*
      Determine the maximum volume and corresponding maximum height of this 
      glass. Round to the first ml, cl, dl, or l below total_height.
      
      pre:
          0 ≤ total_height
        ∧ round_to ∈ {ml, cl, dl, l}
      
      post:
          0 ≤ maximum_height < total_height
        ∧ maximum_volume = volume_at_height(maximum_height)
        ∧ height_at_volume(maximum_volume + 1 round_to) >= total_height
      */

      total_volume = this.volume_at_height(total_height);
      factor = 10;
      switch (round_to) {
        case "ml":
          factor = 1;
          break;
        case "cl":
          factor = 10;
          break;
        case "dl":
          factor = 100;
          break;
        case "l":
          factor = 1000;
      }
      this.maximum_volume = Math.floor(total_volume / factor) * factor;
      this.current_height = 0;
      return this.maximum_height = this.height_at_volume(this.maximum_volume);
    };

    return Glass;

  })();

  module.exports = Glass;

}).call(this);

/*
//@ sourceMappingURL=glass.map
*/

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
*/


(function() {
  var Glass, MeasureLine, WGlass, WMeasureLine, Widget,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Widget = require('../widget');

  Glass = require('./glass');

  MeasureLine = require('./measure_line');

  WMeasureLine = require('./wmeasure_line');

  WGlass = (function(_super) {
    __extends(WGlass, _super);

    function WGlass(canvas, x, y, glass, spec) {
      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.glass = glass;
      this.spec = spec != null ? spec : {};
      this.stop_manual_diff = __bind(this.stop_manual_diff, this);
      this.hide_longdrink = __bind(this.hide_longdrink, this);
      this.show_longdrink = __bind(this.show_longdrink, this);
      this.start_manual_diff = __bind(this.start_manual_diff, this);
      WGlass.__super__.constructor.call(this, this.canvas, this.x, this.y, this.spec);
      this.points = this._compute_points(this.glass);
      this.lengths = this._compute_lengths_at_heigth();
      this._draw();
      this.place_at(this.x, this.y);
      this.move_handler = null;
      this.graph = null;
    }

    WGlass.prototype.start_manual_diff = function() {
      this.glasspane.mouseover(this.show_longdrink);
      return this.glasspane.mouseout(this.hide_longdrink);
    };

    WGlass.prototype.show_longdrink = function() {
      var _ref;
      this.longdrink.show();
      this.lml.show();
      this.lbl.show();
      this.ll.show();
      this.lf.show();
      this.llp.show();
      this.lrp.show();
      this.move_handler = (_ref = this.move_handler) != null ? _ref : this.move_longdrink(this);
      return this.glasspane.mousemove(this.move_handler);
    };

    WGlass.prototype.hide_longdrink = function() {
      this.longdrink.hide();
      this.lml.hide();
      this.lbl.hide();
      this.ll.hide();
      this.lf.hide();
      this.llp.hide();
      this.lrp.hide();
      this.lgl.hide();
      return this.gp.hide();
    };

    WGlass.prototype.fit_point = function(x, y) {
      var point;
      point = {
        x: x - this.canvas.canvas.parentNode.offsetLeft,
        y: y - this.canvas.canvas.parentNode.offsetTop
      };
      return point;
    };

    WGlass.prototype.set_graph = function(graph) {
      return this.graph = graph;
    };

    WGlass.prototype.del_graph = function() {
      return this.graph = null;
    };

    WGlass.prototype.move_longdrink = function(glassrep) {
      var _this = this;
      return function(e, x, y) {
        var BELOW, OVER_GRAPH_LENGTH, compute_vol, gheight, gpx, gpy, gvol, h, halfvol, halfvolpx, hi, left, length, lglpath, line, p, path, ph, py, r, right, rmm, vol;
        p = glassrep.fit_point(x, y);
        py = p.y - _this.dy;
        ph = glassrep.points.foot.right.y - py;
        h = Math.ceil((ph / glassrep.glass.unit) * Glass.TENTH_OF_MM);
        length = glassrep.lengths[h];
        right = Raphael.getPointAtLength(glassrep.glass.path, length);
        left = right.x - 2 * (right.x - glassrep.glass.edge.x);
        r = (right.x - left) / 2;
        rmm = r / glassrep.glass.unit;
        hi = Math.floor(20 * glassrep.glass.unit);
        compute_vol = function(rmm, h) {
          var hmm;
          hmm = h / glassrep.glass.unit;
          return Math.floor(Math.PI * Math.pow(rmm, 2) * hmm / 1000);
        };
        while ((compute_vol(rmm, hi) % 2) !== 0 && (compute_vol(rmm, hi) % 10) !== 5) {
          hi++;
        }
        vol = compute_vol(rmm, hi);
        BELOW = 10 * glassrep.glass.unit;
        if (_this.spec.diff_graph && _this.graph) {
          OVER_GRAPH_LENGTH = 1000;
          gheight = Math.ceil(ph / glassrep.glass.unit);
          gvol = _this.glass.volume_at_height(gheight);
          line = _this.graph.computer_line;
          gpx = line.min.x + gvol / line.x_unit.per_pixel;
          gpy = line.max.y - (gheight / 10) / line.y_unit.per_pixel;
          halfvol = vol / 2;
          halfvolpx = halfvol / line.x_unit.per_pixel;
          lglpath = "M" + gpx + "," + gpy + "l" + halfvolpx + "," + (-hi + BELOW) + "M" + gpx + "," + gpy + "l-" + halfvolpx + "," + BELOW;
          _this.lgl.attr({
            path: lglpath
          });
          _this.lgl.show().toFront();
          _this.gp.attr({
            cx: gpx,
            cy: gpy
          });
          _this.gp.show().toFront();
        } else {
          _this.lgl.hide();
          _this.gp.hide();
          OVER_GRAPH_LENGTH = 0;
        }
        _this.lf.attr({
          x: left + _this.dx,
          y: right.y + _this.dy,
          width: right.x - left,
          height: BELOW
        });
        path = "M" + right.x + "," + (right.y - hi + BELOW) + "H" + (-_this.dx + 10);
        path += "M" + right.x + "," + (right.y - hi + BELOW) + "h" + OVER_GRAPH_LENGTH;
        _this.lml.attr({
          path: path,
          transform: "t" + _this.dx + "," + _this.dy
        });
        _this.lml.toFront();
        path = "M" + right.x + "," + (right.y + BELOW) + "H" + (-_this.dx + 10);
        path += "M" + right.x + "," + (right.y + BELOW) + "h" + OVER_GRAPH_LENGTH;
        _this.lbl.attr({
          path: path,
          transform: "t" + _this.dx + "," + _this.dy
        });
        _this.lbl.toFront();
        path = "M" + right.x + "," + (right.y + BELOW) + "v-" + (hi + 10) + "M" + right.x + "," + (right.y + BELOW) + "L" + left + "," + (right.y + BELOW) + "v-" + (hi + 10);
        _this.longdrink.attr({
          path: path,
          transform: "t" + _this.dx + "," + _this.dy
        });
        _this.llp.attr({
          cx: left + _this.dx,
          cy: right.y + _this.dy
        });
        _this.lrp.attr({
          cx: right.x + _this.dx,
          cy: right.y + _this.dy
        });
        return _this.ll.attr({
          text: "" + vol + " ml",
          transform: "t" + (left + _this.dx + 10) + "," + (right.y - hi + _this.dy - 10 + BELOW)
        });
      };
    };

    WGlass.prototype.stop_manual_diff = function() {
      this.longdrink.hide();
      this.lgl.hide();
      this.gp.hide();
      this.glasspane.unmousemove(this.move_handler);
      this.glasspane.unmouseover(this.show_longdrink);
      return this.glasspane.unmouseout(this.hide_longdrink);
    };

    WGlass.prototype.fill_to_height = function(height_in_mm) {
      /*
      Update the fill-part to correspond to a water level equal to the height_in_mm.
      */

      var diameter, height, left, length, right;
      diameter = function(length, glass) {
        return Math.abs(Raphael.getPointAtLength(glass.path, length).x - glass.foot.x) * 2;
      };
      height = this.glass.foot.y - (height_in_mm * this.glass.unit);
      if (height < this.glass.bowl.y) {
        this.points.water_level = {};
        this.points.water_level.length = length = this.lengths[height_in_mm * Glass.TENTH_OF_MM];
        this.points.water_level.right = right = Raphael.getPointAtLength(this.glass.path, length);
        this.points.water_level.left = {
          x: right.x - diameter(length, this.glass),
          y: right.y
        };
        right = Raphael.path2curve(Raphael.getSubpath(this.glass.path, this.points.water_level.length, this.points.bowl.length));
        left = this._mirror_path_vertically(right, this.glass.bowl.x);
        return this.water_level.attr({
          path: right + ("H" + this.points.bowl.left.x) + left
        });
      }
    };

    WGlass.prototype._draw = function() {
      var base, bowl, max_ml_representation, max_x, max_y, maxpoint;
      this.paths = this._create_paths();
      base = this.canvas.path(this.paths.base);
      base.attr({
        fill: '#aaa',
        stroke: 'black',
        'stroke-width': 2
      });
      this.widgets.push(base);
      this.water_level = this.canvas.path("M0,0");
      this.water_level.attr({
        fill: '#abf',
        'fill-opacity': 0.4,
        stroke: 'none'
      });
      this.widgets.push(this.water_level);
      bowl = this.canvas.path(this.paths.bowl);
      bowl.attr({
        stroke: 'black',
        'stroke-width': 2
      });
      this.widgets.push(bowl);
      maxpoint = Raphael.getPointAtLength(this.glass.path, this.lengths[this.glass.maximum_height * Glass.TENTH_OF_MM]);
      max_x = maxpoint.x;
      max_y = maxpoint.y;
      this.max_ml = new MeasureLine(this.glass.maximum_volume, this.glass.maximum_height, this.glass, {
        x: max_x,
        y: max_y
      }, 'right', true, false);
      max_ml_representation = new WMeasureLine(this.canvas, max_x, max_y, this.max_ml);
      this.widgets.push(max_ml_representation.widgets);
      this.lf = this.canvas.rect(0, 0, 0, 0);
      this.lf.attr({
        fill: 'orange',
        'fill-opacity': 0.5,
        'stroke': 'none'
      });
      this.lf.hide();
      this.lml = this.canvas.path("M0,0");
      this.lml.attr({
        stroke: 'orange',
        'stroke-opacity': 0.5,
        'stroke-dasharray': '-'
      });
      this.lml.hide();
      this.lbl = this.canvas.path("M0,0");
      this.lbl.attr({
        stroke: 'orange',
        'stroke-opacity': 0.5,
        'stroke-dasharray': '-'
      });
      this.lbl.hide();
      this.longdrink = this.canvas.path("M0,0");
      this.longdrink.attr({
        stroke: 'orange',
        'stroke-width': 3,
        'stroke-opacity': 0.9
      });
      this.longdrink.hide();
      this.lgl = this.canvas.path("M0,0");
      this.lgl.attr({
        stroke: 'orange',
        'stroke-width': 3,
        'stroke-opacity': 0.9
      });
      this.lgl.hide();
      this.gp = this.canvas.circle(0, 0, 2);
      this.gp.attr({
        fill: 'gray'
      });
      this.gp.hide();
      this.ll = this.canvas.text(0, 0, "250 ml");
      this.ll.attr({
        'font-family': 'sans-serif',
        'font-size': '12pt',
        'text-anchor': 'start',
        fill: 'gray'
      });
      this.ll.hide();
      this.llp = this.canvas.circle(0, 0, 2);
      this.llp.attr({
        fill: 'gray'
      });
      this.llp.hide();
      this.lrp = this.canvas.circle(0, 0, 2);
      this.lrp.attr({
        fill: 'gray'
      });
      this.lrp.hide();
      this.glasspane = this.canvas.path(this.paths.bowl);
      this.glasspane.attr({
        fill: 'white',
        'fill-opacity': 0,
        'stroke-width': 5,
        'stroke-opacity': 0
      });
      return this.widgets.push(this.glasspane);
    };

    WGlass.prototype._create_paths = function() {
      /*
      Create the path of the part of this glass
      */

      var left, paths, right;
      paths = {};
      right = Raphael.path2curve(Raphael.getSubpath(this.glass.path, this.points.bowl.length, this.points.foot.length));
      left = this._mirror_path_vertically(right, this.glass.foot.x);
      paths.base = right + ("H" + this.points.foot.left.x) + left;
      right = Raphael.path2curve(Raphael.getSubpath(this.glass.path, this.points.edge.length, this.points.bowl.length));
      left = this._mirror_path_vertically(right, this.glass.foot.x);
      paths.bowl = right + ("H" + this.points.bowl.left.x) + left;
      return paths;
    };

    WGlass.prototype._compute_geometry = function() {
      var base, bowl;
      base = Raphael.pathBBox(this.paths.base);
      bowl = Raphael.pathBBox(this.paths.bowl);
      this.geometry = {};
      this.geometry.top = bowl.y;
      this.geometry.left = Math.min(base.x, bowl.x);
      this.geometry.bottom = base.y2;
      this.geometry.right = Math.max(base.x2, bowl.b2);
      this.geometry.width = Math.max(base.width, bowl.width);
      this.geometry.height = base.height + bowl.height;
      return this.geometry.center = {
        x: (this.geometry.right - this.geometry.left) / 2 + this.geometry.left,
        y: (this.geometry.bottom - this.geometry.top) / 2 + this.geometry.top
      };
    };

    WGlass.prototype._compute_points = function(glass) {
      /*
      Compute points, lengths, and paths between points for the edge, foot, stem, and bowl
      */

      var diameter, length, line, points, right, _i, _len, _ref;
      diameter = function(length) {
        return Math.abs(Raphael.getPointAtLength(glass.path, length).x - glass.foot.x) * 2;
      };
      points = {};
      length = 0;
      _ref = ['edge', 'bowl', 'stem', 'foot'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        points[line] = {};
        points[line].length = length = this._length_at_y(glass.path, glass[line].y, length);
        points[line].right = right = Raphael.getPointAtLength(glass.path, length);
        points[line].left = {
          x: right.x - diameter(length),
          y: right.y
        };
      }
      return points;
    };

    WGlass.prototype._compute_lengths_at_heigth = function() {
      var height, height_in_pixels, length, lengths, max_length;
      lengths = [];
      length = 0;
      max_length = Raphael.getTotalLength(this.glass.path);
      height = this.glass.height_in_mm * Glass.TENTH_OF_MM;
      while (height > 0) {
        height_in_pixels = this.glass.foot.y - ((height * this.glass.unit) / Glass.TENTH_OF_MM);
        while (length < max_length && Raphael.getPointAtLength(this.glass.path, length).y < height_in_pixels) {
          length++;
        }
        lengths[height] = length;
        height--;
      }
      lengths[0] = this.points.foot.length;
      return lengths;
    };

    WGlass.prototype._length_at_y = function(path, y, start) {
      var length, max_length;
      if (start == null) {
        start = 0;
      }
      /*
        Find the length on the path the path hat intersects the horizontal line at y
      */

      length = start;
      max_length = Raphael.getTotalLength(path);
      while (length < max_length && Raphael.getPointAtLength(path, length).y < y) {
        length++;
      }
      return length;
    };

    WGlass.prototype._mirror_path_vertically = function(path, x_line) {
      /*
      */

      var cp1x, cp1y, cp2x, cp2y, cpath, cpathsegs, mirror, mirror_x, mirrorlist, segment, x, y, _i, _len, _ref, _ref1, _ref2, _ref3;
      mirror_x = function(x) {
        return x_line - Math.abs(x_line - x);
      };
      cpath = Raphael.path2curve(path);
      cpathsegs = Raphael.parsePathString(cpath);
      mirror = "";
      mirrorlist = [];
      _ref = cpathsegs[0].slice(1, 3), x = _ref[0], y = _ref[1];
      _ref1 = cpathsegs.slice(1, +cpathsegs.length + 1 || 9e9);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        segment = _ref1[_i];
        _ref2 = segment.slice(1, 5), cp1x = _ref2[0], cp1y = _ref2[1], cp2x = _ref2[2], cp2y = _ref2[3];
        mirrorlist.push([mirror_x(cp2x), cp2y, mirror_x(cp1x), cp1y, mirror_x(x), y]);
        _ref3 = segment.slice(5, 7), x = _ref3[0], y = _ref3[1];
      }
      mirror = ((function() {
        var _j, _len1, _ref4, _results;
        _ref4 = mirrorlist.reverse();
        _results = [];
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          segment = _ref4[_j];
          _results.push('C' + segment.join(","));
        }
        return _results;
      })()).join("");
      return mirror;
    };

    return WGlass;

  })(Widget);

  module.exports = WGlass;

}).call(this);

/*
//@ sourceMappingURL=wglass.map
*/

},{"../widget":4,"./glass":2,"./measure_line":5,"./wmeasure_line":6}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*

(c) 2012, Huub de Beer, H.T.de.Beer@gmail.com
*/


(function() {
  var Widget;

  Widget = (function() {
    function Widget(canvas, x, y, spec) {
      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.spec = spec != null ? spec : {};
      this.widgets = this.canvas.set();
      this.dx = this.dy = 0;
    }

    Widget.prototype.place_at = function(x, y) {
      /*
      Place this widget at co-ordinates x an y
      */

      this._compute_geometry();
      this.dx = x - this.geometry.left;
      this.dy = y - this.geometry.top;
      this.widgets.transform("...t" + this.dx + "," + this.dy);
      this.x = x;
      this.y = y;
      this._compute_geometry();
      return this;
    };

    Widget.prototype._draw = function() {
      /*
      Draw this widget. Virtual method to be overloaded by all subclasses of 
      Widget. All shapes drawn are added to the list of widgets
      */

    };

    Widget.prototype._compute_geometry = function() {
      /*
      Compute the left, top, bottom, right, width, height, and center of this 
      widget given its top-left corner (x, y). 
      
      This does not work with paths that do not start at (0,0)
      */

      var bbox;
      bbox = this.widgets.getBBox();
      this.geometry = {};
      this.geometry.width = bbox.width;
      this.geometry.height = bbox.height;
      this.geometry.top = bbox.y;
      this.geometry.left = bbox.x;
      this.geometry.right = bbox.x2;
      this.geometry.bottom = bbox.y2;
      return this.geometry.center = {
        x: (this.geometry.right - this.geometry.left) / 2 + this.geometry.left,
        y: (this.geometry.bottom - this.geometry.top) / 2 + this.geometry.top
      };
    };

    return Widget;

  })();

  module.exports = Widget;

}).call(this);

/*
//@ sourceMappingURL=widget.map
*/

},{}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
 (c) 2012, Huub de Beer, H.T.de.Beer@gmail.com
*/


(function() {
  var MeasureLine;

  MeasureLine = (function() {
    MeasureLine.EPSILON = 0.01;

    MeasureLine.prototype.to_json = function() {
      var export_object;
      export_object = {
        volume: this.volume,
        height: this.height,
        initial_position: this.initial_position,
        position: {
          x: this.position.x,
          y: this.position.y
        },
        side: this.side,
        movable: this.movable,
        visible: this.visible
      };
      return JSON.stringify(export_object);
    };

    MeasureLine.prototype.from_json = function(mljson) {
      this.volume = mljson.volume;
      this.height = mljson.height;
      this.initial_position = mljson.initial_position;
      this.position = mljson.position;
      this.side = mljson.side;
      this.movable = mljson.movable;
      return this.visible = mljson.visible;
    };

    function MeasureLine(volume, height, glass, initial_position, side, visible, movable) {
      this.volume = volume;
      this.height = height;
      this.glass = glass;
      this.initial_position = initial_position != null ? initial_position : {
        x: -1,
        y: -1
      };
      this.side = side != null ? side : 'right';
      this.visible = visible != null ? visible : false;
      this.movable = movable != null ? movable : true;
      this.set_position(this.initial_position);
    }

    MeasureLine.prototype.reset = function() {
      /*
      */

      return this.set_position(this.initial_position);
    };

    MeasureLine.prototype.hide = function() {
      return this.visible = false;
    };

    MeasureLine.prototype.show = function() {
      return this.visible = true;
    };

    MeasureLine.prototype.set_position = function(position) {
      /*
      Set the position of this measure line. Position is a point (x, y). Subsequently the height in mm can be computed.
      */

      this.position = position;
      return this.height = (this.glass.foot.y - this.position.y) / this.glass.unit;
    };

    MeasureLine.prototype.is_correct = function() {
      /*
      Is this measure line on the correct height on the glass? That is: is the error smaller than epsilon?
      */

      return Math.abs(this.error) <= MeasureLine.EPSILON;
    };

    MeasureLine.prototype.error = function() {
      /*
      The distance of this measure line to the correct position in mm. A negative error means it is too hight, a positive distance that it is too low
      */

      return (this.glass.height_at_volume(this.volume)) - this.height;
    };

    return MeasureLine;

  })();

  module.exports = MeasureLine;

}).call(this);

/*
//@ sourceMappingURL=measure_line.map
*/

},{}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
(c) 2012, Huub de Beer, H.T.de.Beer@gmail.com
*/


(function() {
  var MeasureLine, WMeasureLine, Widget,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Widget = require('../widget');

  MeasureLine = require('./measure_line');

  WMeasureLine = (function(_super) {
    __extends(WMeasureLine, _super);

    function WMeasureLine(canvas, x, y, ml, foot, spec) {
      var _this = this;
      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.ml = ml;
      this.foot = foot;
      this.spec = spec != null ? spec : {};
      this.end = __bind(this.end, this);
      this.start = __bind(this.start, this);
      this.drag = __bind(this.drag, this);
      WMeasureLine.__super__.constructor.call(this, this.canvas, this.x, this.y, this.spec);
      this._draw();
      if (this.ml.movable) {
        this.widgets.mouseover(function(e) {
          return _this.border.attr({
            fill: 'gold',
            'fill-opacity': 0.25,
            'stroke-opacity': 0.75,
            cursor: 'move'
          });
        });
        this.widgets.mouseout(function(e) {
          return _this.border.attr({
            'stroke-opacity': 0,
            cursor: 'default',
            fill: 'white',
            'fill-opacity': 0
          });
        });
        this.widgets.drag(this.drag, this.start, this.end);
      }
    }

    WMeasureLine.prototype.drag = function(dx, dy, x, y, e) {
      var tx, ty;
      tx = Math.floor(dx - this.dpo.x);
      ty = Math.floor(dy - this.dpo.y);
      this.x += tx;
      this.y += ty;
      this.widgets.transform("...t" + tx + "," + ty);
      this.dpo = {
        x: dx,
        y: dy
      };
      this._compute_geometry();
      this.ml.position.x = this.x;
      this.ml.position.y = this.y;
      return this.ml.glass.change_measure_line(this.ml.volume, (this.foot - this.y) / this.ml.glass.unit);
    };

    WMeasureLine.prototype.show = function() {
      return this.widgets.show();
    };

    WMeasureLine.prototype.hide = function() {
      return this.widgets.hide();
    };

    WMeasureLine.prototype.start = function() {
      var _ref;
      this.dpo = (_ref = this.dpo) != null ? _ref : {};
      this.dpo = {
        x: 0,
        y: 0
      };
      return this.border.attr({
        'fill': 'gold',
        'fill-opacity': 0.05
      });
    };

    WMeasureLine.prototype.end = function() {
      return this.border.attr({
        'fill': 'white',
        'fill-opacity': 0
      });
    };

    WMeasureLine.prototype._draw = function() {
      var BENDINESS, LABELSKIP, TICKWIDTH, bbox, label, labelleft, tick, tickpath, _ref, _ref1, _ref2, _ref3, _ref4;
      TICKWIDTH = (_ref = this.spec['thickwidth']) != null ? _ref : 10;
      LABELSKIP = (_ref1 = this.spec['labelskip']) != null ? _ref1 : 5;
      BENDINESS = 6;
      this.bend = (_ref2 = this.spec.bend) != null ? _ref2 : false;
      switch (this.ml.side) {
        case 'right':
          if (this.bend) {
            tickpath = "M" + this.ml.position.x + "," + this.ml.position.y + "c0," + 2 + ",-" + BENDINESS + "," + BENDINESS + ",-" + TICKWIDTH + "," + BENDINESS;
          } else {
            tickpath = "M" + this.ml.position.x + "," + this.ml.position.y + "h-" + TICKWIDTH;
          }
          tick = this.canvas.path(tickpath);
          label = this.canvas.text(0, 0, "" + this.ml.volume + " ml");
          label.attr({
            'font-family': (_ref3 = this.spec['font-family']) != null ? _ref3 : 'sans-serif',
            'font-size': (_ref4 = this.spec['font-size']) != null ? _ref4 : 12,
            'text-anchor': 'start'
          });
          bbox = label.getBBox();
          labelleft = this.ml.position.x - LABELSKIP - bbox.width - TICKWIDTH;
          if (this.bend) {
            label.attr({
              x: labelleft,
              y: this.ml.position.y + BENDINESS
            });
          } else {
            label.attr({
              x: labelleft,
              y: this.ml.position.y
            });
          }
          bbox = label.getBBox();
          this.border = this.canvas.rect(bbox.x, bbox.y, bbox.width + TICKWIDTH, bbox.height);
          this.border.attr({
            stroke: 'black',
            fill: 'white',
            'fill-opacity': 0,
            'stroke-opacity': 0,
            'stroke-dasharray': '. '
          });
          break;
        case 'left':
          tickpath = "M" + this.ml.position.x + "," + this.ml.position.y + "h" + TICKWIDTH;
      }
      this.widgets.push(tick, label, this.border);
      bbox = this.widgets.getBBox();
      this.width = bbox.width;
      return this.height = bbox.height;
    };

    return WMeasureLine;

  })(Widget);

  module.exports = WMeasureLine;

}).call(this);

/*
//@ sourceMappingURL=wmeasure_line.map
*/

},{"../widget":4,"./measure_line":5}]},{},[1])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvaG9tZS9odC9wcmltYXJ5Y2FsY3VsdXMtc2Vjb25kX3N0dWR5L3NyYy90ZXN0LmpzIiwiL2hvbWUvaHQvcHJpbWFyeWNhbGN1bHVzLXNlY29uZF9zdHVkeS9zcmMvd2lkZ2V0cy9nbGFzcy9nbGFzcy5qcyIsIi9ob21lL2h0L3ByaW1hcnljYWxjdWx1cy1zZWNvbmRfc3R1ZHkvc3JjL3dpZGdldHMvZ2xhc3Mvd2dsYXNzLmpzIiwiL2hvbWUvaHQvcHJpbWFyeWNhbGN1bHVzLXNlY29uZF9zdHVkeS9zcmMvd2lkZ2V0cy93aWRnZXQuanMiLCIvaG9tZS9odC9wcmltYXJ5Y2FsY3VsdXMtc2Vjb25kX3N0dWR5L3NyYy93aWRnZXRzL2dsYXNzL21lYXN1cmVfbGluZS5qcyIsIi9ob21lL2h0L3ByaW1hcnljYWxjdWx1cy1zZWNvbmRfc3R1ZHkvc3JjL3dpZGdldHMvZ2xhc3Mvd21lYXN1cmVfbGluZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuM1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgR2xhc3MsIFdHbGFzcywgY2FudmFzLCBjb2NrdGFpbF9nbGFzcywgY29ja3RhaWxfanNvbiwgY29ja3RhaWxfcmVwcmVzZW50YXRpb24sIGV4cG9ydF9zdHJpbmcsIHc7XG5cbiAgY29uc29sZS5sb2coXCJ0ZXN0XCIpO1xuXG4gIGNvY2t0YWlsX2pzb24gPSAne1wicGF0aFwiOlwiTSA0MTkgMTAyIGwgLTE1MiAyNDUgbCAwIDE4NSBjIDAgMjMuMjUgMTAxIDExLjc1IDEwNiAyNVwiLFwiZm9vdFwiOntcInhcIjoyNTUsXCJ5XCI6NTU3fSxcInN0ZW1cIjp7XCJ4XCI6MjU1LFwieVwiOjUzMn0sXCJib3dsXCI6e1wieFwiOjI1NSxcInlcIjozNDd9LFwiZWRnZVwiOntcInhcIjoyNTUsXCJ5XCI6MTAyfSxcImhlaWdodF9pbl9tbVwiOjE1MCxcInNwZWNcIjp7XCJyb3VuZF9tYXhcIjpcImNsXCIsXCJtbV9mcm9tX3RvcFwiOjB9LFwibWVhc3VyZV9saW5lc1wiOnt9LFwibnJfb2ZfbWVhc3VyZV9saW5lc1wiOjB9JztcblxuICBjYW52YXMgPSBSYXBoYWVsKCd0ZXN0JywgNTAwLCA1MDApO1xuXG4gIGNvbnNvbGUubG9nKFwiaW5cIik7XG5cbiAgR2xhc3MgPSByZXF1aXJlKCcuL3dpZGdldHMvZ2xhc3MvZ2xhc3MnKTtcblxuICBXR2xhc3MgPSByZXF1aXJlKCcuL3dpZGdldHMvZ2xhc3Mvd2dsYXNzJyk7XG5cbiAgY29ja3RhaWxfZ2xhc3MgPSBuZXcgR2xhc3MoY29ja3RhaWxfanNvbik7XG5cbiAgZXhwb3J0X3N0cmluZyA9IGNvY2t0YWlsX2dsYXNzLnRvX2Z1bGxfanNvbigpO1xuXG4gIHcgPSB3aW5kb3cub3BlbignJyk7XG5cbiAgdy5kb2N1bWVudC5vcGVuKCd0ZXh0L3BsYWluJyk7XG5cbiAgdy5kb2N1bWVudC53cml0ZShleHBvcnRfc3RyaW5nKTtcblxuICBjb2NrdGFpbF9yZXByZXNlbnRhdGlvbiA9IG5ldyBXR2xhc3MoY2FudmFzLCAxLCAxLCBjb2NrdGFpbF9nbGFzcyk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8qXG4vL0Agc291cmNlTWFwcGluZ1VSTD10ZXN0Lm1hcFxuKi9cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjNcbi8qXG5nbGFzcy5jb2ZmZWUgdmVyc2lvbiAwLjFcblxuTW9kZWxpbmcgZGlmZmVyZW50IGdsYXNzZXNcblxuKGMpIDIwMTIgSHV1YiBkZSBCZWVyIEguVC5kZS5CZWVyQGdtYWlsLmNvbVxuXG5Mb25nIGRlc2NyaXB0aW9uXG4qL1xuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIEdsYXNzO1xuXG4gIEdsYXNzID0gKGZ1bmN0aW9uKCkge1xuICAgIEdsYXNzLlRFTlRIX09GX01NID0gMTA7XG5cbiAgICBHbGFzcy5wcm90b3R5cGUudG9fanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV4cG9ydF9vYmplY3Q7XG4gICAgICBleHBvcnRfb2JqZWN0ID0ge1xuICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgIGZvb3Q6IHtcbiAgICAgICAgICB4OiB0aGlzLmZvb3QueCxcbiAgICAgICAgICB5OiB0aGlzLmZvb3QueVxuICAgICAgICB9LFxuICAgICAgICBzdGVtOiB7XG4gICAgICAgICAgeDogdGhpcy5zdGVtLngsXG4gICAgICAgICAgeTogdGhpcy5zdGVtLnlcbiAgICAgICAgfSxcbiAgICAgICAgYm93bDoge1xuICAgICAgICAgIHg6IHRoaXMuYm93bC54LFxuICAgICAgICAgIHk6IHRoaXMuYm93bC55XG4gICAgICAgIH0sXG4gICAgICAgIGVkZ2U6IHtcbiAgICAgICAgICB4OiB0aGlzLmVkZ2UueCxcbiAgICAgICAgICB5OiB0aGlzLmVkZ2UueVxuICAgICAgICB9LFxuICAgICAgICBoZWlnaHRfaW5fbW06IHRoaXMuaGVpZ2h0X2luX21tLFxuICAgICAgICBzcGVjOiB0aGlzLnNwZWNcbiAgICAgIH07XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXhwb3J0X29iamVjdCwgbnVsbCwgJyAgJyk7XG4gICAgfTtcblxuICAgIEdsYXNzLnByb3RvdHlwZS50b19mdWxsX2pzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBleHBvcnRfb2JqZWN0O1xuICAgICAgZXhwb3J0X29iamVjdCA9IHtcbiAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICBmb290OiB7XG4gICAgICAgICAgeDogdGhpcy5mb290LngsXG4gICAgICAgICAgeTogdGhpcy5mb290LnlcbiAgICAgICAgfSxcbiAgICAgICAgc3RlbToge1xuICAgICAgICAgIHg6IHRoaXMuc3RlbS54LFxuICAgICAgICAgIHk6IHRoaXMuc3RlbS55XG4gICAgICAgIH0sXG4gICAgICAgIGJvd2w6IHtcbiAgICAgICAgICB4OiB0aGlzLmJvd2wueCxcbiAgICAgICAgICB5OiB0aGlzLmJvd2wueVxuICAgICAgICB9LFxuICAgICAgICBib3dsX3N0YXJ0OiB0aGlzLmJvd2xfc3RhcnQsXG4gICAgICAgIGVkZ2U6IHtcbiAgICAgICAgICB4OiB0aGlzLmVkZ2UueCxcbiAgICAgICAgICB5OiB0aGlzLmVkZ2UueVxuICAgICAgICB9LFxuICAgICAgICBoZWlnaHRfaW5fbW06IHRoaXMuaGVpZ2h0X2luX21tLFxuICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgIHNwZWM6IHRoaXMuc3BlYyxcbiAgICAgICAgdm9sOiB0aGlzLnZvbCxcbiAgICAgICAgcjogdGhpcy5yLFxuICAgICAgICBzcGVlZDogdGhpcy5zcGVlZCxcbiAgICAgICAgbWF4aW11bV9oZWlnaHQ6IHRoaXMubWF4aW11bV9oZWlnaHQsXG4gICAgICAgIG1heGltdW1fdm9sdW1lOiB0aGlzLm1heGltdW1fdm9sdW1lLFxuICAgICAgICBtYXhpbXVtX3NwZWVkOiB0aGlzLm1heGltdW1fc3BlZWRcbiAgICAgIH07XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXhwb3J0X29iamVjdCwgbnVsbCwgJyAgJyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEdsYXNzKHBhdGgsIGZvb3QsIHN0ZW0sIGJvd2wsIGVkZ2UsIGhlaWdodF9pbl9tbSwgc3BlYykge1xuICAgICAgdmFyIGltcG9ydF9vYmplY3QsIF9yZWYsIF9yZWYxLCBfcmVmMiwgX3JlZjMsIF9yZWY0LCBfcmVmNSwgX3JlZjYsIF9yZWY3LCBfcmVmODtcbiAgICAgIGlmIChzcGVjID09IG51bGwpIHtcbiAgICAgICAgc3BlYyA9IHtcbiAgICAgICAgICByb3VuZF9tYXg6IFwiY2xcIixcbiAgICAgICAgICBtbV9mcm9tX3RvcDogNVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLypcbiAgICAgIHByZTpcbiAgICAgICAgICBwYXRoIGlzIHRoZSByaWdodCBoYW5kIHNpZGUgb2YgdGhlIGNvdW50b3VyIG9mIHRoZSBnbGFzc1xuICAgICAgICDiiKcgMCDiiaQgZm9vdC55IFxuICAgICAgICDiiKcgZm9vdC55IOKJpCBzdGVtLnkgXG4gICAgICAgIOKIpyBzdGVtLnkg4omkIGJvd2wueVxuICAgICAgICDiiKcgYm93bC55IDwgZWRnZS55XG4gICAgICAgIOKIpyAwIDwgaGVpZ2h0X2luX21tXG4gICAgICBcbiAgICAgIHBvc3Q6XG4gICAgICAgICAgaXNfZW1wdHlcbiAgICAgICovXG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGltcG9ydF9vYmplY3QgPSBKU09OLnBhcnNlKHBhdGgpO1xuICAgICAgICB0aGlzLnBhdGggPSBpbXBvcnRfb2JqZWN0LnBhdGg7XG4gICAgICAgIHRoaXMuZm9vdCA9IGltcG9ydF9vYmplY3QuZm9vdDtcbiAgICAgICAgdGhpcy5zdGVtID0gaW1wb3J0X29iamVjdC5zdGVtO1xuICAgICAgICB0aGlzLmJvd2wgPSBpbXBvcnRfb2JqZWN0LmJvd2w7XG4gICAgICAgIHRoaXMuZWRnZSA9IGltcG9ydF9vYmplY3QuZWRnZTtcbiAgICAgICAgdGhpcy5oZWlnaHRfaW5fbW0gPSBpbXBvcnRfb2JqZWN0LmhlaWdodF9pbl9tbTtcbiAgICAgICAgdGhpcy5zcGVjID0gKF9yZWYgPSBpbXBvcnRfb2JqZWN0ICE9IG51bGwgPyBpbXBvcnRfb2JqZWN0LnNwZWMgOiB2b2lkIDApICE9IG51bGwgPyBfcmVmIDoge1xuICAgICAgICAgIHJvdW5kX21heDogXCJjbFwiLFxuICAgICAgICAgIG1tX2Zyb21fdG9wOiA1XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5pdCA9IChfcmVmMSA9IGltcG9ydF9vYmplY3QgIT0gbnVsbCA/IGltcG9ydF9vYmplY3QudW5pdCA6IHZvaWQgMCkgIT0gbnVsbCA/IF9yZWYxIDogTWF0aC5hYnModGhpcy5lZGdlLnkgLSB0aGlzLmZvb3QueSkgLyB0aGlzLmhlaWdodF9pbl9tbTtcbiAgICAgICAgdGhpcy5ib3dsX3N0YXJ0ID0gKF9yZWYyID0gaW1wb3J0X29iamVjdCAhPSBudWxsID8gaW1wb3J0X29iamVjdC5ib3dsX3N0YXJ0IDogdm9pZCAwKSAhPSBudWxsID8gX3JlZjIgOiB0aGlzLmhlaWdodF9pbl9tbSAtIChNYXRoLmFicyh0aGlzLmJvd2wueSAtIHRoaXMuZWRnZS55KSAvIHRoaXMudW5pdCk7XG4gICAgICAgIHRoaXMuciA9IChfcmVmMyA9IGltcG9ydF9vYmplY3QgIT0gbnVsbCA/IGltcG9ydF9vYmplY3QuciA6IHZvaWQgMCkgIT0gbnVsbCA/IF9yZWYzIDogW107XG4gICAgICAgIGlmICghKGltcG9ydF9vYmplY3QgIT0gbnVsbCA/IGltcG9ydF9vYmplY3QuciA6IHZvaWQgMCkpIHtcbiAgICAgICAgICB0aGlzLnIgPSB0aGlzLl9jb21wdXRlX3IodGhpcy5wYXRoLCB0aGlzLmZvb3QsIHRoaXMuaGVpZ2h0X2luX21tLCB0aGlzLnVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMucik7XG4gICAgICAgIHRoaXMudm9sID0gKF9yZWY0ID0gaW1wb3J0X29iamVjdCAhPSBudWxsID8gaW1wb3J0X29iamVjdC52b2wgOiB2b2lkIDApICE9IG51bGwgPyBfcmVmNCA6IFtdO1xuICAgICAgICB0aGlzLnNwZWVkID0gKF9yZWY1ID0gaW1wb3J0X29iamVjdCAhPSBudWxsID8gaW1wb3J0X29iamVjdC5zcGVlZCA6IHZvaWQgMCkgIT0gbnVsbCA/IF9yZWY1IDogW107XG4gICAgICAgIHRoaXMubWF4aW11bV92b2x1bWUgPSAoX3JlZjYgPSBpbXBvcnRfb2JqZWN0ICE9IG51bGwgPyBpbXBvcnRfb2JqZWN0Lm1heGltdW1fdm9sdW1lIDogdm9pZCAwKSAhPSBudWxsID8gX3JlZjYgOiAwO1xuICAgICAgICB0aGlzLm1heGltdW1faGVpZ2h0ID0gKF9yZWY3ID0gaW1wb3J0X29iamVjdCAhPSBudWxsID8gaW1wb3J0X29iamVjdC5tYXhpbXVtX2hlaWdodCA6IHZvaWQgMCkgIT0gbnVsbCA/IF9yZWY3IDogMDtcbiAgICAgICAgdGhpcy5tYXhpbXVtX3NwZWVkID0gKF9yZWY4ID0gaW1wb3J0X29iamVjdCAhPSBudWxsID8gaW1wb3J0X29iamVjdC5tYXhpbXVtX3NwZWVkIDogdm9pZCAwKSAhPSBudWxsID8gX3JlZjggOiAwO1xuICAgICAgICBpZiAodGhpcy5tYXhpbXVtX3ZvbHVtZSA9PT0gMCB8fCB0aGlzLm1heGltdW1faGVpZ2h0ID09PSAwIHx8IHRoaXMubWF4aW11bV9zcGVlZCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2RldGVybWluZV9tYXhpbXVtKHRoaXMuaGVpZ2h0X2luX21tIC0gdGhpcy5zcGVjLm1tX2Zyb21fdG9wLCB0aGlzLnNwZWMucm91bmRfbWF4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5mb290ID0gZm9vdDtcbiAgICAgICAgdGhpcy5zdGVtID0gc3RlbTtcbiAgICAgICAgdGhpcy5ib3dsID0gYm93bDtcbiAgICAgICAgdGhpcy5lZGdlID0gZWRnZTtcbiAgICAgICAgdGhpcy5oZWlnaHRfaW5fbW0gPSBoZWlnaHRfaW5fbW07XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIHRoaXMudW5pdCA9IE1hdGguYWJzKHRoaXMuZWRnZS55IC0gdGhpcy5mb290LnkpIC8gdGhpcy5oZWlnaHRfaW5fbW07XG4gICAgICAgIHRoaXMuYm93bF9zdGFydCA9IHRoaXMuaGVpZ2h0X2luX21tIC0gKE1hdGguYWJzKHRoaXMuYm93bC55IC0gdGhpcy5lZGdlLnkpIC8gdGhpcy51bml0KTtcbiAgICAgICAgdGhpcy5yID0gW107XG4gICAgICAgIHRoaXMuciA9IHRoaXMuX2NvbXB1dGVfcih0aGlzLnBhdGgsIHRoaXMuZm9vdCwgdGhpcy5oZWlnaHRfaW5fbW0sIHRoaXMudW5pdCk7XG4gICAgICAgIHRoaXMudm9sID0gW107XG4gICAgICAgIHRoaXMuc3BlZWQgPSBbXTtcbiAgICAgICAgdGhpcy5tYXhpbXVtX3ZvbHVtZSA9IDA7XG4gICAgICAgIHRoaXMubWF4aW11bV9oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLm1heGltdW1fc3BlZWQgPSAwO1xuICAgICAgICB0aGlzLl9kZXRlcm1pbmVfbWF4aW11bSh0aGlzLmhlaWdodF9pbl9tbSAtIHRoaXMuc3BlYy5tbV9mcm9tX3RvcCwgdGhpcy5zcGVjLnJvdW5kX21heCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1ha2VfZW1wdHkoKTtcbiAgICB9XG5cbiAgICBHbGFzcy5wcm90b3R5cGUuY29tcHV0ZV9zcGVlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRoLCBkdm9sLCBoLCBoX21heCwgdl9wcmV2LCB2b2wsIF9yZXN1bHRzO1xuICAgICAgaCA9IDA7XG4gICAgICBoX21heCA9IHRoaXMudm9sLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAodGhpcy52b2xbaF0gPT09IDApIHtcbiAgICAgICAgaCsrO1xuICAgICAgfVxuICAgICAgdGhpcy5zcGVlZFswXSA9IDA7XG4gICAgICB2X3ByZXYgPSAwO1xuICAgICAgdGhpcy5tYXhpbXVtX3NwZWVkID0gMDtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAoaCA8PSBoX21heCkge1xuICAgICAgICB2b2wgPSB0aGlzLnZvbFtoXTtcbiAgICAgICAgZGggPSAwO1xuICAgICAgICB3aGlsZSAoaCA8PSBoX21heCAmJiB2X3ByZXYgPT09IHZvbCkge1xuICAgICAgICAgIGgrKztcbiAgICAgICAgICBkaCArPSAwLjAxO1xuICAgICAgICAgIHZvbCA9IHRoaXMudm9sW2hdO1xuICAgICAgICB9XG4gICAgICAgIGR2b2wgPSB2b2wgLSB2X3ByZXY7XG4gICAgICAgIHRoaXMuc3BlZWRbdm9sXSA9IGRoIC8gZHZvbDtcbiAgICAgICAgdGhpcy5tYXhpbXVtX3NwZWVkID0gTWF0aC5tYXgodGhpcy5tYXhpbXVtX3NwZWVkLCB0aGlzLnNwZWVkW3ZvbF0pO1xuICAgICAgICB2X3ByZXYgPSB2b2w7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goaCsrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgR2xhc3MucHJvdG90eXBlLm1ha2VfZW1wdHkgPSBmdW5jdGlvbihpbml0aWFsX3ZhbHVlKSB7XG4gICAgICBpZiAoaW5pdGlhbF92YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGluaXRpYWxfdmFsdWUgPSAwO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgIEVtcHR5IHRoaXMgZ2xhc3MgXG4gICAgICBcbiAgICAgIHByZTpcbiAgICAgICAgICBUcnVlXG4gICAgICBcbiAgICAgIHBvc3Q6XG4gICAgICAgICAgY3VycmVudF9oZWlnaHQgPSAwXG4gICAgICAgIOKIpyBjdXJyZW50X3ZvbHVtZSA9IDBcbiAgICAgICovXG5cbiAgICAgIHRoaXMuY3VycmVudF92b2x1bWUgPSAwO1xuICAgICAgdGhpcy5jdXJyZW50X2hlaWdodCA9IDA7XG4gICAgICB0aGlzLmN1cnJlbnRfaGVpZ2h0ID0gdGhpcy5maWxsX3RvX3ZvbHVtZShpbml0aWFsX3ZhbHVlKTtcbiAgICAgIHRoaXMuY3VycmVudF9oZWlnaHQrKztcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRfZ3JhcGggPSBcIk0wLDBcIjtcbiAgICB9O1xuXG4gICAgR2xhc3MucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvKlxuICAgICAgSXMgdGhpcyBnbGFzcyBlbXB0eT9cbiAgICAgIFxuICAgICAgcHJlOlxuICAgICAgICAgIFRydWVcbiAgICAgIFxuICAgICAgcG9zdDpcbiAgICAgICAgICBUcnVlXG4gICAgICBcbiAgICAgIHJldHVybjpcbiAgICAgICAgICBjdXJyZW50X3ZvbHVtZSA9IDBcbiAgICAgICovXG5cbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRfdm9sdW1lID09PSAwO1xuICAgIH07XG5cbiAgICBHbGFzcy5wcm90b3R5cGUuaXNfZnVsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLypcbiAgICAgIElzIHRoaXMgZ2xhc3MgZnVsbD9cbiAgICAgIFxuICAgICAgcHJlOlxuICAgICAgICAgIFRydWVcbiAgICAgIFxuICAgICAgcG9zdDpcbiAgICAgICAgICBUcnVlXG4gICAgICBcbiAgICAgIHJldHVybjpcbiAgICAgICAgICBjdXJyZW50X3ZvbHVtZSA9IG1heGltdW1fdm9sdW1lXG4gICAgICAqL1xuXG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50X3ZvbHVtZSA9PT0gdGhpcy5tYXhpbXVtX3ZvbHVtZTtcbiAgICB9O1xuXG4gICAgR2xhc3MucHJvdG90eXBlLmZpbGxfdG9faGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAvKlxuICAgICAgRmlsbCB0aGlzIGdsYXNzIHVwIHRvIGhlaWdodCBhbmQgcmV0dXJuIGNvcnJlc3BvbmRpbmcgdm9sdW1lXG4gICAgICBcbiAgICAgIHByZTogXG4gICAgICAgICAgaGVpZ2h0LCAwIOKJpCBoZWlnaHQg4omkIG1heGltdW1faGVpZ2h0XG4gICAgICBcbiAgICAgIHBvc3Q6XG4gICAgICAgICAgY3VycmVudF9oZWlnaHQgPSBoZWlnaHRcbiAgICAgICAg4oinIGN1cnJlbnRfdm9sdW1lID0gdm9sdW1lX2F0X2hlaWdodChoZWlnaHQpXG4gICAgICBcbiAgICAgIHJldHVybjpcbiAgICAgICAgICB2b2x1bWVfYXRfaGVpZ2h0KGhlaWdodClcbiAgICAgICovXG5cbiAgICAgIGlmIChoZWlnaHQgPD0gdGhpcy5tYXhpbXVtX2hlaWdodCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRfaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXJyZW50X2hlaWdodCA9IHRoaXMubWF4aW11bV9oZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnJlbnRfdm9sdW1lID0gdGhpcy52b2x1bWVfYXRfaGVpZ2h0KHRoaXMuY3VycmVudF9oZWlnaHQpO1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudF92b2x1bWU7XG4gICAgfTtcblxuICAgIEdsYXNzLnByb3RvdHlwZS5maWxsX3RvX3ZvbHVtZSA9IGZ1bmN0aW9uKHZvbHVtZSkge1xuICAgICAgLypcbiAgICAgIEZpbGwgdGhpcyBnbGFzcyB1cCB0byB2b2x1bWUgYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyB3YXRlciBsZXZlbCBoZWlnaHQuXG4gICAgICBcbiAgICAgIHByZTpcbiAgICAgICAgICB2b2x1bWUsIDAg4omkIHZvbHVtZSDiiaQgbWF4aW11bV92b2x1bWVcbiAgICAgIFxuICAgICAgcG9zdDpcbiAgICAgICAgICBjdXJyZW50X3ZvbHVtZSA9IHZvbHVtZVxuICAgICAgICDiiKcgY3VycmVudF9oZWlnaHQgPSBoZWlnaHRfYXRfdm9sdW1lKHZvbHVtZSlcbiAgICAgIFxuICAgICAgcmV0dXJuOlxuICAgICAgICAgIGhlaWdodF9hdF92b2x1bWUodm9sdW1lKVxuICAgICAgKi9cblxuICAgICAgaWYgKHZvbHVtZSA8PSB0aGlzLm1heGltdW1fdm9sdW1lKSB7XG4gICAgICAgIHRoaXMuY3VycmVudF92b2x1bWUgPSB2b2x1bWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRfdm9sdW1lID0gdGhpcy5tYXhpbXVtX3ZvbHVtZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudF9oZWlnaHQgPSB0aGlzLmhlaWdodF9hdF92b2x1bWUodGhpcy5jdXJyZW50X3ZvbHVtZSk7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50X2hlaWdodDtcbiAgICB9O1xuXG4gICAgR2xhc3MucHJvdG90eXBlLnNwZWVkX2F0X2hlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BlZWRbaGVpZ2h0ICogR2xhc3MuVEVOVEhfT0ZfTU1dO1xuICAgIH07XG5cbiAgICBHbGFzcy5wcm90b3R5cGUuc3BlZWRfYXRfdm9sdW1lID0gZnVuY3Rpb24odm9sKSB7XG4gICAgICB2YXIgaDtcbiAgICAgIGggPSBoZWlnaHRfYXRfdm9sdW1lKHZvbCk7XG4gICAgICByZXR1cm4gdGhpcy5zcGVlZFtoICogR2xhc3MuVEVOVEhfT0ZfTU1dO1xuICAgIH07XG5cbiAgICBHbGFzcy5wcm90b3R5cGUudm9sdW1lX2F0X2hlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgLypcbiAgICAgIENvbXB1dGUgdGhlIHZvbHVtZSBvZiB0aGUgd2F0ZXIgaW4gdGhpcyBnbGFzcyB3aGVuIGl0IGlzIGZpbGxlZCB1cCB0b1xuICAgICAgaGVpZ2h0LiBUYWtlIGluIGFjY291bnQgdGhlIHNoYXBlIG9mIHRoZSBnbGFzczogb25seSB0aGUgYm93bCBvZiB0aGVcbiAgICAgIGdsYXNzIGNhbiBiZSBmaWxsZWQuXG4gICAgICBcbiAgICAgIHByZTpcbiAgICAgICAgICBoZWlnaHQ6IHdhdGVyIGxldmVsIGhlaWdodCBpbiBtbVxuICAgICAgXG4gICAgICBwb3N0OlxuICAgICAgICAgIHZvbHVtZSA9ICjiiKtoOiAwIOKJpCBoIOKJpCBoZWlnaHQ6IM+AcihoKV4yKVxuICAgICAgXG4gICAgICByZXR1cm46XG4gICAgICAgICAgdm9sdW1lIGluIG1sXG4gICAgICAqL1xuXG4gICAgICB2YXIgSFNURVAsIGR2b2wsIGg7XG4gICAgICBIU1RFUCA9IDAuMDE7XG4gICAgICBoID0gTWF0aC5jZWlsKGhlaWdodCAqIEdsYXNzLlRFTlRIX09GX01NKTtcbiAgICAgIGlmICh0aGlzLnZvbFtoXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy52b2xbMF0gPSAwO1xuICAgICAgICAgIHRoaXMuc3BlZWRbMF0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoMCA8PSBoZWlnaHQgJiYgaGVpZ2h0IDwgdGhpcy5ib3dsX3N0YXJ0KSkge1xuICAgICAgICAgICAgdGhpcy52b2xbaF0gPSAwICsgdGhpcy52b2x1bWVfYXRfaGVpZ2h0KChoIC0gMSkgLyBHbGFzcy5URU5USF9PRl9NTSk7XG4gICAgICAgICAgICB0aGlzLnNwZWVkW2hdID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHZvbCA9IE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJbaF0gLyBHbGFzcy5URU5USF9PRl9NTSwgMikgKiBIU1RFUDtcbiAgICAgICAgICAgIHRoaXMudm9sW2hdID0gZHZvbCArIHRoaXMudm9sdW1lX2F0X2hlaWdodCgoaCAtIDEpIC8gR2xhc3MuVEVOVEhfT0ZfTU0pO1xuICAgICAgICAgICAgdGhpcy5zcGVlZFtoXSA9IGR2b2wgIT09IDAgPyBIU1RFUCAvIGR2b2wgOiAwO1xuICAgICAgICAgICAgdGhpcy5tYXhpbXVtX3NwZWVkID0gTWF0aC5tYXgodGhpcy5tYXhpbXVtX3NwZWVkLCB0aGlzLnNwZWVkW2hdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnZvbFtoXTtcbiAgICB9O1xuXG4gICAgR2xhc3MucHJvdG90eXBlLmhlaWdodF9hdF92b2x1bWUgPSBmdW5jdGlvbih2b2x1bWUpIHtcbiAgICAgIC8qXG4gICAgICBDb21wdXRlIHRoZSBoZWlnaHQgb2YgdGhlIHdhdGVyIGxldmVsIGluIHRoaXMgZ2xhc3Mgd2hlbiB0aGVyZSBpcyB2b2x1bWUgd2F0ZXIgaW4gaXQuXG4gICAgICBcbiAgICAgIHByZTpcbiAgICAgICAgICAwIOKJpCB2b2x1bWUgXG4gICAgICBcbiAgICAgIHBvc3Q6XG4gICAgICAgICAgaGVpZ2h0ID0gKGg6IDAg4omkIGgg4omkIHRvdGFsX2hlaWdodDogdm9sW2ggKyAxXSA+IHZvbHVtZSDiiKcgdm9sW2gtMV0gPCB2b2x1bWUpXG4gICAgICBcbiAgICAgIHJldHVybjpcbiAgICAgICAgICBoZWlnaHQgaW4gbW1cbiAgICAgICovXG5cbiAgICAgIHZhciBoZWlnaHQsIG1heGhlaWdodDtcbiAgICAgIGhlaWdodCA9IHRoaXMuY3VycmVudF9oZWlnaHQgKiBHbGFzcy5URU5USF9PRl9NTTtcbiAgICAgIG1heGhlaWdodCA9IHRoaXMuaGVpZ2h0X2luX21tICogR2xhc3MuVEVOVEhfT0ZfTU07XG4gICAgICB3aGlsZSAoISh0aGlzLnZvbFtoZWlnaHRdID4gdm9sdW1lIHx8IGhlaWdodCA+PSBtYXhoZWlnaHQpKSB7XG4gICAgICAgIGhlaWdodCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoaGVpZ2h0IC8gR2xhc3MuVEVOVEhfT0ZfTU0pO1xuICAgIH07XG5cbiAgICBHbGFzcy5wcm90b3R5cGUuZ2V0X2N1cnJlbnRfZ3JhcGggPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRfZ3JhcGggPSB0aGlzLmdyYXBoW01hdGguY2VpbCh0aGlzLmN1cnJlbnRfaGVpZ2h0ICogR2xhc3MuVEVOVEhfT0ZfTU0pXTtcbiAgICB9O1xuXG4gICAgR2xhc3MucHJvdG90eXBlLmNyZWF0ZV9ncmFwaCA9IGZ1bmN0aW9uKHBhcGVyLCBncmFwaCwgbGluZSwgeF9heGlzLCBzcGVlZCkge1xuICAgICAgdmFyIEVQU0lMT04sIGFkZF90aW1lLCBkc3BlZWQsIGR0aW1lLCBkdm9sLCBoLCBwLCBwYXRoLCBwdG1tLCBzcGVlZF9iZWZvcmUsIHNwZWVkX3N0ZXAsIHZvbGxhc3QsIHgsIHk7XG4gICAgICBpZiAoc3BlZWQgPT0gbnVsbCkge1xuICAgICAgICBzcGVlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgRVBTSUxPTiA9IDAuMDE7XG4gICAgICBzd2l0Y2ggKHhfYXhpcykge1xuICAgICAgICBjYXNlICd2b2wnOlxuICAgICAgICAgIGlmIChzcGVlZCkge1xuICAgICAgICAgICAgcHRtbSA9IDEgLyAxMDAgLyBsaW5lLnlfdW5pdC5wZXJfcGl4ZWw7XG4gICAgICAgICAgICBkdm9sID0gMDtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGggPSBbXTtcbiAgICAgICAgICAgIHBhdGggPSBcIk0wLDBcIjtcbiAgICAgICAgICAgIGggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudm9sW2hdID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuZ3JhcGgucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgaCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCA9IGxpbmUubWluLng7XG4gICAgICAgICAgICB5ID0gbGluZS5tYXgueSAtICh0aGlzLnNwZWVkW2hdIC8gbGluZS55X3VuaXQucGVyX3BpeGVsKTtcbiAgICAgICAgICAgIHBhdGggPSBcIk1cIiArIHggKyBcIixcIiArIHk7XG4gICAgICAgICAgICB2b2xsYXN0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGgucHVzaChwYXRoKTtcbiAgICAgICAgICAgIHNwZWVkX2JlZm9yZSA9IHRoaXMuc3BlZWRbaF07XG4gICAgICAgICAgICB3aGlsZSAoaCA8IHRoaXMudm9sLmxlbmd0aCAmJiB0aGlzLnZvbFtoXSA8IHRoaXMubWF4aW11bV92b2x1bWUpIHtcbiAgICAgICAgICAgICAgZHZvbCA9IHRoaXMudm9sW2hdIC0gdm9sbGFzdDtcbiAgICAgICAgICAgICAgdm9sbGFzdCA9IHRoaXMudm9sW2hdO1xuICAgICAgICAgICAgICBkc3BlZWQgPSBzcGVlZF9iZWZvcmUgIT09IDAgPyB0aGlzLnNwZWVkW2hdIC0gc3BlZWRfYmVmb3JlIDogMDtcbiAgICAgICAgICAgICAgc3BlZWRfYmVmb3JlID0gdGhpcy5zcGVlZFtoXTtcbiAgICAgICAgICAgICAgc3BlZWRfc3RlcCA9IGRzcGVlZCAvIGxpbmUueV91bml0LnBlcl9waXhlbCAqICgtMSk7XG4gICAgICAgICAgICAgIHBhdGggKz0gXCJsXCIgKyAoZHZvbCAvIGxpbmUueF91bml0LnBlcl9waXhlbCkgKyBcIixcIiArIHNwZWVkX3N0ZXA7XG4gICAgICAgICAgICAgIHRoaXMuZ3JhcGgucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgaCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhcGguYXR0cih7XG4gICAgICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGluZS5hZGRfcG9pbnQoeCwgeSwgZ3JhcGgpO1xuICAgICAgICAgICAgcCA9IGxpbmUuZmluZF9wb2ludF9hdCh4KTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLmFkZF9mcmVlaGFuZF9saW5lKHAsIHBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdG1tID0gMSAvIDEwMCAvIGxpbmUueV91bml0LnBlcl9waXhlbDtcbiAgICAgICAgICAgIGR2b2wgPSAwO1xuICAgICAgICAgICAgdGhpcy5ncmFwaCA9IFtdO1xuICAgICAgICAgICAgcGF0aCA9IFwiTTAsMFwiO1xuICAgICAgICAgICAgaCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy52b2xbaF0gPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5ncmFwaC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICBoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ID0gbGluZS5taW4ueDtcbiAgICAgICAgICAgIHkgPSBsaW5lLm1heC55IC0gKGggLyAxMDAgLyBsaW5lLnlfdW5pdC5wZXJfcGl4ZWwpO1xuICAgICAgICAgICAgcGF0aCA9IFwiTVwiICsgeCArIFwiLFwiICsgeTtcbiAgICAgICAgICAgIHZvbGxhc3QgPSAwO1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgd2hpbGUgKGggPCB0aGlzLnZvbC5sZW5ndGggJiYgdGhpcy52b2xbaF0gPCB0aGlzLm1heGltdW1fdm9sdW1lKSB7XG4gICAgICAgICAgICAgIGR2b2wgPSB0aGlzLnZvbFtoXSAtIHZvbGxhc3Q7XG4gICAgICAgICAgICAgIHZvbGxhc3QgPSB0aGlzLnZvbFtoXTtcbiAgICAgICAgICAgICAgcGF0aCArPSBcImxcIiArIChkdm9sIC8gbGluZS54X3VuaXQucGVyX3BpeGVsKSArIFwiLC1cIiArIHB0bW07XG4gICAgICAgICAgICAgIHRoaXMuZ3JhcGgucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgaCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhcGguYXR0cih7XG4gICAgICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGluZS5hZGRfcG9pbnQoeCwgeSwgZ3JhcGgpO1xuICAgICAgICAgICAgcCA9IGxpbmUuZmluZF9wb2ludF9hdCh4KTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLmFkZF9mcmVlaGFuZF9saW5lKHAsIHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgICAgcHRtbSA9IDEgLyAxMDAgLyBsaW5lLnlfdW5pdC5wZXJfcGl4ZWw7XG4gICAgICAgICAgZHRpbWUgPSAwO1xuICAgICAgICAgIHRoaXMuZ3JhcGggPSBbXTtcbiAgICAgICAgICBwYXRoID0gXCJNMCwwXCI7XG4gICAgICAgICAgaCA9IDA7XG4gICAgICAgICAgd2hpbGUgKHRoaXMudm9sW2hdID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLnB1c2gocGF0aCk7XG4gICAgICAgICAgICBoKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHggPSBsaW5lLm1pbi54O1xuICAgICAgICAgIHkgPSBsaW5lLm1heC55IC0gKGggLyAxMDAgLyBsaW5lLnlfdW5pdC5wZXJfcGl4ZWwpO1xuICAgICAgICAgIHBhdGggPSBcIk1cIiArIHggKyBcIixcIiArIHk7XG4gICAgICAgICAgdm9sbGFzdCA9IDA7XG4gICAgICAgICAgYWRkX3RpbWUgPSAwO1xuICAgICAgICAgIHRoaXMuZ3JhcGgucHVzaChwYXRoKTtcbiAgICAgICAgICB3aGlsZSAoaCA8IHRoaXMudm9sLmxlbmd0aCAmJiB0aGlzLnZvbFtoXSA8IHRoaXMubWF4aW11bV92b2x1bWUpIHtcbiAgICAgICAgICAgIGR2b2wgPSB0aGlzLnZvbFtoXSAtIHZvbGxhc3Q7XG4gICAgICAgICAgICB2b2xsYXN0ID0gdGhpcy52b2xbaF07XG4gICAgICAgICAgICBhZGRfdGltZSA9IGR2b2wgLyBzcGVlZDtcbiAgICAgICAgICAgIHBhdGggKz0gXCJsXCIgKyAoYWRkX3RpbWUgLyBsaW5lLnhfdW5pdC5wZXJfcGl4ZWwpICsgXCIsLVwiICsgcHRtbTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGgucHVzaChwYXRoKTtcbiAgICAgICAgICAgIGgrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgZ3JhcGguYXR0cih7XG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGluZS5hZGRfcG9pbnQoeCwgeSwgZ3JhcGgpO1xuICAgICAgICAgIHAgPSBsaW5lLmZpbmRfcG9pbnRfYXQoeCk7XG4gICAgICAgICAgcmV0dXJuIGxpbmUuYWRkX2ZyZWVoYW5kX2xpbmUocCwgcGF0aCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEdsYXNzLnByb3RvdHlwZS5fY29tcHV0ZV9yID0gZnVuY3Rpb24ocGF0aCwgZm9vdCwgdG90YWxfaGVpZ2h0LCB1bml0KSB7XG4gICAgICAvKlxuICAgICAgR2l2ZW4gYSBwYXRoIGFuZCB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZm9vdCBvbiB0aGUgbWlkLWxpbmUgb2YgdGhlXG4gICAgICBnbGFzcywgY29tcHV0ZSB0aGUgcmFkaXVzIG9mIHRoZSBnbGFzcyBhdCBldmVyeSBoZWlnaHQuXG4gICAgICBcbiAgICAgIHByZTpcbiAgICAgICAgICBwYXRoOiBTVkcgcGF0aCBvZiBjb250b3VyIG9mIHRoZSByaWdodCBzaWRlIG9mIHRoZSBnbGFzc1xuICAgICAgICDiiKcgZm9vdDogcG9pbnQgb2YgdGhlIGZvb3Qgb3IgYm90dG9tIG9mIHRoZSBnbGFzcyBvbiB0aGUgbWlkIGxpbmVcbiAgICAgIFxuICAgICAgcG9zdDpcbiAgICAgICAgICAo4oiAIGg6IDAg4omkIGgg4omkIHRvdGFsX2hlaWdodDogcltoXSA9IHJhZGl1cyBvZiBnbGFzcyBhdCBoZWlnaHQgaCBpbiBtbS8xMCBpbiBtbSkgXG4gICAgICBcbiAgICAgIHJldHVybjpcbiAgICAgICAgICByXG4gICAgICAqL1xuXG4gICAgICB2YXIgaGVpZ2h0LCBsZW5ndGhfb25fcGF0aCwgcG9pbnRfb25fbGVuZ3RoLCByLCBfaSwgX3JlZjtcbiAgICAgIHIgPSBbXTtcbiAgICAgIGxlbmd0aF9vbl9wYXRoID0gMDtcbiAgICAgIGZvciAoaGVpZ2h0ID0gX2kgPSBfcmVmID0gdG90YWxfaGVpZ2h0ICogR2xhc3MuVEVOVEhfT0ZfTU07IF9yZWYgPD0gMCA/IF9pIDw9IDAgOiBfaSA+PSAwOyBoZWlnaHQgPSBfcmVmIDw9IDAgPyArK19pIDogLS1faSkge1xuICAgICAgICBwb2ludF9vbl9sZW5ndGggPSBSYXBoYWVsLmdldFBvaW50QXRMZW5ndGgocGF0aCwgbGVuZ3RoX29uX3BhdGgpO1xuICAgICAgICB3aGlsZSAoTWF0aC5hYnMoZm9vdC55IC0gcG9pbnRfb25fbGVuZ3RoLnkpID4gaGVpZ2h0ICogdW5pdCAvIEdsYXNzLlRFTlRIX09GX01NKSB7XG4gICAgICAgICAgbGVuZ3RoX29uX3BhdGgrKztcbiAgICAgICAgICBwb2ludF9vbl9sZW5ndGggPSBSYXBoYWVsLmdldFBvaW50QXRMZW5ndGgocGF0aCwgbGVuZ3RoX29uX3BhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJbaGVpZ2h0XSA9IE1hdGguYWJzKHBvaW50X29uX2xlbmd0aC54IC0gZm9vdC54KSAvIHVuaXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgR2xhc3MucHJvdG90eXBlLl9kZXRlcm1pbmVfbWF4aW11bSA9IGZ1bmN0aW9uKHRvdGFsX2hlaWdodCwgcm91bmRfdG8pIHtcbiAgICAgIHZhciBmYWN0b3IsIHRvdGFsX3ZvbHVtZTtcbiAgICAgIGlmIChyb3VuZF90byA9PSBudWxsKSB7XG4gICAgICAgIHJvdW5kX3RvID0gXCJjbFwiO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgIERldGVybWluZSB0aGUgbWF4aW11bSB2b2x1bWUgYW5kIGNvcnJlc3BvbmRpbmcgbWF4aW11bSBoZWlnaHQgb2YgdGhpcyBcbiAgICAgIGdsYXNzLiBSb3VuZCB0byB0aGUgZmlyc3QgbWwsIGNsLCBkbCwgb3IgbCBiZWxvdyB0b3RhbF9oZWlnaHQuXG4gICAgICBcbiAgICAgIHByZTpcbiAgICAgICAgICAwIOKJpCB0b3RhbF9oZWlnaHRcbiAgICAgICAg4oinIHJvdW5kX3RvIOKIiCB7bWwsIGNsLCBkbCwgbH1cbiAgICAgIFxuICAgICAgcG9zdDpcbiAgICAgICAgICAwIOKJpCBtYXhpbXVtX2hlaWdodCA8IHRvdGFsX2hlaWdodFxuICAgICAgICDiiKcgbWF4aW11bV92b2x1bWUgPSB2b2x1bWVfYXRfaGVpZ2h0KG1heGltdW1faGVpZ2h0KVxuICAgICAgICDiiKcgaGVpZ2h0X2F0X3ZvbHVtZShtYXhpbXVtX3ZvbHVtZSArIDEgcm91bmRfdG8pID49IHRvdGFsX2hlaWdodFxuICAgICAgKi9cblxuICAgICAgdG90YWxfdm9sdW1lID0gdGhpcy52b2x1bWVfYXRfaGVpZ2h0KHRvdGFsX2hlaWdodCk7XG4gICAgICBmYWN0b3IgPSAxMDtcbiAgICAgIHN3aXRjaCAocm91bmRfdG8pIHtcbiAgICAgICAgY2FzZSBcIm1sXCI6XG4gICAgICAgICAgZmFjdG9yID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNsXCI6XG4gICAgICAgICAgZmFjdG9yID0gMTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkbFwiOlxuICAgICAgICAgIGZhY3RvciA9IDEwMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxcIjpcbiAgICAgICAgICBmYWN0b3IgPSAxMDAwO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXhpbXVtX3ZvbHVtZSA9IE1hdGguZmxvb3IodG90YWxfdm9sdW1lIC8gZmFjdG9yKSAqIGZhY3RvcjtcbiAgICAgIHRoaXMuY3VycmVudF9oZWlnaHQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMubWF4aW11bV9oZWlnaHQgPSB0aGlzLmhlaWdodF9hdF92b2x1bWUodGhpcy5tYXhpbXVtX3ZvbHVtZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBHbGFzcztcblxuICB9KSgpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gR2xhc3M7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8qXG4vL0Agc291cmNlTWFwcGluZ1VSTD1nbGFzcy5tYXBcbiovXG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4zXG4vKlxuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBHbGFzcywgTWVhc3VyZUxpbmUsIFdHbGFzcywgV01lYXN1cmVMaW5lLCBXaWRnZXQsXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICBXaWRnZXQgPSByZXF1aXJlKCcuLi93aWRnZXQnKTtcblxuICBHbGFzcyA9IHJlcXVpcmUoJy4vZ2xhc3MnKTtcblxuICBNZWFzdXJlTGluZSA9IHJlcXVpcmUoJy4vbWVhc3VyZV9saW5lJyk7XG5cbiAgV01lYXN1cmVMaW5lID0gcmVxdWlyZSgnLi93bWVhc3VyZV9saW5lJyk7XG5cbiAgV0dsYXNzID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXR2xhc3MsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBXR2xhc3MoY2FudmFzLCB4LCB5LCBnbGFzcywgc3BlYykge1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMuZ2xhc3MgPSBnbGFzcztcbiAgICAgIHRoaXMuc3BlYyA9IHNwZWMgIT0gbnVsbCA/IHNwZWMgOiB7fTtcbiAgICAgIHRoaXMuc3RvcF9tYW51YWxfZGlmZiA9IF9fYmluZCh0aGlzLnN0b3BfbWFudWFsX2RpZmYsIHRoaXMpO1xuICAgICAgdGhpcy5oaWRlX2xvbmdkcmluayA9IF9fYmluZCh0aGlzLmhpZGVfbG9uZ2RyaW5rLCB0aGlzKTtcbiAgICAgIHRoaXMuc2hvd19sb25nZHJpbmsgPSBfX2JpbmQodGhpcy5zaG93X2xvbmdkcmluaywgdGhpcyk7XG4gICAgICB0aGlzLnN0YXJ0X21hbnVhbF9kaWZmID0gX19iaW5kKHRoaXMuc3RhcnRfbWFudWFsX2RpZmYsIHRoaXMpO1xuICAgICAgV0dsYXNzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHRoaXMuY2FudmFzLCB0aGlzLngsIHRoaXMueSwgdGhpcy5zcGVjKTtcbiAgICAgIHRoaXMucG9pbnRzID0gdGhpcy5fY29tcHV0ZV9wb2ludHModGhpcy5nbGFzcyk7XG4gICAgICB0aGlzLmxlbmd0aHMgPSB0aGlzLl9jb21wdXRlX2xlbmd0aHNfYXRfaGVpZ3RoKCk7XG4gICAgICB0aGlzLl9kcmF3KCk7XG4gICAgICB0aGlzLnBsYWNlX2F0KHRoaXMueCwgdGhpcy55KTtcbiAgICAgIHRoaXMubW92ZV9oYW5kbGVyID0gbnVsbDtcbiAgICAgIHRoaXMuZ3JhcGggPSBudWxsO1xuICAgIH1cblxuICAgIFdHbGFzcy5wcm90b3R5cGUuc3RhcnRfbWFudWFsX2RpZmYgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZ2xhc3NwYW5lLm1vdXNlb3Zlcih0aGlzLnNob3dfbG9uZ2RyaW5rKTtcbiAgICAgIHJldHVybiB0aGlzLmdsYXNzcGFuZS5tb3VzZW91dCh0aGlzLmhpZGVfbG9uZ2RyaW5rKTtcbiAgICB9O1xuXG4gICAgV0dsYXNzLnByb3RvdHlwZS5zaG93X2xvbmdkcmluayA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZWY7XG4gICAgICB0aGlzLmxvbmdkcmluay5zaG93KCk7XG4gICAgICB0aGlzLmxtbC5zaG93KCk7XG4gICAgICB0aGlzLmxibC5zaG93KCk7XG4gICAgICB0aGlzLmxsLnNob3coKTtcbiAgICAgIHRoaXMubGYuc2hvdygpO1xuICAgICAgdGhpcy5sbHAuc2hvdygpO1xuICAgICAgdGhpcy5scnAuc2hvdygpO1xuICAgICAgdGhpcy5tb3ZlX2hhbmRsZXIgPSAoX3JlZiA9IHRoaXMubW92ZV9oYW5kbGVyKSAhPSBudWxsID8gX3JlZiA6IHRoaXMubW92ZV9sb25nZHJpbmsodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcy5nbGFzc3BhbmUubW91c2Vtb3ZlKHRoaXMubW92ZV9oYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgV0dsYXNzLnByb3RvdHlwZS5oaWRlX2xvbmdkcmluayA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5sb25nZHJpbmsuaGlkZSgpO1xuICAgICAgdGhpcy5sbWwuaGlkZSgpO1xuICAgICAgdGhpcy5sYmwuaGlkZSgpO1xuICAgICAgdGhpcy5sbC5oaWRlKCk7XG4gICAgICB0aGlzLmxmLmhpZGUoKTtcbiAgICAgIHRoaXMubGxwLmhpZGUoKTtcbiAgICAgIHRoaXMubHJwLmhpZGUoKTtcbiAgICAgIHRoaXMubGdsLmhpZGUoKTtcbiAgICAgIHJldHVybiB0aGlzLmdwLmhpZGUoKTtcbiAgICB9O1xuXG4gICAgV0dsYXNzLnByb3RvdHlwZS5maXRfcG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgcG9pbnQ7XG4gICAgICBwb2ludCA9IHtcbiAgICAgICAgeDogeCAtIHRoaXMuY2FudmFzLmNhbnZhcy5wYXJlbnROb2RlLm9mZnNldExlZnQsXG4gICAgICAgIHk6IHkgLSB0aGlzLmNhbnZhcy5jYW52YXMucGFyZW50Tm9kZS5vZmZzZXRUb3BcbiAgICAgIH07XG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfTtcblxuICAgIFdHbGFzcy5wcm90b3R5cGUuc2V0X2dyYXBoID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgfTtcblxuICAgIFdHbGFzcy5wcm90b3R5cGUuZGVsX2dyYXBoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ncmFwaCA9IG51bGw7XG4gICAgfTtcblxuICAgIFdHbGFzcy5wcm90b3R5cGUubW92ZV9sb25nZHJpbmsgPSBmdW5jdGlvbihnbGFzc3JlcCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbihlLCB4LCB5KSB7XG4gICAgICAgIHZhciBCRUxPVywgT1ZFUl9HUkFQSF9MRU5HVEgsIGNvbXB1dGVfdm9sLCBnaGVpZ2h0LCBncHgsIGdweSwgZ3ZvbCwgaCwgaGFsZnZvbCwgaGFsZnZvbHB4LCBoaSwgbGVmdCwgbGVuZ3RoLCBsZ2xwYXRoLCBsaW5lLCBwLCBwYXRoLCBwaCwgcHksIHIsIHJpZ2h0LCBybW0sIHZvbDtcbiAgICAgICAgcCA9IGdsYXNzcmVwLmZpdF9wb2ludCh4LCB5KTtcbiAgICAgICAgcHkgPSBwLnkgLSBfdGhpcy5keTtcbiAgICAgICAgcGggPSBnbGFzc3JlcC5wb2ludHMuZm9vdC5yaWdodC55IC0gcHk7XG4gICAgICAgIGggPSBNYXRoLmNlaWwoKHBoIC8gZ2xhc3NyZXAuZ2xhc3MudW5pdCkgKiBHbGFzcy5URU5USF9PRl9NTSk7XG4gICAgICAgIGxlbmd0aCA9IGdsYXNzcmVwLmxlbmd0aHNbaF07XG4gICAgICAgIHJpZ2h0ID0gUmFwaGFlbC5nZXRQb2ludEF0TGVuZ3RoKGdsYXNzcmVwLmdsYXNzLnBhdGgsIGxlbmd0aCk7XG4gICAgICAgIGxlZnQgPSByaWdodC54IC0gMiAqIChyaWdodC54IC0gZ2xhc3NyZXAuZ2xhc3MuZWRnZS54KTtcbiAgICAgICAgciA9IChyaWdodC54IC0gbGVmdCkgLyAyO1xuICAgICAgICBybW0gPSByIC8gZ2xhc3NyZXAuZ2xhc3MudW5pdDtcbiAgICAgICAgaGkgPSBNYXRoLmZsb29yKDIwICogZ2xhc3NyZXAuZ2xhc3MudW5pdCk7XG4gICAgICAgIGNvbXB1dGVfdm9sID0gZnVuY3Rpb24ocm1tLCBoKSB7XG4gICAgICAgICAgdmFyIGhtbTtcbiAgICAgICAgICBobW0gPSBoIC8gZ2xhc3NyZXAuZ2xhc3MudW5pdDtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLlBJICogTWF0aC5wb3cocm1tLCAyKSAqIGhtbSAvIDEwMDApO1xuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAoKGNvbXB1dGVfdm9sKHJtbSwgaGkpICUgMikgIT09IDAgJiYgKGNvbXB1dGVfdm9sKHJtbSwgaGkpICUgMTApICE9PSA1KSB7XG4gICAgICAgICAgaGkrKztcbiAgICAgICAgfVxuICAgICAgICB2b2wgPSBjb21wdXRlX3ZvbChybW0sIGhpKTtcbiAgICAgICAgQkVMT1cgPSAxMCAqIGdsYXNzcmVwLmdsYXNzLnVuaXQ7XG4gICAgICAgIGlmIChfdGhpcy5zcGVjLmRpZmZfZ3JhcGggJiYgX3RoaXMuZ3JhcGgpIHtcbiAgICAgICAgICBPVkVSX0dSQVBIX0xFTkdUSCA9IDEwMDA7XG4gICAgICAgICAgZ2hlaWdodCA9IE1hdGguY2VpbChwaCAvIGdsYXNzcmVwLmdsYXNzLnVuaXQpO1xuICAgICAgICAgIGd2b2wgPSBfdGhpcy5nbGFzcy52b2x1bWVfYXRfaGVpZ2h0KGdoZWlnaHQpO1xuICAgICAgICAgIGxpbmUgPSBfdGhpcy5ncmFwaC5jb21wdXRlcl9saW5lO1xuICAgICAgICAgIGdweCA9IGxpbmUubWluLnggKyBndm9sIC8gbGluZS54X3VuaXQucGVyX3BpeGVsO1xuICAgICAgICAgIGdweSA9IGxpbmUubWF4LnkgLSAoZ2hlaWdodCAvIDEwKSAvIGxpbmUueV91bml0LnBlcl9waXhlbDtcbiAgICAgICAgICBoYWxmdm9sID0gdm9sIC8gMjtcbiAgICAgICAgICBoYWxmdm9scHggPSBoYWxmdm9sIC8gbGluZS54X3VuaXQucGVyX3BpeGVsO1xuICAgICAgICAgIGxnbHBhdGggPSBcIk1cIiArIGdweCArIFwiLFwiICsgZ3B5ICsgXCJsXCIgKyBoYWxmdm9scHggKyBcIixcIiArICgtaGkgKyBCRUxPVykgKyBcIk1cIiArIGdweCArIFwiLFwiICsgZ3B5ICsgXCJsLVwiICsgaGFsZnZvbHB4ICsgXCIsXCIgKyBCRUxPVztcbiAgICAgICAgICBfdGhpcy5sZ2wuYXR0cih7XG4gICAgICAgICAgICBwYXRoOiBsZ2xwYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3RoaXMubGdsLnNob3coKS50b0Zyb250KCk7XG4gICAgICAgICAgX3RoaXMuZ3AuYXR0cih7XG4gICAgICAgICAgICBjeDogZ3B4LFxuICAgICAgICAgICAgY3k6IGdweVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzLmdwLnNob3coKS50b0Zyb250KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMubGdsLmhpZGUoKTtcbiAgICAgICAgICBfdGhpcy5ncC5oaWRlKCk7XG4gICAgICAgICAgT1ZFUl9HUkFQSF9MRU5HVEggPSAwO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmxmLmF0dHIoe1xuICAgICAgICAgIHg6IGxlZnQgKyBfdGhpcy5keCxcbiAgICAgICAgICB5OiByaWdodC55ICsgX3RoaXMuZHksXG4gICAgICAgICAgd2lkdGg6IHJpZ2h0LnggLSBsZWZ0LFxuICAgICAgICAgIGhlaWdodDogQkVMT1dcbiAgICAgICAgfSk7XG4gICAgICAgIHBhdGggPSBcIk1cIiArIHJpZ2h0LnggKyBcIixcIiArIChyaWdodC55IC0gaGkgKyBCRUxPVykgKyBcIkhcIiArICgtX3RoaXMuZHggKyAxMCk7XG4gICAgICAgIHBhdGggKz0gXCJNXCIgKyByaWdodC54ICsgXCIsXCIgKyAocmlnaHQueSAtIGhpICsgQkVMT1cpICsgXCJoXCIgKyBPVkVSX0dSQVBIX0xFTkdUSDtcbiAgICAgICAgX3RoaXMubG1sLmF0dHIoe1xuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRcIiArIF90aGlzLmR4ICsgXCIsXCIgKyBfdGhpcy5keVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMubG1sLnRvRnJvbnQoKTtcbiAgICAgICAgcGF0aCA9IFwiTVwiICsgcmlnaHQueCArIFwiLFwiICsgKHJpZ2h0LnkgKyBCRUxPVykgKyBcIkhcIiArICgtX3RoaXMuZHggKyAxMCk7XG4gICAgICAgIHBhdGggKz0gXCJNXCIgKyByaWdodC54ICsgXCIsXCIgKyAocmlnaHQueSArIEJFTE9XKSArIFwiaFwiICsgT1ZFUl9HUkFQSF9MRU5HVEg7XG4gICAgICAgIF90aGlzLmxibC5hdHRyKHtcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0XCIgKyBfdGhpcy5keCArIFwiLFwiICsgX3RoaXMuZHlcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmxibC50b0Zyb250KCk7XG4gICAgICAgIHBhdGggPSBcIk1cIiArIHJpZ2h0LnggKyBcIixcIiArIChyaWdodC55ICsgQkVMT1cpICsgXCJ2LVwiICsgKGhpICsgMTApICsgXCJNXCIgKyByaWdodC54ICsgXCIsXCIgKyAocmlnaHQueSArIEJFTE9XKSArIFwiTFwiICsgbGVmdCArIFwiLFwiICsgKHJpZ2h0LnkgKyBCRUxPVykgKyBcInYtXCIgKyAoaGkgKyAxMCk7XG4gICAgICAgIF90aGlzLmxvbmdkcmluay5hdHRyKHtcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0XCIgKyBfdGhpcy5keCArIFwiLFwiICsgX3RoaXMuZHlcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmxscC5hdHRyKHtcbiAgICAgICAgICBjeDogbGVmdCArIF90aGlzLmR4LFxuICAgICAgICAgIGN5OiByaWdodC55ICsgX3RoaXMuZHlcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmxycC5hdHRyKHtcbiAgICAgICAgICBjeDogcmlnaHQueCArIF90aGlzLmR4LFxuICAgICAgICAgIGN5OiByaWdodC55ICsgX3RoaXMuZHlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcy5sbC5hdHRyKHtcbiAgICAgICAgICB0ZXh0OiBcIlwiICsgdm9sICsgXCIgbWxcIixcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidFwiICsgKGxlZnQgKyBfdGhpcy5keCArIDEwKSArIFwiLFwiICsgKHJpZ2h0LnkgLSBoaSArIF90aGlzLmR5IC0gMTAgKyBCRUxPVylcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBXR2xhc3MucHJvdG90eXBlLnN0b3BfbWFudWFsX2RpZmYgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubG9uZ2RyaW5rLmhpZGUoKTtcbiAgICAgIHRoaXMubGdsLmhpZGUoKTtcbiAgICAgIHRoaXMuZ3AuaGlkZSgpO1xuICAgICAgdGhpcy5nbGFzc3BhbmUudW5tb3VzZW1vdmUodGhpcy5tb3ZlX2hhbmRsZXIpO1xuICAgICAgdGhpcy5nbGFzc3BhbmUudW5tb3VzZW92ZXIodGhpcy5zaG93X2xvbmdkcmluayk7XG4gICAgICByZXR1cm4gdGhpcy5nbGFzc3BhbmUudW5tb3VzZW91dCh0aGlzLmhpZGVfbG9uZ2RyaW5rKTtcbiAgICB9O1xuXG4gICAgV0dsYXNzLnByb3RvdHlwZS5maWxsX3RvX2hlaWdodCA9IGZ1bmN0aW9uKGhlaWdodF9pbl9tbSkge1xuICAgICAgLypcbiAgICAgIFVwZGF0ZSB0aGUgZmlsbC1wYXJ0IHRvIGNvcnJlc3BvbmQgdG8gYSB3YXRlciBsZXZlbCBlcXVhbCB0byB0aGUgaGVpZ2h0X2luX21tLlxuICAgICAgKi9cblxuICAgICAgdmFyIGRpYW1ldGVyLCBoZWlnaHQsIGxlZnQsIGxlbmd0aCwgcmlnaHQ7XG4gICAgICBkaWFtZXRlciA9IGZ1bmN0aW9uKGxlbmd0aCwgZ2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKFJhcGhhZWwuZ2V0UG9pbnRBdExlbmd0aChnbGFzcy5wYXRoLCBsZW5ndGgpLnggLSBnbGFzcy5mb290LngpICogMjtcbiAgICAgIH07XG4gICAgICBoZWlnaHQgPSB0aGlzLmdsYXNzLmZvb3QueSAtIChoZWlnaHRfaW5fbW0gKiB0aGlzLmdsYXNzLnVuaXQpO1xuICAgICAgaWYgKGhlaWdodCA8IHRoaXMuZ2xhc3MuYm93bC55KSB7XG4gICAgICAgIHRoaXMucG9pbnRzLndhdGVyX2xldmVsID0ge307XG4gICAgICAgIHRoaXMucG9pbnRzLndhdGVyX2xldmVsLmxlbmd0aCA9IGxlbmd0aCA9IHRoaXMubGVuZ3Roc1toZWlnaHRfaW5fbW0gKiBHbGFzcy5URU5USF9PRl9NTV07XG4gICAgICAgIHRoaXMucG9pbnRzLndhdGVyX2xldmVsLnJpZ2h0ID0gcmlnaHQgPSBSYXBoYWVsLmdldFBvaW50QXRMZW5ndGgodGhpcy5nbGFzcy5wYXRoLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvaW50cy53YXRlcl9sZXZlbC5sZWZ0ID0ge1xuICAgICAgICAgIHg6IHJpZ2h0LnggLSBkaWFtZXRlcihsZW5ndGgsIHRoaXMuZ2xhc3MpLFxuICAgICAgICAgIHk6IHJpZ2h0LnlcbiAgICAgICAgfTtcbiAgICAgICAgcmlnaHQgPSBSYXBoYWVsLnBhdGgyY3VydmUoUmFwaGFlbC5nZXRTdWJwYXRoKHRoaXMuZ2xhc3MucGF0aCwgdGhpcy5wb2ludHMud2F0ZXJfbGV2ZWwubGVuZ3RoLCB0aGlzLnBvaW50cy5ib3dsLmxlbmd0aCkpO1xuICAgICAgICBsZWZ0ID0gdGhpcy5fbWlycm9yX3BhdGhfdmVydGljYWxseShyaWdodCwgdGhpcy5nbGFzcy5ib3dsLngpO1xuICAgICAgICByZXR1cm4gdGhpcy53YXRlcl9sZXZlbC5hdHRyKHtcbiAgICAgICAgICBwYXRoOiByaWdodCArIChcIkhcIiArIHRoaXMucG9pbnRzLmJvd2wubGVmdC54KSArIGxlZnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFdHbGFzcy5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiYXNlLCBib3dsLCBtYXhfbWxfcmVwcmVzZW50YXRpb24sIG1heF94LCBtYXhfeSwgbWF4cG9pbnQ7XG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5fY3JlYXRlX3BhdGhzKCk7XG4gICAgICBiYXNlID0gdGhpcy5jYW52YXMucGF0aCh0aGlzLnBhdGhzLmJhc2UpO1xuICAgICAgYmFzZS5hdHRyKHtcbiAgICAgICAgZmlsbDogJyNhYWEnLFxuICAgICAgICBzdHJva2U6ICdibGFjaycsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiAyXG4gICAgICB9KTtcbiAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKGJhc2UpO1xuICAgICAgdGhpcy53YXRlcl9sZXZlbCA9IHRoaXMuY2FudmFzLnBhdGgoXCJNMCwwXCIpO1xuICAgICAgdGhpcy53YXRlcl9sZXZlbC5hdHRyKHtcbiAgICAgICAgZmlsbDogJyNhYmYnLFxuICAgICAgICAnZmlsbC1vcGFjaXR5JzogMC40LFxuICAgICAgICBzdHJva2U6ICdub25lJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLndpZGdldHMucHVzaCh0aGlzLndhdGVyX2xldmVsKTtcbiAgICAgIGJvd2wgPSB0aGlzLmNhbnZhcy5wYXRoKHRoaXMucGF0aHMuYm93bCk7XG4gICAgICBib3dsLmF0dHIoe1xuICAgICAgICBzdHJva2U6ICdibGFjaycsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiAyXG4gICAgICB9KTtcbiAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKGJvd2wpO1xuICAgICAgbWF4cG9pbnQgPSBSYXBoYWVsLmdldFBvaW50QXRMZW5ndGgodGhpcy5nbGFzcy5wYXRoLCB0aGlzLmxlbmd0aHNbdGhpcy5nbGFzcy5tYXhpbXVtX2hlaWdodCAqIEdsYXNzLlRFTlRIX09GX01NXSk7XG4gICAgICBtYXhfeCA9IG1heHBvaW50Lng7XG4gICAgICBtYXhfeSA9IG1heHBvaW50Lnk7XG4gICAgICB0aGlzLm1heF9tbCA9IG5ldyBNZWFzdXJlTGluZSh0aGlzLmdsYXNzLm1heGltdW1fdm9sdW1lLCB0aGlzLmdsYXNzLm1heGltdW1faGVpZ2h0LCB0aGlzLmdsYXNzLCB7XG4gICAgICAgIHg6IG1heF94LFxuICAgICAgICB5OiBtYXhfeVxuICAgICAgfSwgJ3JpZ2h0JywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgbWF4X21sX3JlcHJlc2VudGF0aW9uID0gbmV3IFdNZWFzdXJlTGluZSh0aGlzLmNhbnZhcywgbWF4X3gsIG1heF95LCB0aGlzLm1heF9tbCk7XG4gICAgICB0aGlzLndpZGdldHMucHVzaChtYXhfbWxfcmVwcmVzZW50YXRpb24ud2lkZ2V0cyk7XG4gICAgICB0aGlzLmxmID0gdGhpcy5jYW52YXMucmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgIHRoaXMubGYuYXR0cih7XG4gICAgICAgIGZpbGw6ICdvcmFuZ2UnLFxuICAgICAgICAnZmlsbC1vcGFjaXR5JzogMC41LFxuICAgICAgICAnc3Ryb2tlJzogJ25vbmUnXG4gICAgICB9KTtcbiAgICAgIHRoaXMubGYuaGlkZSgpO1xuICAgICAgdGhpcy5sbWwgPSB0aGlzLmNhbnZhcy5wYXRoKFwiTTAsMFwiKTtcbiAgICAgIHRoaXMubG1sLmF0dHIoe1xuICAgICAgICBzdHJva2U6ICdvcmFuZ2UnLFxuICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwLjUsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJy0nXG4gICAgICB9KTtcbiAgICAgIHRoaXMubG1sLmhpZGUoKTtcbiAgICAgIHRoaXMubGJsID0gdGhpcy5jYW52YXMucGF0aChcIk0wLDBcIik7XG4gICAgICB0aGlzLmxibC5hdHRyKHtcbiAgICAgICAgc3Ryb2tlOiAnb3JhbmdlJyxcbiAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMC41LFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICctJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLmxibC5oaWRlKCk7XG4gICAgICB0aGlzLmxvbmdkcmluayA9IHRoaXMuY2FudmFzLnBhdGgoXCJNMCwwXCIpO1xuICAgICAgdGhpcy5sb25nZHJpbmsuYXR0cih7XG4gICAgICAgIHN0cm9rZTogJ29yYW5nZScsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiAzLFxuICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwLjlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb25nZHJpbmsuaGlkZSgpO1xuICAgICAgdGhpcy5sZ2wgPSB0aGlzLmNhbnZhcy5wYXRoKFwiTTAsMFwiKTtcbiAgICAgIHRoaXMubGdsLmF0dHIoe1xuICAgICAgICBzdHJva2U6ICdvcmFuZ2UnLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMyxcbiAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMC45XG4gICAgICB9KTtcbiAgICAgIHRoaXMubGdsLmhpZGUoKTtcbiAgICAgIHRoaXMuZ3AgPSB0aGlzLmNhbnZhcy5jaXJjbGUoMCwgMCwgMik7XG4gICAgICB0aGlzLmdwLmF0dHIoe1xuICAgICAgICBmaWxsOiAnZ3JheSdcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ncC5oaWRlKCk7XG4gICAgICB0aGlzLmxsID0gdGhpcy5jYW52YXMudGV4dCgwLCAwLCBcIjI1MCBtbFwiKTtcbiAgICAgIHRoaXMubGwuYXR0cih7XG4gICAgICAgICdmb250LWZhbWlseSc6ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxMnB0JyxcbiAgICAgICAgJ3RleHQtYW5jaG9yJzogJ3N0YXJ0JyxcbiAgICAgICAgZmlsbDogJ2dyYXknXG4gICAgICB9KTtcbiAgICAgIHRoaXMubGwuaGlkZSgpO1xuICAgICAgdGhpcy5sbHAgPSB0aGlzLmNhbnZhcy5jaXJjbGUoMCwgMCwgMik7XG4gICAgICB0aGlzLmxscC5hdHRyKHtcbiAgICAgICAgZmlsbDogJ2dyYXknXG4gICAgICB9KTtcbiAgICAgIHRoaXMubGxwLmhpZGUoKTtcbiAgICAgIHRoaXMubHJwID0gdGhpcy5jYW52YXMuY2lyY2xlKDAsIDAsIDIpO1xuICAgICAgdGhpcy5scnAuYXR0cih7XG4gICAgICAgIGZpbGw6ICdncmF5J1xuICAgICAgfSk7XG4gICAgICB0aGlzLmxycC5oaWRlKCk7XG4gICAgICB0aGlzLmdsYXNzcGFuZSA9IHRoaXMuY2FudmFzLnBhdGgodGhpcy5wYXRocy5ib3dsKTtcbiAgICAgIHRoaXMuZ2xhc3NwYW5lLmF0dHIoe1xuICAgICAgICBmaWxsOiAnd2hpdGUnLFxuICAgICAgICAnZmlsbC1vcGFjaXR5JzogMCxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDUsXG4gICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0cy5wdXNoKHRoaXMuZ2xhc3NwYW5lKTtcbiAgICB9O1xuXG4gICAgV0dsYXNzLnByb3RvdHlwZS5fY3JlYXRlX3BhdGhzID0gZnVuY3Rpb24oKSB7XG4gICAgICAvKlxuICAgICAgQ3JlYXRlIHRoZSBwYXRoIG9mIHRoZSBwYXJ0IG9mIHRoaXMgZ2xhc3NcbiAgICAgICovXG5cbiAgICAgIHZhciBsZWZ0LCBwYXRocywgcmlnaHQ7XG4gICAgICBwYXRocyA9IHt9O1xuICAgICAgcmlnaHQgPSBSYXBoYWVsLnBhdGgyY3VydmUoUmFwaGFlbC5nZXRTdWJwYXRoKHRoaXMuZ2xhc3MucGF0aCwgdGhpcy5wb2ludHMuYm93bC5sZW5ndGgsIHRoaXMucG9pbnRzLmZvb3QubGVuZ3RoKSk7XG4gICAgICBsZWZ0ID0gdGhpcy5fbWlycm9yX3BhdGhfdmVydGljYWxseShyaWdodCwgdGhpcy5nbGFzcy5mb290LngpO1xuICAgICAgcGF0aHMuYmFzZSA9IHJpZ2h0ICsgKFwiSFwiICsgdGhpcy5wb2ludHMuZm9vdC5sZWZ0LngpICsgbGVmdDtcbiAgICAgIHJpZ2h0ID0gUmFwaGFlbC5wYXRoMmN1cnZlKFJhcGhhZWwuZ2V0U3VicGF0aCh0aGlzLmdsYXNzLnBhdGgsIHRoaXMucG9pbnRzLmVkZ2UubGVuZ3RoLCB0aGlzLnBvaW50cy5ib3dsLmxlbmd0aCkpO1xuICAgICAgbGVmdCA9IHRoaXMuX21pcnJvcl9wYXRoX3ZlcnRpY2FsbHkocmlnaHQsIHRoaXMuZ2xhc3MuZm9vdC54KTtcbiAgICAgIHBhdGhzLmJvd2wgPSByaWdodCArIChcIkhcIiArIHRoaXMucG9pbnRzLmJvd2wubGVmdC54KSArIGxlZnQ7XG4gICAgICByZXR1cm4gcGF0aHM7XG4gICAgfTtcblxuICAgIFdHbGFzcy5wcm90b3R5cGUuX2NvbXB1dGVfZ2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiYXNlLCBib3dsO1xuICAgICAgYmFzZSA9IFJhcGhhZWwucGF0aEJCb3godGhpcy5wYXRocy5iYXNlKTtcbiAgICAgIGJvd2wgPSBSYXBoYWVsLnBhdGhCQm94KHRoaXMucGF0aHMuYm93bCk7XG4gICAgICB0aGlzLmdlb21ldHJ5ID0ge307XG4gICAgICB0aGlzLmdlb21ldHJ5LnRvcCA9IGJvd2wueTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkubGVmdCA9IE1hdGgubWluKGJhc2UueCwgYm93bC54KTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuYm90dG9tID0gYmFzZS55MjtcbiAgICAgIHRoaXMuZ2VvbWV0cnkucmlnaHQgPSBNYXRoLm1heChiYXNlLngyLCBib3dsLmIyKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkud2lkdGggPSBNYXRoLm1heChiYXNlLndpZHRoLCBib3dsLndpZHRoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuaGVpZ2h0ID0gYmFzZS5oZWlnaHQgKyBib3dsLmhlaWdodDtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmNlbnRlciA9IHtcbiAgICAgICAgeDogKHRoaXMuZ2VvbWV0cnkucmlnaHQgLSB0aGlzLmdlb21ldHJ5LmxlZnQpIC8gMiArIHRoaXMuZ2VvbWV0cnkubGVmdCxcbiAgICAgICAgeTogKHRoaXMuZ2VvbWV0cnkuYm90dG9tIC0gdGhpcy5nZW9tZXRyeS50b3ApIC8gMiArIHRoaXMuZ2VvbWV0cnkudG9wXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBXR2xhc3MucHJvdG90eXBlLl9jb21wdXRlX3BvaW50cyA9IGZ1bmN0aW9uKGdsYXNzKSB7XG4gICAgICAvKlxuICAgICAgQ29tcHV0ZSBwb2ludHMsIGxlbmd0aHMsIGFuZCBwYXRocyBiZXR3ZWVuIHBvaW50cyBmb3IgdGhlIGVkZ2UsIGZvb3QsIHN0ZW0sIGFuZCBib3dsXG4gICAgICAqL1xuXG4gICAgICB2YXIgZGlhbWV0ZXIsIGxlbmd0aCwgbGluZSwgcG9pbnRzLCByaWdodCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICBkaWFtZXRlciA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoUmFwaGFlbC5nZXRQb2ludEF0TGVuZ3RoKGdsYXNzLnBhdGgsIGxlbmd0aCkueCAtIGdsYXNzLmZvb3QueCkgKiAyO1xuICAgICAgfTtcbiAgICAgIHBvaW50cyA9IHt9O1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIF9yZWYgPSBbJ2VkZ2UnLCAnYm93bCcsICdzdGVtJywgJ2Zvb3QnXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBsaW5lID0gX3JlZltfaV07XG4gICAgICAgIHBvaW50c1tsaW5lXSA9IHt9O1xuICAgICAgICBwb2ludHNbbGluZV0ubGVuZ3RoID0gbGVuZ3RoID0gdGhpcy5fbGVuZ3RoX2F0X3koZ2xhc3MucGF0aCwgZ2xhc3NbbGluZV0ueSwgbGVuZ3RoKTtcbiAgICAgICAgcG9pbnRzW2xpbmVdLnJpZ2h0ID0gcmlnaHQgPSBSYXBoYWVsLmdldFBvaW50QXRMZW5ndGgoZ2xhc3MucGF0aCwgbGVuZ3RoKTtcbiAgICAgICAgcG9pbnRzW2xpbmVdLmxlZnQgPSB7XG4gICAgICAgICAgeDogcmlnaHQueCAtIGRpYW1ldGVyKGxlbmd0aCksXG4gICAgICAgICAgeTogcmlnaHQueVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9O1xuXG4gICAgV0dsYXNzLnByb3RvdHlwZS5fY29tcHV0ZV9sZW5ndGhzX2F0X2hlaWd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhlaWdodCwgaGVpZ2h0X2luX3BpeGVscywgbGVuZ3RoLCBsZW5ndGhzLCBtYXhfbGVuZ3RoO1xuICAgICAgbGVuZ3RocyA9IFtdO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIG1heF9sZW5ndGggPSBSYXBoYWVsLmdldFRvdGFsTGVuZ3RoKHRoaXMuZ2xhc3MucGF0aCk7XG4gICAgICBoZWlnaHQgPSB0aGlzLmdsYXNzLmhlaWdodF9pbl9tbSAqIEdsYXNzLlRFTlRIX09GX01NO1xuICAgICAgd2hpbGUgKGhlaWdodCA+IDApIHtcbiAgICAgICAgaGVpZ2h0X2luX3BpeGVscyA9IHRoaXMuZ2xhc3MuZm9vdC55IC0gKChoZWlnaHQgKiB0aGlzLmdsYXNzLnVuaXQpIC8gR2xhc3MuVEVOVEhfT0ZfTU0pO1xuICAgICAgICB3aGlsZSAobGVuZ3RoIDwgbWF4X2xlbmd0aCAmJiBSYXBoYWVsLmdldFBvaW50QXRMZW5ndGgodGhpcy5nbGFzcy5wYXRoLCBsZW5ndGgpLnkgPCBoZWlnaHRfaW5fcGl4ZWxzKSB7XG4gICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3Roc1toZWlnaHRdID0gbGVuZ3RoO1xuICAgICAgICBoZWlnaHQtLTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aHNbMF0gPSB0aGlzLnBvaW50cy5mb290Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGhzO1xuICAgIH07XG5cbiAgICBXR2xhc3MucHJvdG90eXBlLl9sZW5ndGhfYXRfeSA9IGZ1bmN0aW9uKHBhdGgsIHksIHN0YXJ0KSB7XG4gICAgICB2YXIgbGVuZ3RoLCBtYXhfbGVuZ3RoO1xuICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgICAgRmluZCB0aGUgbGVuZ3RoIG9uIHRoZSBwYXRoIHRoZSBwYXRoIGhhdCBpbnRlcnNlY3RzIHRoZSBob3Jpem9udGFsIGxpbmUgYXQgeVxuICAgICAgKi9cblxuICAgICAgbGVuZ3RoID0gc3RhcnQ7XG4gICAgICBtYXhfbGVuZ3RoID0gUmFwaGFlbC5nZXRUb3RhbExlbmd0aChwYXRoKTtcbiAgICAgIHdoaWxlIChsZW5ndGggPCBtYXhfbGVuZ3RoICYmIFJhcGhhZWwuZ2V0UG9pbnRBdExlbmd0aChwYXRoLCBsZW5ndGgpLnkgPCB5KSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9O1xuXG4gICAgV0dsYXNzLnByb3RvdHlwZS5fbWlycm9yX3BhdGhfdmVydGljYWxseSA9IGZ1bmN0aW9uKHBhdGgsIHhfbGluZSkge1xuICAgICAgLypcbiAgICAgICovXG5cbiAgICAgIHZhciBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBjcGF0aCwgY3BhdGhzZWdzLCBtaXJyb3IsIG1pcnJvcl94LCBtaXJyb3JsaXN0LCBzZWdtZW50LCB4LCB5LCBfaSwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZWYyLCBfcmVmMztcbiAgICAgIG1pcnJvcl94ID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4geF9saW5lIC0gTWF0aC5hYnMoeF9saW5lIC0geCk7XG4gICAgICB9O1xuICAgICAgY3BhdGggPSBSYXBoYWVsLnBhdGgyY3VydmUocGF0aCk7XG4gICAgICBjcGF0aHNlZ3MgPSBSYXBoYWVsLnBhcnNlUGF0aFN0cmluZyhjcGF0aCk7XG4gICAgICBtaXJyb3IgPSBcIlwiO1xuICAgICAgbWlycm9ybGlzdCA9IFtdO1xuICAgICAgX3JlZiA9IGNwYXRoc2Vnc1swXS5zbGljZSgxLCAzKSwgeCA9IF9yZWZbMF0sIHkgPSBfcmVmWzFdO1xuICAgICAgX3JlZjEgPSBjcGF0aHNlZ3Muc2xpY2UoMSwgK2NwYXRoc2Vncy5sZW5ndGggKyAxIHx8IDllOSk7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHNlZ21lbnQgPSBfcmVmMVtfaV07XG4gICAgICAgIF9yZWYyID0gc2VnbWVudC5zbGljZSgxLCA1KSwgY3AxeCA9IF9yZWYyWzBdLCBjcDF5ID0gX3JlZjJbMV0sIGNwMnggPSBfcmVmMlsyXSwgY3AyeSA9IF9yZWYyWzNdO1xuICAgICAgICBtaXJyb3JsaXN0LnB1c2goW21pcnJvcl94KGNwMngpLCBjcDJ5LCBtaXJyb3JfeChjcDF4KSwgY3AxeSwgbWlycm9yX3goeCksIHldKTtcbiAgICAgICAgX3JlZjMgPSBzZWdtZW50LnNsaWNlKDUsIDcpLCB4ID0gX3JlZjNbMF0sIHkgPSBfcmVmM1sxXTtcbiAgICAgIH1cbiAgICAgIG1pcnJvciA9ICgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZWY0LCBfcmVzdWx0cztcbiAgICAgICAgX3JlZjQgPSBtaXJyb3JsaXN0LnJldmVyc2UoKTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjQubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IF9yZWY0W19qXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKCdDJyArIHNlZ21lbnQuam9pbihcIixcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpLmpvaW4oXCJcIik7XG4gICAgICByZXR1cm4gbWlycm9yO1xuICAgIH07XG5cbiAgICByZXR1cm4gV0dsYXNzO1xuXG4gIH0pKFdpZGdldCk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBXR2xhc3M7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8qXG4vL0Agc291cmNlTWFwcGluZ1VSTD13Z2xhc3MubWFwXG4qL1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuM1xuLypcblxuKGMpIDIwMTIsIEh1dWIgZGUgQmVlciwgSC5ULmRlLkJlZXJAZ21haWwuY29tXG4qL1xuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIFdpZGdldDtcblxuICBXaWRnZXQgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gV2lkZ2V0KGNhbnZhcywgeCwgeSwgc3BlYykge1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMuc3BlYyA9IHNwZWMgIT0gbnVsbCA/IHNwZWMgOiB7fTtcbiAgICAgIHRoaXMud2lkZ2V0cyA9IHRoaXMuY2FudmFzLnNldCgpO1xuICAgICAgdGhpcy5keCA9IHRoaXMuZHkgPSAwO1xuICAgIH1cblxuICAgIFdpZGdldC5wcm90b3R5cGUucGxhY2VfYXQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAvKlxuICAgICAgUGxhY2UgdGhpcyB3aWRnZXQgYXQgY28tb3JkaW5hdGVzIHggYW4geVxuICAgICAgKi9cblxuICAgICAgdGhpcy5fY29tcHV0ZV9nZW9tZXRyeSgpO1xuICAgICAgdGhpcy5keCA9IHggLSB0aGlzLmdlb21ldHJ5LmxlZnQ7XG4gICAgICB0aGlzLmR5ID0geSAtIHRoaXMuZ2VvbWV0cnkudG9wO1xuICAgICAgdGhpcy53aWRnZXRzLnRyYW5zZm9ybShcIi4uLnRcIiArIHRoaXMuZHggKyBcIixcIiArIHRoaXMuZHkpO1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLl9jb21wdXRlX2dlb21ldHJ5KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLypcbiAgICAgIERyYXcgdGhpcyB3aWRnZXQuIFZpcnR1YWwgbWV0aG9kIHRvIGJlIG92ZXJsb2FkZWQgYnkgYWxsIHN1YmNsYXNzZXMgb2YgXG4gICAgICBXaWRnZXQuIEFsbCBzaGFwZXMgZHJhd24gYXJlIGFkZGVkIHRvIHRoZSBsaXN0IG9mIHdpZGdldHNcbiAgICAgICovXG5cbiAgICB9O1xuXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5fY29tcHV0ZV9nZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLypcbiAgICAgIENvbXB1dGUgdGhlIGxlZnQsIHRvcCwgYm90dG9tLCByaWdodCwgd2lkdGgsIGhlaWdodCwgYW5kIGNlbnRlciBvZiB0aGlzIFxuICAgICAgd2lkZ2V0IGdpdmVuIGl0cyB0b3AtbGVmdCBjb3JuZXIgKHgsIHkpLiBcbiAgICAgIFxuICAgICAgVGhpcyBkb2VzIG5vdCB3b3JrIHdpdGggcGF0aHMgdGhhdCBkbyBub3Qgc3RhcnQgYXQgKDAsMClcbiAgICAgICovXG5cbiAgICAgIHZhciBiYm94O1xuICAgICAgYmJveCA9IHRoaXMud2lkZ2V0cy5nZXRCQm94KCk7XG4gICAgICB0aGlzLmdlb21ldHJ5ID0ge307XG4gICAgICB0aGlzLmdlb21ldHJ5LndpZHRoID0gYmJveC53aWR0aDtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuaGVpZ2h0ID0gYmJveC5oZWlnaHQ7XG4gICAgICB0aGlzLmdlb21ldHJ5LnRvcCA9IGJib3gueTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkubGVmdCA9IGJib3gueDtcbiAgICAgIHRoaXMuZ2VvbWV0cnkucmlnaHQgPSBiYm94LngyO1xuICAgICAgdGhpcy5nZW9tZXRyeS5ib3R0b20gPSBiYm94LnkyO1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuY2VudGVyID0ge1xuICAgICAgICB4OiAodGhpcy5nZW9tZXRyeS5yaWdodCAtIHRoaXMuZ2VvbWV0cnkubGVmdCkgLyAyICsgdGhpcy5nZW9tZXRyeS5sZWZ0LFxuICAgICAgICB5OiAodGhpcy5nZW9tZXRyeS5ib3R0b20gLSB0aGlzLmdlb21ldHJ5LnRvcCkgLyAyICsgdGhpcy5nZW9tZXRyeS50b3BcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiBXaWRnZXQ7XG5cbiAgfSkoKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFdpZGdldDtcblxufSkuY2FsbCh0aGlzKTtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPXdpZGdldC5tYXBcbiovXG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4zXG4vKlxuIChjKSAyMDEyLCBIdXViIGRlIEJlZXIsIEguVC5kZS5CZWVyQGdtYWlsLmNvbVxuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBNZWFzdXJlTGluZTtcblxuICBNZWFzdXJlTGluZSA9IChmdW5jdGlvbigpIHtcbiAgICBNZWFzdXJlTGluZS5FUFNJTE9OID0gMC4wMTtcblxuICAgIE1lYXN1cmVMaW5lLnByb3RvdHlwZS50b19qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXhwb3J0X29iamVjdDtcbiAgICAgIGV4cG9ydF9vYmplY3QgPSB7XG4gICAgICAgIHZvbHVtZTogdGhpcy52b2x1bWUsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgIGluaXRpYWxfcG9zaXRpb246IHRoaXMuaW5pdGlhbF9wb3NpdGlvbixcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiB0aGlzLnBvc2l0aW9uLngsXG4gICAgICAgICAgeTogdGhpcy5wb3NpdGlvbi55XG4gICAgICAgIH0sXG4gICAgICAgIHNpZGU6IHRoaXMuc2lkZSxcbiAgICAgICAgbW92YWJsZTogdGhpcy5tb3ZhYmxlLFxuICAgICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXhwb3J0X29iamVjdCk7XG4gICAgfTtcblxuICAgIE1lYXN1cmVMaW5lLnByb3RvdHlwZS5mcm9tX2pzb24gPSBmdW5jdGlvbihtbGpzb24pIHtcbiAgICAgIHRoaXMudm9sdW1lID0gbWxqc29uLnZvbHVtZTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWxqc29uLmhlaWdodDtcbiAgICAgIHRoaXMuaW5pdGlhbF9wb3NpdGlvbiA9IG1sanNvbi5pbml0aWFsX3Bvc2l0aW9uO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IG1sanNvbi5wb3NpdGlvbjtcbiAgICAgIHRoaXMuc2lkZSA9IG1sanNvbi5zaWRlO1xuICAgICAgdGhpcy5tb3ZhYmxlID0gbWxqc29uLm1vdmFibGU7XG4gICAgICByZXR1cm4gdGhpcy52aXNpYmxlID0gbWxqc29uLnZpc2libGU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIE1lYXN1cmVMaW5lKHZvbHVtZSwgaGVpZ2h0LCBnbGFzcywgaW5pdGlhbF9wb3NpdGlvbiwgc2lkZSwgdmlzaWJsZSwgbW92YWJsZSkge1xuICAgICAgdGhpcy52b2x1bWUgPSB2b2x1bWU7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuZ2xhc3MgPSBnbGFzcztcbiAgICAgIHRoaXMuaW5pdGlhbF9wb3NpdGlvbiA9IGluaXRpYWxfcG9zaXRpb24gIT0gbnVsbCA/IGluaXRpYWxfcG9zaXRpb24gOiB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAtMVxuICAgICAgfTtcbiAgICAgIHRoaXMuc2lkZSA9IHNpZGUgIT0gbnVsbCA/IHNpZGUgOiAncmlnaHQnO1xuICAgICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZSAhPSBudWxsID8gdmlzaWJsZSA6IGZhbHNlO1xuICAgICAgdGhpcy5tb3ZhYmxlID0gbW92YWJsZSAhPSBudWxsID8gbW92YWJsZSA6IHRydWU7XG4gICAgICB0aGlzLnNldF9wb3NpdGlvbih0aGlzLmluaXRpYWxfcG9zaXRpb24pO1xuICAgIH1cblxuICAgIE1lYXN1cmVMaW5lLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLypcbiAgICAgICovXG5cbiAgICAgIHJldHVybiB0aGlzLnNldF9wb3NpdGlvbih0aGlzLmluaXRpYWxfcG9zaXRpb24pO1xuICAgIH07XG5cbiAgICBNZWFzdXJlTGluZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBNZWFzdXJlTGluZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgfTtcblxuICAgIE1lYXN1cmVMaW5lLnByb3RvdHlwZS5zZXRfcG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgLypcbiAgICAgIFNldCB0aGUgcG9zaXRpb24gb2YgdGhpcyBtZWFzdXJlIGxpbmUuIFBvc2l0aW9uIGlzIGEgcG9pbnQgKHgsIHkpLiBTdWJzZXF1ZW50bHkgdGhlIGhlaWdodCBpbiBtbSBjYW4gYmUgY29tcHV0ZWQuXG4gICAgICAqL1xuXG4gICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICByZXR1cm4gdGhpcy5oZWlnaHQgPSAodGhpcy5nbGFzcy5mb290LnkgLSB0aGlzLnBvc2l0aW9uLnkpIC8gdGhpcy5nbGFzcy51bml0O1xuICAgIH07XG5cbiAgICBNZWFzdXJlTGluZS5wcm90b3R5cGUuaXNfY29ycmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLypcbiAgICAgIElzIHRoaXMgbWVhc3VyZSBsaW5lIG9uIHRoZSBjb3JyZWN0IGhlaWdodCBvbiB0aGUgZ2xhc3M/IFRoYXQgaXM6IGlzIHRoZSBlcnJvciBzbWFsbGVyIHRoYW4gZXBzaWxvbj9cbiAgICAgICovXG5cbiAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmVycm9yKSA8PSBNZWFzdXJlTGluZS5FUFNJTE9OO1xuICAgIH07XG5cbiAgICBNZWFzdXJlTGluZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8qXG4gICAgICBUaGUgZGlzdGFuY2Ugb2YgdGhpcyBtZWFzdXJlIGxpbmUgdG8gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gbW0uIEEgbmVnYXRpdmUgZXJyb3IgbWVhbnMgaXQgaXMgdG9vIGhpZ2h0LCBhIHBvc2l0aXZlIGRpc3RhbmNlIHRoYXQgaXQgaXMgdG9vIGxvd1xuICAgICAgKi9cblxuICAgICAgcmV0dXJuICh0aGlzLmdsYXNzLmhlaWdodF9hdF92b2x1bWUodGhpcy52b2x1bWUpKSAtIHRoaXMuaGVpZ2h0O1xuICAgIH07XG5cbiAgICByZXR1cm4gTWVhc3VyZUxpbmU7XG5cbiAgfSkoKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IE1lYXN1cmVMaW5lO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vKlxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9bWVhc3VyZV9saW5lLm1hcFxuKi9cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjNcbi8qXG4oYykgMjAxMiwgSHV1YiBkZSBCZWVyLCBILlQuZGUuQmVlckBnbWFpbC5jb21cbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgTWVhc3VyZUxpbmUsIFdNZWFzdXJlTGluZSwgV2lkZ2V0LFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgV2lkZ2V0ID0gcmVxdWlyZSgnLi4vd2lkZ2V0Jyk7XG5cbiAgTWVhc3VyZUxpbmUgPSByZXF1aXJlKCcuL21lYXN1cmVfbGluZScpO1xuXG4gIFdNZWFzdXJlTGluZSA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV01lYXN1cmVMaW5lLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gV01lYXN1cmVMaW5lKGNhbnZhcywgeCwgeSwgbWwsIGZvb3QsIHNwZWMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgdGhpcy5tbCA9IG1sO1xuICAgICAgdGhpcy5mb290ID0gZm9vdDtcbiAgICAgIHRoaXMuc3BlYyA9IHNwZWMgIT0gbnVsbCA/IHNwZWMgOiB7fTtcbiAgICAgIHRoaXMuZW5kID0gX19iaW5kKHRoaXMuZW5kLCB0aGlzKTtcbiAgICAgIHRoaXMuc3RhcnQgPSBfX2JpbmQodGhpcy5zdGFydCwgdGhpcyk7XG4gICAgICB0aGlzLmRyYWcgPSBfX2JpbmQodGhpcy5kcmFnLCB0aGlzKTtcbiAgICAgIFdNZWFzdXJlTGluZS5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCB0aGlzLmNhbnZhcywgdGhpcy54LCB0aGlzLnksIHRoaXMuc3BlYyk7XG4gICAgICB0aGlzLl9kcmF3KCk7XG4gICAgICBpZiAodGhpcy5tbC5tb3ZhYmxlKSB7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5tb3VzZW92ZXIoZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5ib3JkZXIuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiAnZ29sZCcsXG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogMC4yNSxcbiAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDAuNzUsXG4gICAgICAgICAgICBjdXJzb3I6ICdtb3ZlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53aWRnZXRzLm1vdXNlb3V0KGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuYm9yZGVyLmF0dHIoe1xuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMCxcbiAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgZmlsbDogJ3doaXRlJyxcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndpZGdldHMuZHJhZyh0aGlzLmRyYWcsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBXTWVhc3VyZUxpbmUucHJvdG90eXBlLmRyYWcgPSBmdW5jdGlvbihkeCwgZHksIHgsIHksIGUpIHtcbiAgICAgIHZhciB0eCwgdHk7XG4gICAgICB0eCA9IE1hdGguZmxvb3IoZHggLSB0aGlzLmRwby54KTtcbiAgICAgIHR5ID0gTWF0aC5mbG9vcihkeSAtIHRoaXMuZHBvLnkpO1xuICAgICAgdGhpcy54ICs9IHR4O1xuICAgICAgdGhpcy55ICs9IHR5O1xuICAgICAgdGhpcy53aWRnZXRzLnRyYW5zZm9ybShcIi4uLnRcIiArIHR4ICsgXCIsXCIgKyB0eSk7XG4gICAgICB0aGlzLmRwbyA9IHtcbiAgICAgICAgeDogZHgsXG4gICAgICAgIHk6IGR5XG4gICAgICB9O1xuICAgICAgdGhpcy5fY29tcHV0ZV9nZW9tZXRyeSgpO1xuICAgICAgdGhpcy5tbC5wb3NpdGlvbi54ID0gdGhpcy54O1xuICAgICAgdGhpcy5tbC5wb3NpdGlvbi55ID0gdGhpcy55O1xuICAgICAgcmV0dXJuIHRoaXMubWwuZ2xhc3MuY2hhbmdlX21lYXN1cmVfbGluZSh0aGlzLm1sLnZvbHVtZSwgKHRoaXMuZm9vdCAtIHRoaXMueSkgLyB0aGlzLm1sLmdsYXNzLnVuaXQpO1xuICAgIH07XG5cbiAgICBXTWVhc3VyZUxpbmUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZGdldHMuc2hvdygpO1xuICAgIH07XG5cbiAgICBXTWVhc3VyZUxpbmUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZGdldHMuaGlkZSgpO1xuICAgIH07XG5cbiAgICBXTWVhc3VyZUxpbmUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIHRoaXMuZHBvID0gKF9yZWYgPSB0aGlzLmRwbykgIT0gbnVsbCA/IF9yZWYgOiB7fTtcbiAgICAgIHRoaXMuZHBvID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuYm9yZGVyLmF0dHIoe1xuICAgICAgICAnZmlsbCc6ICdnb2xkJyxcbiAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAuMDVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBXTWVhc3VyZUxpbmUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYm9yZGVyLmF0dHIoe1xuICAgICAgICAnZmlsbCc6ICd3aGl0ZScsXG4gICAgICAgICdmaWxsLW9wYWNpdHknOiAwXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgV01lYXN1cmVMaW5lLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIEJFTkRJTkVTUywgTEFCRUxTS0lQLCBUSUNLV0lEVEgsIGJib3gsIGxhYmVsLCBsYWJlbGxlZnQsIHRpY2ssIHRpY2twYXRoLCBfcmVmLCBfcmVmMSwgX3JlZjIsIF9yZWYzLCBfcmVmNDtcbiAgICAgIFRJQ0tXSURUSCA9IChfcmVmID0gdGhpcy5zcGVjWyd0aGlja3dpZHRoJ10pICE9IG51bGwgPyBfcmVmIDogMTA7XG4gICAgICBMQUJFTFNLSVAgPSAoX3JlZjEgPSB0aGlzLnNwZWNbJ2xhYmVsc2tpcCddKSAhPSBudWxsID8gX3JlZjEgOiA1O1xuICAgICAgQkVORElORVNTID0gNjtcbiAgICAgIHRoaXMuYmVuZCA9IChfcmVmMiA9IHRoaXMuc3BlYy5iZW5kKSAhPSBudWxsID8gX3JlZjIgOiBmYWxzZTtcbiAgICAgIHN3aXRjaCAodGhpcy5tbC5zaWRlKSB7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBpZiAodGhpcy5iZW5kKSB7XG4gICAgICAgICAgICB0aWNrcGF0aCA9IFwiTVwiICsgdGhpcy5tbC5wb3NpdGlvbi54ICsgXCIsXCIgKyB0aGlzLm1sLnBvc2l0aW9uLnkgKyBcImMwLFwiICsgMiArIFwiLC1cIiArIEJFTkRJTkVTUyArIFwiLFwiICsgQkVORElORVNTICsgXCIsLVwiICsgVElDS1dJRFRIICsgXCIsXCIgKyBCRU5ESU5FU1M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpY2twYXRoID0gXCJNXCIgKyB0aGlzLm1sLnBvc2l0aW9uLnggKyBcIixcIiArIHRoaXMubWwucG9zaXRpb24ueSArIFwiaC1cIiArIFRJQ0tXSURUSDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGljayA9IHRoaXMuY2FudmFzLnBhdGgodGlja3BhdGgpO1xuICAgICAgICAgIGxhYmVsID0gdGhpcy5jYW52YXMudGV4dCgwLCAwLCBcIlwiICsgdGhpcy5tbC52b2x1bWUgKyBcIiBtbFwiKTtcbiAgICAgICAgICBsYWJlbC5hdHRyKHtcbiAgICAgICAgICAgICdmb250LWZhbWlseSc6IChfcmVmMyA9IHRoaXMuc3BlY1snZm9udC1mYW1pbHknXSkgIT0gbnVsbCA/IF9yZWYzIDogJ3NhbnMtc2VyaWYnLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IChfcmVmNCA9IHRoaXMuc3BlY1snZm9udC1zaXplJ10pICE9IG51bGwgPyBfcmVmNCA6IDEyLFxuICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogJ3N0YXJ0J1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJib3ggPSBsYWJlbC5nZXRCQm94KCk7XG4gICAgICAgICAgbGFiZWxsZWZ0ID0gdGhpcy5tbC5wb3NpdGlvbi54IC0gTEFCRUxTS0lQIC0gYmJveC53aWR0aCAtIFRJQ0tXSURUSDtcbiAgICAgICAgICBpZiAodGhpcy5iZW5kKSB7XG4gICAgICAgICAgICBsYWJlbC5hdHRyKHtcbiAgICAgICAgICAgICAgeDogbGFiZWxsZWZ0LFxuICAgICAgICAgICAgICB5OiB0aGlzLm1sLnBvc2l0aW9uLnkgKyBCRU5ESU5FU1NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYWJlbC5hdHRyKHtcbiAgICAgICAgICAgICAgeDogbGFiZWxsZWZ0LFxuICAgICAgICAgICAgICB5OiB0aGlzLm1sLnBvc2l0aW9uLnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiYm94ID0gbGFiZWwuZ2V0QkJveCgpO1xuICAgICAgICAgIHRoaXMuYm9yZGVyID0gdGhpcy5jYW52YXMucmVjdChiYm94LngsIGJib3gueSwgYmJveC53aWR0aCArIFRJQ0tXSURUSCwgYmJveC5oZWlnaHQpO1xuICAgICAgICAgIHRoaXMuYm9yZGVyLmF0dHIoe1xuICAgICAgICAgICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgICAgICAgICAgZmlsbDogJ3doaXRlJyxcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAwLFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMCxcbiAgICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJy4gJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICB0aWNrcGF0aCA9IFwiTVwiICsgdGhpcy5tbC5wb3NpdGlvbi54ICsgXCIsXCIgKyB0aGlzLm1sLnBvc2l0aW9uLnkgKyBcImhcIiArIFRJQ0tXSURUSDtcbiAgICAgIH1cbiAgICAgIHRoaXMud2lkZ2V0cy5wdXNoKHRpY2ssIGxhYmVsLCB0aGlzLmJvcmRlcik7XG4gICAgICBiYm94ID0gdGhpcy53aWRnZXRzLmdldEJCb3goKTtcbiAgICAgIHRoaXMud2lkdGggPSBiYm94LndpZHRoO1xuICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0ID0gYmJveC5oZWlnaHQ7XG4gICAgfTtcblxuICAgIHJldHVybiBXTWVhc3VyZUxpbmU7XG5cbiAgfSkoV2lkZ2V0KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFdNZWFzdXJlTGluZTtcblxufSkuY2FsbCh0aGlzKTtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPXdtZWFzdXJlX2xpbmUubWFwXG4qL1xuIl19
;