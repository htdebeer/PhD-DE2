;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var FLOW_RATE, FlaskFiller, Glass, create_glass, json_glasses, random_color;

  json_glasses = {
    cocktail: '{"path":"M 419 102 l -152 245 l 0 185 c 0 23.25 101 11.75 106 25","foot":{"x":255,"y":557},"stem":{"x":255,"y":532},"bowl":{"x":255,"y":347},"edge":{"x":255,"y":102},"height_in_mm":150,"spec":{"round_max":"cl","mm_from_top":0},"measure_lines":{},"nr_of_measure_lines":0}',
    erlenmeyer: '{"path":"M 307 103 l 0 123 l 100 299 c 10 25 9.5 26 -63 28 l -1 2 l 2 2","foot":{"x":255,"y":557},"stem":{"x":255,"y":555},"bowl":{"x":255,"y":553},"edge":{"x":255,"y":103},"height_in_mm":149,"spec":{"round_max":"cl","mm_from_top":0},"measure_lines":{},"nr_of_measure_lines":0}',
    longdrink: '{"path":"M 339 92 l 0 326 l 0 3 l 0 6","foot":{"x":255,"y":427},"stem":{"x":255,"y":421},"bowl":{"x":255,"y":418},"edge":{"x":255,"y":92},"height_in_mm":110,"spec":{"round_max":"cl","mm_from_top":0},"measure_lines":{},"nr_of_measure_lines":0}',
    longdrink_smal: '{"path":"M 324 179 l 0 332 l 0 22 l 0 24","foot":{"x":255,"y":557},"stem":{"x":255,"y":533},"bowl":{"x":255,"y":511},"edge":{"x":255,"y":179},"height_in_mm":124,"spec":{"round_max":"cl","mm_from_top":5},"measure_lines":{},"nr_of_measure_lines":0}',
    longdrink_breed: '{"path":"M 429 153 l 0 385 l 0 17 l 0 2","foot":{"x":255,"y":557},"stem":{"x":255,"y":555},"bowl":{"x":255,"y":538},"edge":{"x":255,"y":153},"height_in_mm":133,"spec":{"round_max":"cl","mm_from_top":5},"measure_lines":{},"nr_of_measure_lines":0}',
    longdrink_vreemd: '{"path":"M 318 254 l 0 150 l 88 2 l 0 122 l 0 15 l 0 14","foot":{"x":255,"y":557},"stem":{"x":255,"y":543},"bowl":{"x":255,"y":528},"edge":{"x":255,"y":254},"height_in_mm":99,"spec":{"round_max":"cl","mm_from_top":5},"measure_lines":{},"nr_of_measure_lines":0}',
    wijn: '{"path":"M 361 123 c 21 92.75 1 176.25 -90 255 l 0 164 l 89 15","foot":{"x":255,"y":557},"stem":{"x":255,"y":542},"bowl":{"x":255,"y":378},"edge":{"x":255,"y":123},"height_in_mm":143,"spec":{"round_max":"cl","mm_from_top":0},"measure_lines":{},"nr_of_measure_lines":0}',
    rondbodemkolf: '{"path":"M 315 73 l 0 161 c 192 45.75 192 262.25 -4 319 l -13 2 l -10 2","foot":{"x":255,"y":557},"stem":{"x":255,"y":555},"bowl":{"x":255,"y":553},"edge":{"x":255,"y":73},"height_in_mm":159,"spec":{"round_max":"cl","mm_from_top":5},"measure_lines":{},"nr_of_measure_lines":0}',
    cognac: '{"path":"M 346 223 c 24.5 67.75 45 103.25 37 151 c -3 29 -16 78 -118 92 l 0 62 c -4 21.25 73.5 13.75 89 29","foot":{"x":255,"y":557},"stem":{"x":255,"y":528},"bowl":{"x":255,"y":466},"edge":{"x":255,"y":223},"height_in_mm":110,"spec":{"round_max":"cl","mm_from_top":0},"measure_lines":{},"nr_of_measure_lines":0}',
    bier: '{"path":"M 363 253 l 0 94 c 1 16.75 -3 11.25 -12 31 l -25 175 l 0 2 l 0 2","foot":{"x":255,"y":557},"stem":{"x":255,"y":555},"bowl":{"x":255,"y":553},"edge":{"x":255,"y":253},"height_in_mm":100,"spec":{"round_max":"cl","mm_from_top":0},"measure_lines":{},"nr_of_measure_lines":0}'
  };

  Glass = require('./widgets/glass/glass');

  FlaskFiller = require('./microworlds/flaskfiller/flaskfiller');

  random_color = function() {
    var colors, hexes, i;
    hexes = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
    colors = [];
    i = 0;
    while (i < 6) {
      colors.push(hexes[Math.round(Math.random() * (hexes.length - 1))]);
      i++;
    }
    return "#" + (colors.join(''));
  };

  create_glass = function(json_glasses, name) {
    var glass;
    glass = {
      name: name,
      glass: new Glass(json_glasses[name]),
      color: random_color()
    };
    return glass;
  };

  FLOW_RATE = 20;

  $(document).ready(function() {
    var ff;
    return ff = new FlaskFiller({
      id: 'flaskfiller',
      flow_rate: FLOW_RATE,
      mm_per_pixel: 0.01,
      glasses: [create_glass(json_glasses, 'cocktail')],
      glass_specs: json_glasses,
      hide_graph: true,
      graph: {
        dimensions: {
          width: 700,
          height: 500
        },
        quantities: {
          time: {
            name: 'time',
            label: 'verstreken tijd',
            unit: 'sec',
            step: 1 / FLOW_RATE
          },
          volume: {
            name: 'volume',
            label: 'volume',
            unit: 'ml',
            step: 1
          },
          height: {
            name: 'height',
            label: 'hoogtestijging van het waterpeil',
            unit: 'cm',
            step: 1
          }
        }
      }
    });
  });

}).call(this);

},{"./widgets/glass/glass":2,"./microworlds/flaskfiller/flaskfiller":3}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
glass.coffee version 0.1

Modeling different glasses

(c) 2012 Huub de Beer H.T.de.Beer@gmail.com

Long description
*/


(function() {
  var Glass;

  Glass = (function() {
    Glass.TENTH_OF_MM = 10;

    Glass.prototype.to_json = function() {
      var export_object;
      export_object = {
        path: this.path,
        foot: {
          x: this.foot.x,
          y: this.foot.y
        },
        stem: {
          x: this.stem.x,
          y: this.stem.y
        },
        bowl: {
          x: this.bowl.x,
          y: this.bowl.y
        },
        edge: {
          x: this.edge.x,
          y: this.edge.y
        },
        height_in_mm: this.height_in_mm,
        spec: this.spec
      };
      return JSON.stringify(export_object, null, '  ');
    };

    Glass.prototype.to_full_json = function() {
      var export_object;
      export_object = {
        path: this.path,
        foot: {
          x: this.foot.x,
          y: this.foot.y
        },
        stem: {
          x: this.stem.x,
          y: this.stem.y
        },
        bowl: {
          x: this.bowl.x,
          y: this.bowl.y
        },
        bowl_start: this.bowl_start,
        edge: {
          x: this.edge.x,
          y: this.edge.y
        },
        height_in_mm: this.height_in_mm,
        unit: this.unit,
        spec: this.spec,
        vol: this.vol,
        r: this.r,
        speed: this.speed,
        maximum_height: this.maximum_height,
        maximum_volume: this.maximum_volume,
        maximum_speed: this.maximum_speed
      };
      return JSON.stringify(export_object, null, '  ');
    };

    function Glass(path, foot, stem, bowl, edge, height_in_mm, spec) {
      var import_object, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      if (spec == null) {
        spec = {
          round_max: "cl",
          mm_from_top: 5
        };
      }
      /*
      pre:
          path is the right hand side of the countour of the glass
        ∧ 0 ≤ foot.y 
        ∧ foot.y ≤ stem.y 
        ∧ stem.y ≤ bowl.y
        ∧ bowl.y < edge.y
        ∧ 0 < height_in_mm
      
      post:
          is_empty
      */

      if (arguments.length === 1) {
        import_object = JSON.parse(path);
        this.path = import_object.path;
        this.foot = import_object.foot;
        this.stem = import_object.stem;
        this.bowl = import_object.bowl;
        this.edge = import_object.edge;
        this.height_in_mm = import_object.height_in_mm;
        this.spec = (_ref = import_object != null ? import_object.spec : void 0) != null ? _ref : {
          round_max: "cl",
          mm_from_top: 5
        };
        this.unit = (_ref1 = import_object != null ? import_object.unit : void 0) != null ? _ref1 : Math.abs(this.edge.y - this.foot.y) / this.height_in_mm;
        this.bowl_start = (_ref2 = import_object != null ? import_object.bowl_start : void 0) != null ? _ref2 : this.height_in_mm - (Math.abs(this.bowl.y - this.edge.y) / this.unit);
        this.r = (_ref3 = import_object != null ? import_object.r : void 0) != null ? _ref3 : [];
        if (!(import_object != null ? import_object.r : void 0)) {
          this.r = this._compute_r(this.path, this.foot, this.height_in_mm, this.unit);
        }
        this.vol = (_ref4 = import_object != null ? import_object.vol : void 0) != null ? _ref4 : [];
        this.speed = (_ref5 = import_object != null ? import_object.speed : void 0) != null ? _ref5 : [];
        this.maximum_volume = (_ref6 = import_object != null ? import_object.maximum_volume : void 0) != null ? _ref6 : 0;
        this.maximum_height = (_ref7 = import_object != null ? import_object.maximum_height : void 0) != null ? _ref7 : 0;
        this.maximum_speed = (_ref8 = import_object != null ? import_object.maximum_speed : void 0) != null ? _ref8 : 0;
        if (this.maximum_volume === 0 || this.maximum_height === 0 || this.maximum_speed === 0) {
          this._determine_maximum(this.height_in_mm - this.spec.mm_from_top, this.spec.round_max);
        }
      } else {
        this.path = path;
        this.foot = foot;
        this.stem = stem;
        this.bowl = bowl;
        this.edge = edge;
        this.height_in_mm = height_in_mm;
        this.spec = spec;
        this.unit = Math.abs(this.edge.y - this.foot.y) / this.height_in_mm;
        this.bowl_start = this.height_in_mm - (Math.abs(this.bowl.y - this.edge.y) / this.unit);
        this.r = [];
        this.r = this._compute_r(this.path, this.foot, this.height_in_mm, this.unit);
        this.vol = [];
        this.speed = [];
        this.maximum_volume = 0;
        this.maximum_height = 0;
        this.maximum_speed = 0;
        this._determine_maximum(this.height_in_mm - this.spec.mm_from_top, this.spec.round_max);
      }
      this.make_empty();
    }

    Glass.prototype.volume = function() {
      return this.current_volume;
    };

    Glass.prototype.height = function() {
      return this.current_height / 10;
    };

    Glass.prototype.time = function(flow_rate) {
      return this.current_volume / flow_rate;
    };

    Glass.prototype.to_time = function(vol, flow_rate) {
      return vol / flow_rate;
    };

    Glass.prototype.compute_speed = function() {
      var dh, dvol, h, h_max, v_prev, vol, _results;
      h = 0;
      h_max = this.vol.length - 1;
      while (this.vol[h] === 0) {
        h++;
      }
      this.speed[0] = 0;
      v_prev = 0;
      this.maximum_speed = 0;
      _results = [];
      while (h <= h_max) {
        vol = this.vol[h];
        dh = 0;
        while (h <= h_max && v_prev === vol) {
          h++;
          dh += 0.01;
          vol = this.vol[h];
        }
        dvol = vol - v_prev;
        this.speed[vol] = dh / dvol;
        this.maximum_speed = Math.max(this.maximum_speed, this.speed[vol]);
        v_prev = vol;
        _results.push(h++);
      }
      return _results;
    };

    Glass.prototype.make_empty = function(initial_value) {
      if (initial_value == null) {
        initial_value = 0;
      }
      /*
      Empty this glass 
      
      pre:
          True
      
      post:
          current_height = 0
        ∧ current_volume = 0
      */

      this.current_volume = 0;
      this.current_height = 0;
      this.current_height = this.fill_to_volume(initial_value);
      this.current_height++;
      return this.current_time = 0;
    };

    Glass.prototype.is_empty = function() {
      /*
      Is this glass empty?
      
      pre:
          True
      
      post:
          True
      
      return:
          current_volume = 0
      */

      return this.current_volume === 0;
    };

    Glass.prototype.is_full = function() {
      /*
      Is this glass full?
      
      pre:
          True
      
      post:
          True
      
      return:
          current_volume = maximum_volume
      */

      return this.current_volume === this.maximum_volume;
    };

    Glass.prototype.fill_to_height = function(height) {
      /*
      Fill this glass up to height and return corresponding volume
      
      pre: 
          height, 0 ≤ height ≤ maximum_height
      
      post:
          current_height = height
        ∧ current_volume = volume_at_height(height)
      
      return:
          volume_at_height(height)
      */

      if (height <= this.maximum_height) {
        this.current_height = height;
      } else {
        this.current_height = this.maximum_height;
      }
      this.current_volume = this.volume_at_height(this.current_height);
      return this.current_volume;
    };

    Glass.prototype.fill_to_volume = function(volume) {
      /*
      Fill this glass up to volume and return the corresponding water level height.
      
      pre:
          volume, 0 ≤ volume ≤ maximum_volume
      
      post:
          current_volume = volume
        ∧ current_height = height_at_volume(volume)
      
      return:
          height_at_volume(volume)
      */

      var fill_up;
      fill_up = volume >= this.current_volume;
      if (volume <= this.maximum_volume) {
        this.current_volume = volume;
      } else {
        this.current_volume = this.maximum_volume;
      }
      this.current_height = this.height_at_volume(this.current_volume, true, fill_up);
      return this.current_height;
    };

    Glass.prototype.speed_at_height = function(height) {
      return this.speed[height * Glass.TENTH_OF_MM];
    };

    Glass.prototype.speed_at_volume = function(vol) {
      var h;
      h = height_at_volume(vol);
      return this.speed[h * Glass.TENTH_OF_MM];
    };

    Glass.prototype.volume_at_height = function(height) {
      /*
      Compute the volume of the water in this glass when it is filled up to
      height. Take in account the shape of the glass: only the bowl of the
      glass can be filled.
      
      pre:
          height: water level height in mm
      
      post:
          volume = (∫h: 0 ≤ h ≤ height: πr(h)^2)
      
      return:
          volume in ml
      */

      var HSTEP, dvol, h;
      HSTEP = 0.01;
      h = Math.ceil(height * Glass.TENTH_OF_MM);
      if (this.vol[h] == null) {
        if (h === 0) {
          this.vol[0] = 0;
          this.speed[0] = 0;
        } else {
          if ((0 <= height && height < this.bowl_start)) {
            this.vol[h] = 0 + this.volume_at_height((h - 1) / Glass.TENTH_OF_MM);
            this.speed[h] = 0;
          } else {
            dvol = Math.PI * Math.pow(this.r[h] / Glass.TENTH_OF_MM, 2) * HSTEP;
            this.vol[h] = dvol + this.volume_at_height((h - 1) / Glass.TENTH_OF_MM);
            this.speed[h] = dvol !== 0 ? HSTEP / dvol : 0;
            this.maximum_speed = Math.max(this.maximum_speed, this.speed[h]);
          }
        }
      }
      return this.vol[h];
    };

    Glass.prototype.height_at_volume = function(volume, floor, fill_up) {
      var height, maxheight;
      if (floor == null) {
        floor = true;
      }
      if (fill_up == null) {
        fill_up = true;
      }
      /*
      Compute the height of the water level in this glass when there is volume water in it.
      
      pre:
          0 ≤ volume 
      
      post:
          height = (h: 0 ≤ h ≤ total_height: vol[h + 1] > volume ∧ vol[h-1] < volume)
      
      return:
          height in mm
      */

      if (!fill_up) {
        height = 0;
      } else {
        height = this.current_height * Glass.TENTH_OF_MM;
      }
      maxheight = this.height_in_mm * Glass.TENTH_OF_MM;
      while (!(this.vol[height] > volume || height >= maxheight)) {
        height++;
      }
      if (floor) {
        return Math.floor(height / Glass.TENTH_OF_MM);
      } else {
        return height / Glass.TENTH_OF_MM;
      }
    };

    Glass.prototype.get_fddata = function(flow_rate) {
      var data, height, time, volume;
      data = [];
      volume = 0;
      while (volume < this.maximum_volume) {
        height = (this.height_at_volume(volume, false)) / 10;
        time = volume / flow_rate;
        data.push({
          time: time,
          volume: volume,
          height: height
        });
        volume = volume + 1;
      }
      return data;
    };

    Glass.prototype.get_data = function(flow_rate, from_bowl) {
      var data, h, height, start, time, volume;
      if (from_bowl == null) {
        from_bowl = false;
      }
      data = [];
      h = 0;
      while (this.vol[h] === 0) {
        h++;
      }
      start = h - 1;
      while (h < this.vol.length && this.vol[h] < this.maximum_volume) {
        height = (from_bowl ? h - start : h) / 100;
        volume = this.vol[h];
        time = volume / flow_rate;
        data.push({
          time: time,
          volume: volume,
          height: height
        });
        h++;
      }
      return data;
    };

    Glass.prototype._compute_r = function(path, foot, total_height, unit) {
      /*
      Given a path and the coordinate of the foot on the mid-line of the
      glass, compute the radius of the glass at every height.
      
      pre:
          path: SVG path of contour of the right side of the glass
        ∧ foot: point of the foot or bottom of the glass on the mid line
      
      post:
          (∀ h: 0 ≤ h ≤ total_height: r[h] = radius of glass at height h in mm/10 in mm) 
      
      return:
          r
      */

      var height, length_on_path, point_on_length, r, _i, _ref;
      r = [];
      length_on_path = 0;
      for (height = _i = _ref = total_height * Glass.TENTH_OF_MM; _ref <= 0 ? _i <= 0 : _i >= 0; height = _ref <= 0 ? ++_i : --_i) {
        point_on_length = Raphael.getPointAtLength(path, length_on_path);
        while (Math.abs(foot.y - point_on_length.y) > height * unit / Glass.TENTH_OF_MM) {
          length_on_path++;
          point_on_length = Raphael.getPointAtLength(path, length_on_path);
        }
        r[height] = Math.abs(point_on_length.x - foot.x) / unit;
      }
      return r;
    };

    Glass.prototype._determine_maximum = function(total_height, round_to) {
      var factor, total_volume;
      if (round_to == null) {
        round_to = "cl";
      }
      /*
      Determine the maximum volume and corresponding maximum height of this 
      glass. Round to the first ml, cl, dl, or l below total_height.
      
      pre:
          0 ≤ total_height
        ∧ round_to ∈ {ml, cl, dl, l}
      
      post:
          0 ≤ maximum_height < total_height
        ∧ maximum_volume = volume_at_height(maximum_height)
        ∧ height_at_volume(maximum_volume + 1 round_to) >= total_height
      */

      total_volume = this.volume_at_height(total_height);
      factor = 10;
      switch (round_to) {
        case "ml":
          factor = 1;
          break;
        case "cl":
          factor = 10;
          break;
        case "dl":
          factor = 100;
          break;
        case "l":
          factor = 1000;
      }
      this.maximum_volume = Math.floor(total_volume / factor) * factor;
      this.current_height = 0;
      return this.maximum_height = this.height_at_volume(this.maximum_volume);
    };

    return Glass;

  })();

  module.exports = Glass;

}).call(this);

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var FlaskFiller, GlassTable, Grapher, Simulation;

  GlassTable = require('./glass_table');

  Simulation = require('./simulation');

  Grapher = require('./grapher');

  FlaskFiller = (function() {
    function FlaskFiller(config) {
      var _ref;
      this.config = config;
      this.glasses = (config != null ? config.glasses : void 0) ? config.glasses : [];
      this.container = d3.select("#" + config.id);
      this.simulation_container = this.container.append('figure').attr('id', 'simulatie');
      this.simulation = new Simulation(this, this.simulation_container, config);
      this.table = new GlassTable(this, this.container, config);
      this.graph_container = this.container.append('figure').attr('id', 'grafiek');
      this.graph = new Grapher(this, this.graph_container, config);
      if ((_ref = this.config) != null ? _ref.hide_graph : void 0) {
        this.graph_container.style('display', 'none');
      }
    }

    FlaskFiller.prototype.change_glass = function(glass) {
      var _this = this;
      return function() {
        return _this.table.update_row(glass);
      };
    };

    FlaskFiller.prototype.add = function(glass) {
      this.glasses.push(glass);
      this.table.add_row(glass);
      this.simulation.add_glass(glass);
      return this.graph.add_graph(glass);
    };

    FlaskFiller.prototype.remove = function(glass) {
      this.table.remove_row(glass);
      this.simulation.remove_glass(glass);
      this.graph.remove_graph(glass);
      return this.glasses.splice(this.glasses.indexOf(glass), 1);
    };

    return FlaskFiller;

  })();

  module.exports = FlaskFiller;

}).call(this);

},{"./glass_table":4,"./simulation":5,"./grapher":6}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Grapher;

  Grapher = (function() {
    function Grapher(flaskfiller, container, config) {
      var glass, name, q, _i, _len, _ref, _ref1, _ref2;
      this.flaskfiller = flaskfiller;
      this.config = config;
      this.CONTAINER_DIMENSIONS = {
        width: this.config.graph.dimensions.width,
        height: this.config.graph.dimensions.height
      };
      this.MARGINS = {
        top: 10,
        right: 20,
        left: 60,
        bottom: 60
      };
      this.GRAPH_DIMENSIONS = {
        width: this.CONTAINER_DIMENSIONS.width - this.MARGINS.left - this.MARGINS.right,
        height: this.CONTAINER_DIMENSIONS.height - this.MARGINS.top - this.MARGINS.bottom
      };
      this.QUANTITIES = this.config.graph.quantities;
      this.set_x_quantity('time');
      this.set_y_quantity('height');
      this.step_size = this.QUANTITIES['time'].step;
      this.svg_graph = container.append('svg').attr('width', this.CONTAINER_DIMENSIONS.width).attr('height', this.CONTAINER_DIMENSIONS.height).append('g').attr('transform', "translate(" + this.MARGINS.left + "," + this.MARGINS.top + ")").attr('id', 'graph_container');
      this.glasses = [];
      _ref = this.config.glasses;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        glass = _ref[_i];
        this.add_graph(glass);
      }
      this.graph_settings = container.append('form').classed('form-inline', true);
      this.graph_settings.append('label').text('stapgrootte');
      this.stepsize = this.graph_settings.append('input').attr('id', 'stepsize').classed('input-mini', true).attr('type', 'number').attr('min', '0.01').attr('step', 'any').attr('value', 1).on('change', this.set_step_size());
      this.graph_settings.append('label').text('horizontale as');
      this.select_x = this.graph_settings.append('select').classed('input-mini', true).attr('id', 'x-quantity');
      _ref1 = this.QUANTITIES;
      for (name in _ref1) {
        q = _ref1[name];
        this.select_x.append('option').attr('value', name).text(q.unit);
      }
      this.select_x.on('change', this.change_x_quantity());
      this.graph_settings.append('label').text('verticale as');
      this.select_y = this.graph_settings.append('select').classed('input-mini', true).attr('id', 'y-quantity');
      _ref2 = this.QUANTITIES;
      for (name in _ref2) {
        q = _ref2[name];
        this.select_y.append('option').attr('value', name).text(q.unit);
      }
      this.select_y.on('change', this.change_y_quantity());
    }

    Grapher.prototype.change_y_quantity = function() {
      var _this = this;
      return function() {
        var e, sel;
        e = document.getElementById("y-quantity");
        sel = e.options[e.selectedIndex].value;
        _this.set_y_quantity(sel);
        return _this.redraw_graphs();
      };
    };

    Grapher.prototype.change_x_quantity = function() {
      var _this = this;
      return function() {
        var e, sel;
        e = document.getElementById("x-quantity");
        sel = e.options[e.selectedIndex].value;
        _this.set_x_quantity(sel);
        return _this.redraw_graphs();
      };
    };

    Grapher.prototype.set_step_size = function() {
      var _this = this;
      return function() {
        _this.step_size = parseFloat(d3.select('#stepsize').property('value'));
        return _this.redraw_graphs();
      };
    };

    Grapher.prototype.add_graph = function(glass) {
      glass.graph = {
        name: glass.name,
        data: glass.glass.get_data(this.config.flow_rate),
        color: glass.color,
        toggled: {
          graph: true,
          chart: false,
          tangent: true
        }
      };
      this.glasses.push(glass);
      return this.redraw_graphs();
    };

    Grapher.prototype.redraw_graphs = function() {
      var chart, glass, graph, tangents, _i, _len, _ref, _results;
      this.compute_scales();
      _ref = this.glasses;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        glass = _ref[_i];
        if (glass.graph.toggled.graph) {
          graph = d3.select("#" + glass.name + "-graph");
          if (!graph.empty()) {
            graph.remove();
          }
          this.draw_graph(glass, glass.name);
        }
        if (glass.graph.toggled.chart) {
          chart = d3.select("#" + glass.name + "-chart");
          if (!chart.empty()) {
            chart.remove();
          }
          this.draw_chart(glass, glass.name);
        }
        tangents = d3.select("#" + glass.name + "-tangents");
        if (!tangents.empty()) {
          tangents.remove();
        }
        _results.push(this.draw_tangents(glass, glass.name));
      }
      return _results;
    };

    Grapher.prototype.remove_graph = function(glass) {
      var chart, graph, tangents;
      graph = d3.select("#" + glass.name + "-graph");
      if (!graph.empty()) {
        graph.remove();
      }
      chart = d3.select("#" + glass.name + "-chart");
      if (!chart.empty()) {
        chart.remove();
      }
      tangents = d3.select("#" + glass.name + "-tangents");
      if (!tangents.empty()) {
        tangents.remove();
      }
      this.glasses.splice(this.glasses.indexOf(glass), 1);
      return this.redraw_graphs();
    };

    Grapher.prototype.set_x_quantity = function(quantity) {
      return this.X_QUANTITY = this.QUANTITIES[quantity];
    };

    Grapher.prototype.set_y_quantity = function(quantity) {
      return this.Y_QUANTITY = this.QUANTITIES[quantity];
    };

    Grapher.prototype.compute_scales = function() {
      var glass, xaxis, xlabel, xraster, yaxis, ylabel, yraster,
        _this = this;
      this.all_graphs = d3.merge((function() {
        var _i, _len, _ref, _results;
        _ref = this.glasses;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          glass = _ref[_i];
          _results.push(glass.graph.data);
        }
        return _results;
      }).call(this));
      this.x_extent = d3.extent(this.all_graphs, function(d) {
        return d[_this.X_QUANTITY.name];
      });
      this.x_scale = d3.scale.linear().range([0, this.GRAPH_DIMENSIONS.width]).domain(this.x_extent);
      this.y_extent = d3.extent(this.all_graphs, function(d) {
        return d[_this.Y_QUANTITY.name];
      });
      this.y_scale = d3.scale.linear().range([this.GRAPH_DIMENSIONS.height, 0]).domain(this.y_extent);
      this.x_axis = d3.svg.axis().scale(this.x_scale).tickSubdivide(3);
      this.y_axis = d3.svg.axis().scale(this.y_scale).orient('left').tickSubdivide(3);
      xaxis = d3.select('g.x.axis');
      if (xaxis.empty()) {
        xaxis = this.svg_graph.append('g').attr('class', 'x axis').attr('transform', "translate(0," + this.GRAPH_DIMENSIONS.height + ")");
      }
      xaxis.call(this.x_axis);
      yaxis = d3.select('g.y.axis');
      if (yaxis.empty()) {
        yaxis = this.svg_graph.append('g').attr('class', 'y axis');
      }
      yaxis.call(this.y_axis);
      xraster = d3.select('g.x.grid');
      if (xraster.empty()) {
        xraster = this.svg_graph.append("g").attr("class", "x grid");
      }
      xraster.attr("transform", "translate(0," + this.GRAPH_DIMENSIONS.height + ")").call(this.x_axis.tickSize(-this.GRAPH_DIMENSIONS.height, 0, 0).tickFormat(""));
      yraster = d3.select('g.y.grid');
      if (yraster.empty()) {
        yraster = this.svg_graph.append("g").attr("class", "y grid");
      }
      yraster.call(this.y_axis.tickSize(-this.GRAPH_DIMENSIONS.width, 0, 0).tickFormat(""));
      ylabel = d3.select('#ylabel');
      if (ylabel.empty()) {
        d3.select('.y.axis').append('text').attr('id', 'ylabel');
      }
      ylabel.attr('text-anchor', 'middle').text("" + this.Y_QUANTITY.label + " (" + this.Y_QUANTITY.unit + ")").attr('transform', 'rotate(-270,0,0)').attr('x', this.GRAPH_DIMENSIONS.height / 2).attr('y', 50);
      xlabel = d3.select('#xlabel');
      if (xlabel.empty()) {
        xlabel = d3.select('.x.axis').append('text').attr('id', 'xlabel');
      }
      return xlabel.attr('text-anchor', 'middle').text("" + this.X_QUANTITY.label + " (" + this.X_QUANTITY.unit + ")").attr('x', this.GRAPH_DIMENSIONS.width / 2).attr('y', this.MARGINS.bottom - this.MARGINS.top);
    };

    Grapher.prototype.toggle_chart = function(glass) {
      var chart;
      if (glass.graph.toggled.chart) {
        chart = d3.select("#" + glass.name + "-chart");
        glass.graph.toggled.chart = false;
        return chart.remove();
      } else {
        glass.graph.toggled.chart = true;
        return this.draw_chart(glass, glass.name);
      }
    };

    Grapher.prototype.toggle_graph = function(glass) {
      var graph;
      if (glass.graph.toggled.graph) {
        graph = d3.select("#" + glass.name + "-graph");
        glass.graph.toggled.graph = false;
        return graph.remove();
      } else {
        glass.graph.toggled.graph = true;
        return this.draw_graph(glass, glass.name);
      }
    };

    Grapher.prototype.draw_graph = function(glass, id) {
      var data, g, line,
        _this = this;
      line = d3.svg.line().x(function(d) {
        return _this.x_scale(d[_this.X_QUANTITY.name]);
      }).y(function(d) {
        return _this.y_scale(d[_this.Y_QUANTITY.name]);
      }).interpolate('cardinal').tension(0);
      g = d3.select('#graph_container').append('g').attr('id', "" + glass.name + "-graph").attr('class', glass.name);
      data = glass.graph.data;
      return g.append('path').attr('d', line(data)).attr('class', 'graph').attr('fill', 'none').attr('stroke', glass.color).style('stroke-wdith', 3);
    };

    Grapher.prototype.draw_chart = function(glass, id) {
      var data, elt, end, g, i, prev,
        _this = this;
      g = d3.select('#graph_container').append('g').attr('id', "" + glass.name + "-chart").attr('class', glass.name);
      data = [];
      i = 1;
      end = glass.graph.data.length;
      prev = glass.graph.data[0];
      while (i < end) {
        elt = glass.graph.data[i];
        if (Math.abs(prev[this.X_QUANTITY.name] - elt[this.X_QUANTITY.name]) >= this.step_size) {
          data.push(elt);
          prev = elt;
        }
        i++;
      }
      return g.selectAll('rect-bar').data(data).enter().append('rect').attr('x', function(d) {
        return _this.x_scale(d[_this.X_QUANTITY.name]);
      }).attr('y', function(d) {
        return _this.y_scale(d[_this.Y_QUANTITY.name]);
      }).attr('width', this.x_scale(this.step_size)).attr('height', function(d) {
        return _this.GRAPH_DIMENSIONS.height - _this.y_scale(d[_this.Y_QUANTITY.name]);
      }).attr('fill', glass.color).attr('fill-opacity', 0.8).attr('stroke', glass.color);
    };

    Grapher.prototype.toggle_tangents = function(glass) {
      var graph;
      graph = d3.select("#" + glass.name + "-tangents");
      if (graph.empty()) {
        return this.draw_tangents(glass, glass.name);
      } else {
        return graph.remove();
      }
    };

    Grapher.prototype.draw_tangents = function(glass, id) {
      var g, line,
        _this = this;
      g = d3.select('#graph_container').append('g').attr('id', "" + glass.name + "-tangents").attr('class', glass.name);
      line = d3.svg.line().x(function(d) {
        return _this.x_scale(d[_this.X_QUANTITY.name]);
      }).y(function(d) {
        return _this.y_scale(d[_this.Y_QUANTITY.name]);
      }).interpolate('cardinal').tension(0);
      g = d3.select('#graph_container').append('g').attr('id', "" + glass.name + "-tangents").attr('class', glass.name);
      return g.append('path').attr('d', line(glass.graph.data)).attr('fill', 'none').attr('stroke', 'white').attr('stroke-opacity', 0).attr('stroke-width', 7).on('mouseover', function(d, i) {
        var LENGTH, bigstep, delta, length_at_point, line_path, next_point, prev_point, tangent, this_point, total_length;
        line_path = d3.select("#" + glass.name + "-tangents path")[0][0];
        length_at_point = 0;
        total_length = line_path.getTotalLength();
        bigstep = 50;
        while (line_path.getPointAtLength(length_at_point).x < d3.mouse(line_path)[0] && length_at_point < total_length) {
          length_at_point += bigstep;
        }
        length_at_point -= bigstep;
        while (line_path.getPointAtLength(length_at_point).x < d3.mouse(line_path)[0] && length_at_point < total_length) {
          length_at_point++;
        }
        this_point = line_path.getPointAtLength(length_at_point);
        if (length_at_point > 10 && length_at_point < total_length - 10) {
          prev_point = line_path.getPointAtLength(length_at_point - 9);
          next_point = line_path.getPointAtLength(length_at_point + 9);
          delta = {
            x: next_point.x - prev_point.x,
            y: next_point.y - prev_point.y
          };
        } else {
          return;
        }
        LENGTH = 5;
        return tangent = d3.select('#graph_container').append('line').attr('stroke', 'black').attr('class', 'tangent').attr('id', 'tangent').attr('stroke-width', 1).attr('x1', this_point.x - delta.x * LENGTH).attr('y1', this_point.y - delta.y * LENGTH).attr('x2', this_point.x + delta.x * LENGTH).attr('y2', this_point.y + delta.y * LENGTH);
      }).on('mouseout', function(d, i) {
        return d3.select('#tangent').remove();
      });
    };

    return Grapher;

  })();

  module.exports = Grapher;

}).call(this);

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Glass, GlassTable;

  Glass = require('../../widgets/glass/glass');

  GlassTable = (function() {
    function GlassTable(flaskfiller, container, config) {
      var glass, _i, _len, _ref;
      this.flaskfiller = flaskfiller;
      this.config = config;
      this.selected_all = false;
      this.is_filling = false;
      this.timer_id = -1;
      this.editing = false;
      this.hide_graph = false;
      this.table = container.append('table').classed('table', true).classed('table-striped', true).classed('table-hover', true);
      this.head = this._create_head();
      this.body = this.table.append('tbody');
      this.glasses = [];
      _ref = this.config.glasses;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        glass = _ref[_i];
        this.add_row(glass);
      }
      this.foot = this._create_foot();
    }

    GlassTable.prototype.graph = function(glass) {
      var _this = this;
      return function() {
        return _this.flaskfiller.graph.toggle_graph(glass);
      };
    };

    GlassTable.prototype.chart = function(glass) {
      var _this = this;
      return function() {
        return _this.flaskfiller.graph.toggle_chart(glass);
      };
    };

    GlassTable.prototype.empty = function(glass) {
      var icon,
        _this = this;
      icon = d3.select("#" + glass.name + "-fill");
      return function() {
        glass.glass.make_empty();
        if (glass != null) {
          glass.representation.fill_to_height(glass.glass.current_height);
        }
        icon.classed('icon-pause', false).classed('icon-play', true).classed('icon-glass', false);
        return _this.update_row(glass);
      };
    };

    GlassTable.prototype.full = function(glass) {
      var icon,
        _this = this;
      icon = d3.select("#" + glass.name + "-fill");
      return function() {
        glass.glass.fill_to_height(glass.glass.maximum_height);
        if (glass != null) {
          glass.representation.fill_to_height(glass.glass.current_height);
        }
        icon.classed('icon-pause', false).classed('icon-play', false).classed('icon-glass', true);
        return _this.update_row(glass);
      };
    };

    GlassTable.prototype.set_volume = function(glass) {
      var _this = this;
      return function() {
        var volume;
        volume = parseFloat(d3.select("#" + glass.name + "-volume").property('value'));
        glass.glass.fill_to_volume(volume);
        if (glass != null) {
          glass.representation.fill_to_height(glass.glass.current_height);
        }
        return _this.update_row(glass);
      };
    };

    GlassTable.prototype.set_height = function(glass) {
      var _this = this;
      return function() {
        var height;
        height = parseFloat(d3.select("#" + glass.name + "-height").property('value'));
        glass.glass.fill_to_height(height * 10);
        if (glass != null) {
          glass.representation.fill_to_height(glass.glass.current_height);
        }
        return _this.update_row(glass);
      };
    };

    GlassTable.prototype.set_time = function(glass) {
      var _this = this;
      return function() {
        var time, volume;
        time = parseFloat(d3.select("#" + glass.name + "-time").property('value'));
        volume = time * _this.config.flow_rate;
        glass.glass.fill_to_volume(volume);
        if (glass != null) {
          glass.representation.fill_to_height(glass.glass.current_height);
        }
        return _this.update_row(glass);
      };
    };

    GlassTable.prototype.update_row = function(glass) {
      d3.select("#" + glass.name + "-volume").property('value', glass.glass.volume());
      d3.select("#" + glass.name + "-height").property('value', glass.glass.height());
      return d3.select("#" + glass.name + "-time").property('value', glass.glass.time(this.config.flow_rate));
    };

    GlassTable.prototype.filling = function(glass) {
      var icon, time_step,
        _this = this;
      icon = d3.select("#" + glass.name + "-fill");
      time_step = 50;
      return function() {
        if (_this.is_filling) {
          icon.classed('icon-pause', false).classed('icon-play', true);
          glass.representation.stop_filling();
          clearInterval(_this.timer_id);
          return _this.is_filling = false;
        } else {
          icon.classed('icon-play', false).classed('icon-pause', true);
          glass.representation.start_filling();
          _this.timer_id = setInterval(_this.fill(glass), time_step);
          return _this.is_filling = true;
        }
      };
    };

    GlassTable.prototype.fill = function(glass) {
      var icon, ml_per_time_step, time_step,
        _this = this;
      time_step = 50;
      ml_per_time_step = this.config.flow_rate * (time_step / 1000);
      icon = d3.select("#" + glass.name + "-fill");
      return function() {
        var volume;
        if (_this.is_filling && !glass.glass.is_full()) {
          volume = glass.glass.volume() + ml_per_time_step;
          glass.glass.fill_to_volume(volume);
          glass.representation.fill_to_height(glass.glass.current_height);
          return _this.update_row(glass);
        } else if (glass.glass.is_full()) {
          icon.classed('icon-pause', false).classed('icon-glass', true);
          glass.representation.stop_filling();
          clearInterval(_this.timer_id);
          return _this.is_filling = false;
        }
      };
    };

    GlassTable.prototype.add_row = function(glass) {
      var gb, row, _ref, _ref1,
        _this = this;
      row = this.body.append('tr').attr('id', glass.name);
      row.append('td').append('input').attr('id', "" + glass.name + "-selected").attr('type', 'checkbox').on('click', function() {
        if (this.checked) {
          return glass.selected = true;
        } else {
          return glass.selected = false;
        }
      });
      glass.selected = false;
      row.append('td').text(glass.name);
      row.append('td').append('input').attr('id', "" + glass.name + "-volume").classed('input-mini', true).attr('type', 'number').attr('min', 0).attr('max', glass.glass.maximum_volume).attr('step', 'any').attr('value', glass.glass.volume()).on('change', this.set_volume(glass));
      row.append('td').append('input').attr('id', "" + glass.name + "-height").classed('input-mini', true).attr('type', 'number').attr('min', 0).attr('max', glass.glass.maximum_height).attr('step', 'any').attr('value', glass.glass.height()).on('change', this.set_height(glass));
      row.append('td').append('input').attr('id', "" + glass.name + "-time").classed('input-mini', true).attr('type', 'number').attr('min', 0).attr('max', glass.glass.to_time(glass.glass.maximum_volume, this.config.flow_rate)).attr('step', 'any').attr('value', glass.glass.time(this.config.flow_rate)).on('change', this.set_time(glass));
      row.append('td').append('button').on('click', this.filling(glass)).classed('btn', true).append('i').attr('id', "" + glass.name + "-fill").classed('icon-play', true);
      row.append('td').append('button').classed('btn', true).on('click', this.empty(glass)).append('i').attr('id', "" + glass.name + "-empty").classed('icon-backward', true);
      row.append('td').append('button').on('click', this.full(glass)).classed('btn', true).append('i').attr('id', "" + glass.name + "-full").classed('icon-forward', true);
      row.append('td');
      gb = row.append('td').append('button').classed('btn', true).classed('graphbutton', true);
      gb.append('button').on('click', this.graph(glass)).append('i').attr('id', "" + glass.name + "-showgraph").classed('icon-picture', true);
      if ((_ref = this.config) != null ? _ref.hide_graph : void 0) {
        gb.attr('disabled', 'true');
      }
      gb = row.append('td').append('button').classed('btn', true).classed('graphbutton', true);
      gb.append('button').on('click', this.chart(glass)).append('i').attr('id', "" + glass.name + "-showchart").classed('icon-signal', true);
      if ((_ref1 = this.config) != null ? _ref1.hide_graph : void 0) {
        gb.attr('disabled', 'true');
      }
      row.append('td').append('button').on('click', function() {
        return _this.flaskfiller.remove(glass);
      }).classed('btn', true).append('i').attr('id', "" + glass.name + "-remove").classed('icon-remove-sign', true);
      glass.row = row;
      return this.glasses.push(glass);
    };

    GlassTable.prototype.remove_row = function(glass) {
      return glass.row.remove();
    };

    GlassTable.prototype._name_exists = function(name) {
      var glass, same_names;
      same_names = (function() {
        var _i, _len, _ref, _results;
        _ref = this.glasses;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          glass = _ref[_i];
          if (glass.name === name) {
            _results.push(glass.name);
          }
        }
        return _results;
      }).call(this);
      if (same_names.length > 0) {
        return true;
      } else {
        return false;
      }
    };

    GlassTable.prototype._add_from_menu = function(name, spec) {
      var i, random_color,
        _this = this;
      random_color = function() {
        var colors, hexes, i;
        hexes = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        colors = [];
        i = 0;
        while (i < 6) {
          colors.push(hexes[Math.round(Math.random() * (hexes.length - 1))]);
          i++;
        }
        return "#" + (colors.join(''));
      };
      if (this._name_exists(name)) {
        i = 1;
        while (this._name_exists("" + name + "-" + i)) {
          i++;
        }
        name = "" + name + "-" + i;
      }
      return function() {
        return _this.flaskfiller.add({
          name: name,
          glass: new Glass(spec),
          color: random_color()
        });
      };
    };

    GlassTable.prototype._create_add_menu = function(place) {
      var add_button, item, menu, name, spec, _ref, _results;
      add_button = place.append('div').classed('btn-group', true).classed('dropup', true);
      add_button.append('a').classed('btn', true).classed('dropdown-toggle', true).attr('data-toggle', 'dropdown').attr('href', '#').html('Voeg een glas toe <span class="caret"></span>');
      menu = add_button.append('ul').classed('dropdown-menu', true);
      _ref = this.config.glass_specs;
      _results = [];
      for (name in _ref) {
        spec = _ref[name];
        item = menu.append('li').append('a').attr('href', '#').attr('data-glassname', name).text(name.replace(/_/, ' '));
        _results.push(item.on('click', this._add_from_menu(name, spec)));
      }
      return _results;
    };

    GlassTable.prototype._create_foot = function() {
      var foot,
        _this = this;
      foot = this.table.append('tfoot').append('tr');
      foot.append('td');
      this._create_add_menu(foot.append('td'));
      foot.append('th').classed('text-right', true).attr('colspan', '3').text('pas een actie toe op de geselecteerde glazen');
      foot.append('td');
      foot.append('td').append('button').on('click', function() {
        var glass, _i, _len, _ref, _results;
        _ref = _this.glasses;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          glass = _ref[_i];
          if (glass.selected) {
            _results.push(_this.empty(glass)());
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }).classed('btn', true).append('i').classed('icon-backward', true);
      foot.append('td').append('button').on('click', function() {
        var glass, _i, _len, _ref, _results;
        _ref = _this.glasses;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          glass = _ref[_i];
          if (glass.selected) {
            _results.push(_this.full(glass)());
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }).classed('btn', true).append('i').classed('icon-forward', true);
      foot.append('td');
      foot.append('td');
      foot.append('td');
      foot.append('td').append('button').on('click', function() {
        var glass, _i, _len, _ref, _results;
        _ref = _this.glasses;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          glass = _ref[_i];
          if (glass.selected) {
            _results.push(_this.flaskfiller.remove(glass));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }).classed('btn', true).append('i').classed('icon-remove-sign', true);
      return foot;
    };

    GlassTable.prototype._create_head = function() {
      var head,
        _this = this;
      head = this.table.append('thead').append('tr');
      head.append('th').append('input').attr('id', "select-all").attr('type', 'checkbox').on('click', function() {
        var glass, _i, _j, _len, _len1, _ref, _ref1;
        if (_this.selected_all) {
          _ref = _this.glasses;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            glass = _ref[_i];
            glass.row.select("#" + glass.name + "-selected").property('checked', false);
            glass.selected = false;
          }
          return _this.selected_all = false;
        } else {
          _ref1 = _this.glasses;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            glass = _ref1[_j];
            glass.row.select("#" + glass.name + "-selected").property('checked', true);
            glass.selected = true;
          }
          return _this.selected_all = true;
        }
      });
      head.append('th').text('naam');
      head.append('th').text('volume (ml)');
      head.append('th').text('hoogte (cm)');
      head.append('th').text('tijd (sec)');
      head.append('th').attr('colspan', '7').text('acties');
      return head;
    };

    return GlassTable;

  })();

  module.exports = GlassTable;

}).call(this);

},{"../../widgets/glass/glass":2}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Glass, Simulation, WGlass, WHorizontalRuler, WVerticalRuler;

  Glass = require('../../widgets/glass/glass');

  WGlass = require('../../widgets/glass/wglass');

  WVerticalRuler = require('../../widgets/ruler/wvertical_ruler');

  WHorizontalRuler = require('../../widgets/ruler/whorizontal_ruler');

  Simulation = (function() {
    function Simulation(flaskfiller, container, config) {
      var MM_RULER, glass, hruler, vruler, _i, _len, _ref;
      this.flaskfiller = flaskfiller;
      this.config = config;
      this.selected = {
        selected: null
      };
      this.WIDTH = 700;
      this.HEIGHT = 550;
      this.RULER_WIDTH = 30;
      this.RULER_LENGTH = this.HEIGHT - this.RULER_WIDTH;
      MM_RULER = 170;
      this.simulation_container = container.append('figure').attr('id', 'simulation');
      this.canvas = Raphael('simulation', this.WIDTH, this.HEIGHT);
      this.glasses = [];
      _ref = this.config.glasses;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        glass = _ref[_i];
        this.add_glass(glass);
      }
      vruler = new WVerticalRuler(this.canvas, 0, 0, this.RULER_WIDTH, this.RULER_LENGTH, MM_RULER);
      hruler = new WHorizontalRuler(this.canvas, this.RULER_WIDTH, this.RULER_LENGTH, this.RULER_LENGTH, this.RULER_WIDTH, MM_RULER);
    }

    Simulation.prototype.add_glass = function(glass) {
      var wglass, x, y;
      x = this.RULER_WIDTH + (this.WIDTH / 2) - (glass.glass.edge.x / 2);
      y = this.HEIGHT - (glass.glass.foot.y - glass.glass.edge.y) - this.RULER_WIDTH;
      wglass = new WGlass(this.canvas, x, y, glass.glass, {
        fill: glass.color
      });
      wglass.start_selectable(this.selected);
      glass.representation = wglass;
      return this.glasses.push(glass);
    };

    Simulation.prototype.remove_glass = function(glass) {
      glass.representation.remove();
      return this.glasses.splice(this.glasses.indexOf(glass), 1);
    };

    return Simulation;

  })();

  module.exports = Simulation;

}).call(this);

},{"../../widgets/glass/glass":2,"../../widgets/glass/wglass":7,"../../widgets/ruler/wvertical_ruler":8,"../../widgets/ruler/whorizontal_ruler":9}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
*/


(function() {
  var Glass, MeasureLine, WGlass, WMeasureLine, Widget,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Widget = require('../widget');

  Glass = require('./glass');

  MeasureLine = require('./measure_line');

  WMeasureLine = require('./wmeasure_line');

  WGlass = (function(_super) {
    __extends(WGlass, _super);

    function WGlass(canvas, x, y, glass, spec) {
      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.glass = glass;
      this.spec = spec != null ? spec : {};
      WGlass.__super__.constructor.call(this, this.canvas, this.x, this.y, this.spec);
      this.points = this._compute_points(this.glass);
      this.lengths = this._compute_lengths_at_heigth();
      this._draw();
      this.place_at(this.x, this.y);
      this.move_handler = null;
      this.graph = null;
    }

    WGlass.prototype.start_filling = function() {};

    WGlass.prototype.stop_filling = function() {};

    WGlass.prototype.fill_to_height = function(height_in_mm) {
      /*
      Update the fill-part to correspond to a water level equal to the height_in_mm.
      */

      var diameter, height, left, length, right;
      diameter = function(length, glass) {
        return Math.abs(Raphael.getPointAtLength(glass.path, length).x - glass.foot.x) * 2;
      };
      height = this.glass.foot.y - (height_in_mm * this.glass.unit);
      if (height < this.glass.bowl.y) {
        this.points.water_level = {};
        this.points.water_level.length = length = this.lengths[height_in_mm * Glass.TENTH_OF_MM];
        this.points.water_level.right = right = Raphael.getPointAtLength(this.glass.path, length);
        this.points.water_level.left = {
          x: right.x - diameter(length, this.glass),
          y: right.y
        };
        right = Raphael.path2curve(Raphael.getSubpath(this.glass.path, this.points.water_level.length, this.points.bowl.length));
        left = this._mirror_path_vertically(right, this.glass.bowl.x);
        return this.water_level.attr({
          path: right + ("H" + this.points.bowl.left.x) + left
        });
      }
    };

    WGlass.prototype._draw = function() {
      var base, bowl, max_ml_representation, max_x, max_y, maxpoint, _ref, _ref1;
      this.paths = this._create_paths();
      base = this.canvas.path(this.paths.base);
      base.attr({
        fill: '#aaa',
        stroke: 'black',
        'stroke-width': 2
      });
      this.widgets.push(base);
      this.water_level = this.canvas.path("M0,0");
      this.water_level.attr({
        fill: (_ref = (_ref1 = this.spec) != null ? _ref1.fill : void 0) != null ? _ref : '#abf',
        'fill-opacity': 0.4,
        stroke: 'none'
      });
      this.widgets.push(this.water_level);
      bowl = this.canvas.path(this.paths.bowl);
      bowl.attr({
        stroke: 'black',
        'stroke-width': 2
      });
      this.widgets.push(bowl);
      maxpoint = Raphael.getPointAtLength(this.glass.path, this.lengths[this.glass.maximum_height * Glass.TENTH_OF_MM]);
      max_x = maxpoint.x;
      max_y = maxpoint.y;
      this.max_ml = new MeasureLine(this.glass.maximum_volume, this.glass.maximum_height, this.glass, {
        x: max_x,
        y: max_y
      }, 'right', true, false);
      max_ml_representation = new WMeasureLine(this.canvas, max_x, max_y, this.max_ml);
      this.widgets.push(max_ml_representation.widgets);
      this.glasspane = this.canvas.path("" + this.paths.bowl + " " + this.paths.base);
      this.glasspane.attr({
        fill: 'white',
        'fill-opacity': 0,
        'stroke-width': 5,
        'stroke-opacity': 0,
        'stroke': 'gray'
      });
      return this.widgets.push(this.glasspane);
    };

    WGlass.prototype._create_paths = function() {
      /*
      Create the path of the part of this glass
      */

      var left, paths, right;
      paths = {};
      right = Raphael.path2curve(Raphael.getSubpath(this.glass.path, this.points.bowl.length, this.points.foot.length));
      left = this._mirror_path_vertically(right, this.glass.foot.x);
      paths.base = right + ("H" + this.points.foot.left.x) + left;
      right = Raphael.path2curve(Raphael.getSubpath(this.glass.path, this.points.edge.length, this.points.bowl.length));
      left = this._mirror_path_vertically(right, this.glass.foot.x);
      paths.bowl = right + ("H" + this.points.bowl.left.x) + left;
      return paths;
    };

    WGlass.prototype._compute_geometry = function() {
      var base, bowl;
      base = Raphael.pathBBox(this.paths.base);
      bowl = Raphael.pathBBox(this.paths.bowl);
      this.geometry = {};
      this.geometry.top = bowl.y;
      this.geometry.left = Math.min(base.x, bowl.x);
      this.geometry.bottom = base.y2;
      this.geometry.right = Math.max(base.x2, bowl.b2);
      this.geometry.width = Math.max(base.width, bowl.width);
      this.geometry.height = base.y2 + bowl.y1;
      return this.geometry.center = {
        x: (this.geometry.right - this.geometry.left) / 2 + this.geometry.left,
        y: (this.geometry.bottom - this.geometry.top) / 2 + this.geometry.top
      };
    };

    WGlass.prototype._compute_points = function(glass) {
      /*
      Compute points, lengths, and paths between points for the edge, foot, stem, and bowl
      */

      var diameter, length, line, points, right, _i, _len, _ref;
      diameter = function(length) {
        return Math.abs(Raphael.getPointAtLength(glass.path, length).x - glass.foot.x) * 2;
      };
      points = {};
      length = 0;
      _ref = ['edge', 'bowl', 'stem', 'foot'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        points[line] = {};
        points[line].length = length = this._length_at_y(glass.path, glass[line].y, length);
        points[line].right = right = Raphael.getPointAtLength(glass.path, length);
        points[line].left = {
          x: right.x - diameter(length),
          y: right.y
        };
      }
      return points;
    };

    WGlass.prototype._compute_lengths_at_heigth = function() {
      var height, height_in_pixels, length, lengths, max_length;
      lengths = [];
      length = 0;
      max_length = Raphael.getTotalLength(this.glass.path);
      height = this.glass.height_in_mm * Glass.TENTH_OF_MM;
      while (height > 0) {
        height_in_pixels = this.glass.foot.y - ((height * this.glass.unit) / Glass.TENTH_OF_MM);
        while (length < max_length && Raphael.getPointAtLength(this.glass.path, length).y < height_in_pixels) {
          length++;
        }
        lengths[height] = length;
        height--;
      }
      lengths[0] = this.points.foot.length;
      return lengths;
    };

    WGlass.prototype._length_at_y = function(path, y, start) {
      var length, max_length;
      if (start == null) {
        start = 0;
      }
      /*
        Find the length on the path the path hat intersects the horizontal line at y
      */

      length = start;
      max_length = Raphael.getTotalLength(path);
      while (length < max_length && Raphael.getPointAtLength(path, length).y < y) {
        length++;
      }
      return length;
    };

    WGlass.prototype._mirror_path_vertically = function(path, x_line) {
      /*
      */

      var cp1x, cp1y, cp2x, cp2y, cpath, cpathsegs, mirror, mirror_x, mirrorlist, segment, x, y, _i, _len, _ref, _ref1, _ref2, _ref3;
      mirror_x = function(x) {
        return x_line - Math.abs(x_line - x);
      };
      cpath = Raphael.path2curve(path);
      cpathsegs = Raphael.parsePathString(cpath);
      mirror = "";
      mirrorlist = [];
      _ref = cpathsegs[0].slice(1, 3), x = _ref[0], y = _ref[1];
      _ref1 = cpathsegs.slice(1, +cpathsegs.length + 1 || 9e9);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        segment = _ref1[_i];
        _ref2 = segment.slice(1, 5), cp1x = _ref2[0], cp1y = _ref2[1], cp2x = _ref2[2], cp2y = _ref2[3];
        mirrorlist.push([mirror_x(cp2x), cp2y, mirror_x(cp1x), cp1y, mirror_x(x), y]);
        _ref3 = segment.slice(5, 7), x = _ref3[0], y = _ref3[1];
      }
      mirror = ((function() {
        var _j, _len1, _ref4, _results;
        _ref4 = mirrorlist.reverse();
        _results = [];
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          segment = _ref4[_j];
          _results.push('C' + segment.join(","));
        }
        return _results;
      })()).join("");
      return mirror;
    };

    return WGlass;

  })(Widget);

  module.exports = WGlass;

}).call(this);

},{"../widget":10,"./glass":2,"./measure_line":11,"./wmeasure_line":12}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
(c) 2012, Huub de Beer (H.T.de.Beer@gmail.com)
*/


(function() {
  var WVerticalRuler, Widget,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Widget = require('../widget');

  WVerticalRuler = (function(_super) {
    __extends(WVerticalRuler, _super);

    function WVerticalRuler(canvas, x, y, width, height, height_in_mm, spec) {
      var _this = this;
      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.height_in_mm = height_in_mm;
      this.spec = spec != null ? spec : {};
      this.spec = {
        orientation: "vertical",
        rounded_corners: 0,
        measure_line_width: this.height + this.width
      };
      WVerticalRuler.__super__.constructor.call(this, this.canvas, this.x, this.y, this.spec);
      this._draw();
      this._compute_geometry();
      this.widgets.mouseover(function(e) {
        return _this.measure_line.show();
      });
      this.widgets.mouseout(function(e) {
        return _this.measure_line.hide();
      });
      this.widgets.mousemove(function(e, x, y) {
        var p;
        p = _this.fit_point(x, y);
        return _this._move_measure_line(p.y);
      });
      this.widgets.click(function(e, x, y) {
        var p;
        p = _this.fit_point(x, y);
        return _this._place_pointer(p.y);
      });
    }

    WVerticalRuler.prototype.fit_point = function(x, y) {
      var point;
      point = {
        x: x - this.canvas.canvas.parentNode.offsetLeft,
        y: y - this.canvas.canvas.parentNode.offsetTop
      };
      return point;
    };

    WVerticalRuler.prototype._place_pointer = function(y) {
      var T_HEIGHT, T_WIDTH, active, pointer, remove, triangle, unactive, _ref;
      T_WIDTH = 10;
      T_HEIGHT = 4;
      triangle = "l" + T_WIDTH + "," + T_HEIGHT + "v-" + (2 * T_HEIGHT) + "l-" + T_WIDTH + "," + T_HEIGHT + "m" + T_WIDTH + ",0";
      pointer = this.canvas.path(("M" + (this.x + this.width) + "," + y) + triangle + ("h" + (((_ref = this.spec['measure_line_width']) != null ? _ref : 500) - this.width - T_WIDTH - 2)));
      pointer.attr({
        fill: '#222',
        stroke: '#222',
        'stroke-opacity': 0.75,
        'stroke-width': 1,
        'fill-opacity': 1,
        'stroke-dasharray': '.'
      });
      active = function(elt) {
        return elt.attr({
          fill: "red",
          stroke: "red",
          'stroke-opacity': 0.5,
          'fill-opacity': 0.5
        });
      };
      unactive = function(elt) {
        return elt.attr({
          fill: "#222",
          stroke: '#222',
          'stroke-opacity': 0.5,
          'stroke-width': 0.5,
          'fill-opacity': 1
        });
      };
      remove = function(elt) {
        elt.unmouseover(active);
        elt.unmouseout(unactive);
        return elt.remove();
      };
      pointer.mouseover(function() {
        return active(this);
      });
      pointer.mouseout(function() {
        return unactive(this);
      });
      pointer.click(function() {
        return remove(this);
      });
      pointer.touchstart(function() {
        return active(this);
      });
      pointer.touchcancel(function() {
        return unactive(this);
      });
      pointer.touchend(function() {
        return remove(this);
      });
      return this.pointers.push(pointer);
    };

    WVerticalRuler.prototype._move_measure_line = function(y) {
      var MEASURELINE_LENGTH, _ref;
      MEASURELINE_LENGTH = (_ref = this.spec['measure_line_width']) != null ? _ref : 500;
      return this.measure_line.attr({
        path: "M" + (this.x - this.dx) + "," + y + "h" + MEASURELINE_LENGTH,
        stroke: 'red',
        'stroke-opacity': 0.5,
        'stroke-width': 1
      });
    };

    WVerticalRuler.prototype._draw = function() {
      /*
      Draw a vertical ruler
      */

      var background, cmlabel, label, labels, ticks, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      this.unit = this.height / this.height_in_mm;
      background = this.canvas.rect(this.x, this.y, this.width, this.height, (_ref = this.spec.rounded_corners) != null ? _ref : 5);
      background.attr({
        fill: (_ref1 = this.spec.background) != null ? _ref1 : "white",
        stroke: (_ref2 = this.spec.stroke) != null ? _ref2 : "black",
        'stroke-width': (_ref3 = this.spec['stroke-width']) != null ? _ref3 : 2
      });
      this.widgets.push(background);
      ticks = this.canvas.path(this._ticks_path());
      ticks.attr({
        stroke: (_ref4 = this.spec.stroke) != null ? _ref4 : "black"
      });
      this.widgets.push(ticks);
      labels = this._ticks_labels();
      for (_i = 0, _len = labels.length; _i < _len; _i++) {
        label = labels[_i];
        label.attr({
          'font-family': (_ref5 = this.spec['font-family']) != null ? _ref5 : 'sans-serif',
          'font-size': (_ref6 = this.spec['font-size']) != null ? _ref6 : 10,
          'font-weight': 'bold'
        });
        this.widgets.push(label);
      }
      cmlabel = this.canvas.text(this.x + 11, this.y + 11, "cm");
      cmlabel.attr({
        'font-family': (_ref7 = this.spec['font-family']) != null ? _ref7 : 'sans-serif',
        'font-size': ((_ref8 = this.spec['font-size']) != null ? _ref8 : 10) + 2,
        'font-weight': 'bold'
      });
      this.widgets.push(cmlabel);
      this.pointers = this.canvas.set();
      this.widgets.push(this.pointers);
      this.measure_line = this.canvas.path("M" + this.x + "," + this.y);
      this.measure_line.hide();
      return this.widgets.push(this.measure_line);
    };

    WVerticalRuler.prototype._ticks_path = function() {
      /*
      Generate the ticks by moving from tick to tick and drawing a horizontal line
      for every tick.
      */

      var CM_WIDTH, HCM_WIDTH, MM_WIDTH, d, mm, x, y, _i, _ref, _ref1, _ref2, _ref3, _ref4;
      MM_WIDTH = (_ref = this.spec.mm_width) != null ? _ref : 3;
      HCM_WIDTH = (_ref1 = this.spec.hcm_width) != null ? _ref1 : 7;
      CM_WIDTH = (_ref2 = this.spec.cm_width) != null ? _ref2 : 11;
      x = this.x + this.width;
      y = this.y + this.height - ((_ref3 = this.spec.border_width) != null ? _ref3 : 2);
      d = "";
      for (mm = _i = 2, _ref4 = this.height_in_mm - 1; 2 <= _ref4 ? _i < _ref4 : _i > _ref4; mm = 2 <= _ref4 ? ++_i : --_i) {
        y -= this.unit;
        d += "M" + x + "," + y;
        if (mm % 10 === 0) {
          d += "h-" + CM_WIDTH;
        } else if (mm % 5 === 0) {
          d += "h-" + HCM_WIDTH;
        } else {
          d += "h-" + MM_WIDTH;
        }
      }
      return d;
    };

    WVerticalRuler.prototype._ticks_labels = function() {
      /*
      Draw the labels of the cm ticks
      */

      var X_DISTANCE, Y_DISTANCE, cm, labels, mm, x, y, _i, _ref, _ref1, _ref2, _ref3;
      X_DISTANCE = (_ref = this.spec.x_distance) != null ? _ref : 18;
      Y_DISTANCE = (_ref1 = this.spec.y_distance) != null ? _ref1 : 3;
      x = this.x + this.width - X_DISTANCE;
      y = this.y + this.height - ((_ref2 = this.spec.border_width) != null ? _ref2 : 2);
      cm = 0;
      labels = [];
      for (mm = _i = 2, _ref3 = this.height_in_mm - 1; 2 <= _ref3 ? _i < _ref3 : _i > _ref3; mm = 2 <= _ref3 ? ++_i : --_i) {
        y -= this.unit;
        if (mm % 10 === 0) {
          cm++;
          labels.push(this.canvas.text(x, y + Y_DISTANCE, "" + cm));
        }
      }
      return labels;
    };

    return WVerticalRuler;

  })(Widget);

  module.exports = WVerticalRuler;

}).call(this);

},{"../widget":10}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
(c) 2012, Huub de Beer (H.T.de.Beer@gmail.com)
*/


(function() {
  var WHorizontalRuler, Widget,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Widget = require('../widget');

  WHorizontalRuler = (function(_super) {
    __extends(WHorizontalRuler, _super);

    function WHorizontalRuler(canvas, x, y, width, height, height_in_mm, spec) {
      var _this = this;
      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.height_in_mm = height_in_mm;
      this.spec = spec != null ? spec : {};
      this.spec = {
        orientation: "horizontal",
        rounded_corners: 0,
        measure_line_width: this.width + this.height
      };
      WHorizontalRuler.__super__.constructor.call(this, this.canvas, this.x, this.y, this.spec);
      this._draw();
      this._compute_geometry();
      this.widgets.mouseover(function(e) {
        return _this.measure_line.show();
      });
      this.widgets.mouseout(function(e) {
        return _this.measure_line.hide();
      });
      this.widgets.mousemove(function(e, x, y) {
        var p;
        p = _this.fit_point(x, y);
        return _this._move_measure_line(p.x);
      });
      this.widgets.click(function(e, x, y) {
        var p;
        p = _this.fit_point(x, y);
        return _this._place_pointer(p.x);
      });
    }

    WHorizontalRuler.prototype._place_pointer = function(x) {
      var T_HEIGHT, T_WIDTH, active, pointer, remove, triangle, unactive, _ref;
      T_WIDTH = 4;
      T_HEIGHT = 10;
      triangle = "l" + T_WIDTH + ",-" + T_HEIGHT + "h-" + (2 * T_WIDTH) + "l" + T_WIDTH + "," + T_HEIGHT + "m0,0";
      pointer = this.canvas.path(("M" + x + "," + this.y) + triangle + ("v-" + (((_ref = this.spec['measure_line_width']) != null ? _ref : 500) - this.height - T_WIDTH - 2)));
      pointer.attr({
        fill: '#222',
        stroke: '#222',
        'stroke-opacity': 0.75,
        'stroke-width': 1,
        'fill-opacity': 1,
        'stroke-dasharray': '.'
      });
      active = function(elt) {
        return elt.attr({
          fill: "red",
          stroke: "red",
          'stroke-opacity': 0.5,
          'fill-opacity': 0.5
        });
      };
      unactive = function(elt) {
        return elt.attr({
          fill: "#222",
          stroke: '#222',
          'stroke-opacity': 0.5,
          'stroke-width': 0.5,
          'fill-opacity': 1
        });
      };
      remove = function(elt) {
        elt.unmouseover(active);
        elt.unmouseout(unactive);
        return elt.remove();
      };
      pointer.mouseover(function() {
        return active(this);
      });
      pointer.mouseout(function() {
        return unactive(this);
      });
      pointer.click(function() {
        return remove(this);
      });
      pointer.touchstart(function() {
        return active(this);
      });
      pointer.touchcancel(function() {
        return unactive(this);
      });
      pointer.touchend(function() {
        return remove(this);
      });
      return this.pointers.push(pointer);
    };

    WHorizontalRuler.prototype._move_measure_line = function(x) {
      var MEASURELINE_LENGTH, _ref;
      MEASURELINE_LENGTH = (_ref = this.spec['measure_line_width']) != null ? _ref : 500;
      return this.measure_line.attr({
        path: "M" + x + "," + (this.y - this.dy + this.height) + "v-" + (MEASURELINE_LENGTH + this.height),
        stroke: 'red',
        'stroke-opacity': 0.5,
        'stroke-width': 1
      });
    };

    WHorizontalRuler.prototype._draw = function() {
      /*
      Draw a vertical ruler
      */

      var background, cmlabel, label, labels, ticks, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      this.unit = this.width / this.height_in_mm;
      background = this.canvas.rect(this.x, this.y, this.width, this.height, (_ref = this.spec.rounded_corners) != null ? _ref : 5);
      background.attr({
        fill: (_ref1 = this.spec.background) != null ? _ref1 : "white",
        stroke: (_ref2 = this.spec.stroke) != null ? _ref2 : "black",
        'stroke-width': (_ref3 = this.spec['stroke-width']) != null ? _ref3 : 2
      });
      this.widgets.push(background);
      ticks = this.canvas.path(this._ticks_path());
      ticks.attr({
        stroke: (_ref4 = this.spec.stroke) != null ? _ref4 : "black"
      });
      this.widgets.push(ticks);
      labels = this._ticks_labels();
      for (_i = 0, _len = labels.length; _i < _len; _i++) {
        label = labels[_i];
        label.attr({
          'font-family': (_ref5 = this.spec['font-family']) != null ? _ref5 : 'sans-serif',
          'font-size': (_ref6 = this.spec['font-size']) != null ? _ref6 : 10,
          'font-weight': 'bold'
        });
        this.widgets.push(label);
      }
      cmlabel = this.canvas.text(this.x + this.width - 11, this.y + this.height - 11, "cm");
      cmlabel.attr({
        'font-family': (_ref7 = this.spec['font-family']) != null ? _ref7 : 'sans-serif',
        'font-size': ((_ref8 = this.spec['font-size']) != null ? _ref8 : 10) + 2,
        'font-weight': 'bold'
      });
      this.widgets.push(cmlabel);
      this.pointers = this.canvas.set();
      this.widgets.push(this.pointers);
      this.measure_line = this.canvas.path("M" + this.x + "," + this.y);
      this.measure_line.hide();
      return this.widgets.push(this.measure_line);
    };

    WHorizontalRuler.prototype._ticks_path = function() {
      /*
      Generate the ticks by moving from tick to tick and drawing a horizontal line
      for every tick.
      */

      var CM_WIDTH, HCM_WIDTH, MM_WIDTH, d, mm, x, y, _i, _ref, _ref1, _ref2, _ref3, _ref4;
      MM_WIDTH = (_ref = this.spec.mm_width) != null ? _ref : 3;
      HCM_WIDTH = (_ref1 = this.spec.hcm_width) != null ? _ref1 : 7;
      CM_WIDTH = (_ref2 = this.spec.cm_width) != null ? _ref2 : 11;
      x = this.x + ((_ref3 = this.spec.border_width) != null ? _ref3 : 2);
      y = this.y;
      d = "";
      for (mm = _i = 2, _ref4 = this.height_in_mm - 1; 2 <= _ref4 ? _i < _ref4 : _i > _ref4; mm = 2 <= _ref4 ? ++_i : --_i) {
        x += this.unit;
        d += "M" + x + "," + y;
        if (mm % 10 === 0) {
          d += "v" + CM_WIDTH;
        } else if (mm % 5 === 0) {
          d += "v" + HCM_WIDTH;
        } else {
          d += "v" + MM_WIDTH;
        }
      }
      return d;
    };

    WHorizontalRuler.prototype._ticks_labels = function() {
      /*
      Draw the labels of the cm ticks
      */

      var X_DISTANCE, Y_DISTANCE, cm, labels, mm, x, y, _i, _ref, _ref1, _ref2, _ref3;
      X_DISTANCE = (_ref = this.spec.x_distance) != null ? _ref : 3;
      Y_DISTANCE = (_ref1 = this.spec.y_distance) != null ? _ref1 : 10;
      x = this.x + ((_ref2 = this.spec.border_width) != null ? _ref2 : 2);
      y = this.y + Y_DISTANCE;
      cm = 0;
      labels = [];
      for (mm = _i = 2, _ref3 = this.height_in_mm - 1; 2 <= _ref3 ? _i < _ref3 : _i > _ref3; mm = 2 <= _ref3 ? ++_i : --_i) {
        x += this.unit;
        if (mm % 10 === 0) {
          cm++;
          labels.push(this.canvas.text(x, y + Y_DISTANCE, "" + cm));
        }
      }
      return labels;
    };

    return WHorizontalRuler;

  })(Widget);

  module.exports = WHorizontalRuler;

}).call(this);

},{"../widget":10}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*

(c) 2012, Huub de Beer, H.T.de.Beer@gmail.com
*/


(function() {
  var Widget,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Widget = (function() {
    function Widget(canvas, x, y, spec) {
      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.spec = spec != null ? spec : {};
      this.disable_draggable = __bind(this.disable_draggable, this);
      this.enable_draggable = __bind(this.enable_draggable, this);
      this.drag_move = __bind(this.drag_move, this);
      this.drag_end = __bind(this.drag_end, this);
      this.drag_start = __bind(this.drag_start, this);
      this.stop_draggable = __bind(this.stop_draggable, this);
      this.start_draggable = __bind(this.start_draggable, this);
      this.select = __bind(this.select, this);
      this.disable_selectable = __bind(this.disable_selectable, this);
      this.enable_selectable = __bind(this.enable_selectable, this);
      this.stop_selectable = __bind(this.stop_selectable, this);
      this.start_selectable = __bind(this.start_selectable, this);
      this.widgets = this.canvas.set();
      this.dx = this.dy = 0;
      this.selected = false;
    }

    Widget.prototype.remove = function() {
      return this.widgets.remove();
    };

    Widget.prototype.start_selectable = function(slot) {
      this.slot = slot;
      this.glasspane.mouseover(this.enable_selectable);
      return this.glasspane.mouseout(this.disable_selectable);
    };

    Widget.prototype.stop_selectable = function() {
      this.glasspane.unmouseover(this.enable_selectable);
      return this.glasspane.unmouseout(this.disable_selectable);
    };

    Widget.prototype.enable_selectable = function() {
      return this.glasspane.dblclick(this.select);
    };

    Widget.prototype.disable_selectable = function() {
      return this.glasspane.undblclick(this.select);
    };

    Widget.prototype.select = function() {
      var _ref;
      if (this.selected) {
        this.selected = false;
        this.slot.selected = null;
        this.disable_draggable();
        return this.glasspane.attr('stroke-opacity', 0);
      } else {
        this.selected = true;
        if ((_ref = this.slot) != null ? _ref.selected : void 0) {
          this.slot.selected.select();
        }
        this.slot.selected = this;
        this.widgets.toFront();
        this.enable_draggable();
        return this.glasspane.attr('stroke-opacity', 0.5);
      }
    };

    Widget.prototype.start_draggable = function() {
      this.glasspane.mouseover(this.enable_draggable);
      return this.glasspane.mouseout(this.disable_draggable);
    };

    Widget.prototype.stop_draggable = function() {
      this.glasspane.unmouseover(this.enable_draggable);
      return this.glasspane.unmouseout(this.disable_draggable);
    };

    Widget.prototype.drag_start = function() {
      var _ref;
      this.dpo = (_ref = this.dpo) != null ? _ref : {};
      return this.dpo = {
        x: 0,
        y: 0
      };
    };

    Widget.prototype.drag_end = function() {};

    Widget.prototype.drag_move = function(dx, dy, x, y, e) {
      var tx, ty;
      tx = Math.floor(dx - this.dpo.x);
      ty = Math.floor(dy - this.dpo.y);
      this.x += tx;
      this.y += ty;
      this.widgets.transform("...t" + tx + "," + ty);
      return this.dpo = {
        x: dx,
        y: dy
      };
    };

    Widget.prototype.enable_draggable = function() {
      this.widgets.attr('cursor', 'move');
      return this.widgets.drag(this.drag_move, this.drag_start, this.drag_end);
    };

    Widget.prototype.disable_draggable = function() {
      this.widgets.attr('cursor', 'default');
      return this.widgets.undrag();
    };

    Widget.prototype.hide = function() {
      return this.widgets.hide();
    };

    Widget.prototype.show = function() {
      return this.widgets.show();
    };

    Widget.prototype.place_at = function(x, y) {
      /*
      Place this widget at co-ordinates x an y
      */

      this._compute_geometry();
      this.dx = x - this.geometry.left;
      this.dy = y - this.geometry.top;
      this.widgets.transform("...t" + this.dx + "," + this.dy);
      this.x = x;
      this.y = y;
      this._compute_geometry();
      return this;
    };

    Widget.prototype.fit_point = function(x, y) {
      var point;
      point = {
        x: x - this.canvas.canvas.parentNode.offsetLeft,
        y: y - this.canvas.canvas.parentNode.offsetTop
      };
      return point;
    };

    Widget.prototype._draw = function() {
      /*
      Draw this widget. Virtual method to be overloaded by all subclasses of 
      Widget. All shapes drawn are added to the list of widgets
      */

    };

    Widget.prototype._compute_geometry = function() {
      /*
      Compute the left, top, bottom, right, width, height, and center of this 
      widget given its top-left corner (x, y). 
      
      This does not work with paths that do not start at (0,0)
      */

      var bbox;
      bbox = this.widgets.getBBox();
      this.geometry = {};
      this.geometry.width = bbox.width;
      this.geometry.height = bbox.height;
      this.geometry.top = bbox.y;
      this.geometry.left = bbox.x;
      this.geometry.right = bbox.x2;
      this.geometry.bottom = bbox.y2;
      return this.geometry.center = {
        x: (this.geometry.right - this.geometry.left) / 2 + this.geometry.left,
        y: (this.geometry.bottom - this.geometry.top) / 2 + this.geometry.top
      };
    };

    return Widget;

  })();

  module.exports = Widget;

}).call(this);

},{}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
 (c) 2012, Huub de Beer, H.T.de.Beer@gmail.com
*/


(function() {
  var MeasureLine;

  MeasureLine = (function() {
    MeasureLine.EPSILON = 0.01;

    MeasureLine.prototype.to_json = function() {
      var export_object;
      export_object = {
        volume: this.volume,
        height: this.height,
        initial_position: this.initial_position,
        position: {
          x: this.position.x,
          y: this.position.y
        },
        side: this.side,
        movable: this.movable,
        visible: this.visible
      };
      return JSON.stringify(export_object);
    };

    MeasureLine.prototype.from_json = function(mljson) {
      this.volume = mljson.volume;
      this.height = mljson.height;
      this.initial_position = mljson.initial_position;
      this.position = mljson.position;
      this.side = mljson.side;
      this.movable = mljson.movable;
      return this.visible = mljson.visible;
    };

    function MeasureLine(volume, height, glass, initial_position, side, visible, movable) {
      this.volume = volume;
      this.height = height;
      this.glass = glass;
      this.initial_position = initial_position != null ? initial_position : {
        x: -1,
        y: -1
      };
      this.side = side != null ? side : 'right';
      this.visible = visible != null ? visible : false;
      this.movable = movable != null ? movable : true;
      this.set_position(this.initial_position);
    }

    MeasureLine.prototype.reset = function() {
      /*
      */

      return this.set_position(this.initial_position);
    };

    MeasureLine.prototype.hide = function() {
      return this.visible = false;
    };

    MeasureLine.prototype.show = function() {
      return this.visible = true;
    };

    MeasureLine.prototype.set_position = function(position) {
      /*
      Set the position of this measure line. Position is a point (x, y). Subsequently the height in mm can be computed.
      */

      this.position = position;
      return this.height = (this.glass.foot.y - this.position.y) / this.glass.unit;
    };

    MeasureLine.prototype.is_correct = function() {
      /*
      Is this measure line on the correct height on the glass? That is: is the error smaller than epsilon?
      */

      return Math.abs(this.error) <= MeasureLine.EPSILON;
    };

    MeasureLine.prototype.error = function() {
      /*
      The distance of this measure line to the correct position in mm. A negative error means it is too hight, a positive distance that it is too low
      */

      return (this.glass.height_at_volume(this.volume)) - this.height;
    };

    return MeasureLine;

  })();

  module.exports = MeasureLine;

}).call(this);

},{}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
(c) 2012, Huub de Beer, H.T.de.Beer@gmail.com
*/


(function() {
  var MeasureLine, WMeasureLine, Widget,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Widget = require('../widget');

  MeasureLine = require('./measure_line');

  WMeasureLine = (function(_super) {
    __extends(WMeasureLine, _super);

    function WMeasureLine(canvas, x, y, ml, foot, spec) {
      var _this = this;
      this.canvas = canvas;
      this.x = x;
      this.y = y;
      this.ml = ml;
      this.foot = foot;
      this.spec = spec != null ? spec : {};
      this.end = __bind(this.end, this);
      this.start = __bind(this.start, this);
      this.drag = __bind(this.drag, this);
      WMeasureLine.__super__.constructor.call(this, this.canvas, this.x, this.y, this.spec);
      this._draw();
      if (this.ml.movable) {
        this.widgets.mouseover(function(e) {
          return _this.border.attr({
            fill: 'gold',
            'fill-opacity': 0.25,
            'stroke-opacity': 0.75,
            cursor: 'move'
          });
        });
        this.widgets.mouseout(function(e) {
          return _this.border.attr({
            'stroke-opacity': 0,
            cursor: 'default',
            fill: 'white',
            'fill-opacity': 0
          });
        });
        this.widgets.drag(this.drag, this.start, this.end);
      }
    }

    WMeasureLine.prototype.drag = function(dx, dy, x, y, e) {
      var tx, ty;
      tx = Math.floor(dx - this.dpo.x);
      ty = Math.floor(dy - this.dpo.y);
      this.x += tx;
      this.y += ty;
      this.widgets.transform("...t" + tx + "," + ty);
      this.dpo = {
        x: dx,
        y: dy
      };
      this._compute_geometry();
      this.ml.position.x = this.x;
      this.ml.position.y = this.y;
      return this.ml.glass.change_measure_line(this.ml.volume, (this.foot - this.y) / this.ml.glass.unit);
    };

    WMeasureLine.prototype.show = function() {
      return this.widgets.show();
    };

    WMeasureLine.prototype.hide = function() {
      return this.widgets.hide();
    };

    WMeasureLine.prototype.start = function() {
      var _ref;
      this.dpo = (_ref = this.dpo) != null ? _ref : {};
      this.dpo = {
        x: 0,
        y: 0
      };
      return this.border.attr({
        'fill': 'gold',
        'fill-opacity': 0.05
      });
    };

    WMeasureLine.prototype.end = function() {
      return this.border.attr({
        'fill': 'white',
        'fill-opacity': 0
      });
    };

    WMeasureLine.prototype._draw = function() {
      var BENDINESS, LABELSKIP, TICKWIDTH, bbox, label, labelleft, tick, tickpath, _ref, _ref1, _ref2, _ref3, _ref4;
      TICKWIDTH = (_ref = this.spec['thickwidth']) != null ? _ref : 10;
      LABELSKIP = (_ref1 = this.spec['labelskip']) != null ? _ref1 : 5;
      BENDINESS = 6;
      this.bend = (_ref2 = this.spec.bend) != null ? _ref2 : false;
      switch (this.ml.side) {
        case 'right':
          if (this.bend) {
            tickpath = "M" + this.ml.position.x + "," + this.ml.position.y + "c0," + 2 + ",-" + BENDINESS + "," + BENDINESS + ",-" + TICKWIDTH + "," + BENDINESS;
          } else {
            tickpath = "M" + this.ml.position.x + "," + this.ml.position.y + "h-" + TICKWIDTH;
          }
          tick = this.canvas.path(tickpath);
          label = this.canvas.text(0, 0, "" + this.ml.volume + " ml");
          label.attr({
            'font-family': (_ref3 = this.spec['font-family']) != null ? _ref3 : 'sans-serif',
            'font-size': (_ref4 = this.spec['font-size']) != null ? _ref4 : 12,
            'text-anchor': 'start'
          });
          bbox = label.getBBox();
          labelleft = this.ml.position.x - LABELSKIP - bbox.width - TICKWIDTH;
          if (this.bend) {
            label.attr({
              x: labelleft,
              y: this.ml.position.y + BENDINESS
            });
          } else {
            label.attr({
              x: labelleft,
              y: this.ml.position.y
            });
          }
          bbox = label.getBBox();
          this.border = this.canvas.rect(bbox.x, bbox.y, bbox.width + TICKWIDTH, bbox.height);
          this.border.attr({
            stroke: 'black',
            fill: 'white',
            'fill-opacity': 0,
            'stroke-opacity': 0,
            'stroke-dasharray': '. '
          });
          break;
        case 'left':
          tickpath = "M" + this.ml.position.x + "," + this.ml.position.y + "h" + TICKWIDTH;
      }
      this.widgets.push(tick, label, this.border);
      bbox = this.widgets.getBBox();
      this.width = bbox.width;
      return this.height = bbox.height;
    };

    return WMeasureLine;

  })(Widget);

  module.exports = WMeasureLine;

}).call(this);

},{"../widget":10,"./measure_line":11}]},{},[1])
;